{"ast":null,"code":"// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport { CosmosDiagnostics } from \"../CosmosDiagnostics\";\nimport { DiagnosticNodeInternal, DiagnosticNodeType } from \"../diagnostics/DiagnosticNodeInternal\";\nimport { getCurrentTimestampInMs } from \"./time\";\nimport { CosmosDbDiagnosticLevel } from \"../diagnostics/CosmosDbDiagnosticLevel\";\nimport { randomUUID } from \"@azure/core-util\";\n/**\n * @hidden\n * Utility function to create an Empty CosmosDiagnostic object.\n */\nexport function getEmptyCosmosDiagnostics() {\n  return new CosmosDiagnostics({\n    requestDurationInMs: 0,\n    requestStartTimeUTCInMs: getCurrentTimestampInMs(),\n    totalRequestPayloadLengthInBytes: 0,\n    totalResponsePayloadLengthInBytes: 0,\n    locationEndpointsContacted: [],\n    retryDiagnostics: {\n      failedAttempts: []\n    },\n    metadataDiagnostics: {\n      metadataLookups: []\n    },\n    gatewayStatistics: []\n  }, {\n    id: randomUUID(),\n    nodeType: DiagnosticNodeType.CLIENT_REQUEST_NODE,\n    children: [],\n    data: {},\n    startTimeUTCInMs: getCurrentTimestampInMs(),\n    durationInMs: 0\n  });\n}\n/**\n * A supporting utility wrapper function, to be used inside a diagnostic session started\n * by `withDiagnostics` function.\n * Created a Diagnostic node and add it as a child to existing diagnostic session.\n * @hidden\n */\nexport async function addDignosticChild(callback, node, type, data = {}) {\n  const childNode = node.initializeChildNode(type, CosmosDbDiagnosticLevel.debug, data);\n  try {\n    const response = await callback(childNode);\n    childNode.updateTimestamp();\n    return response;\n  } catch (e) {\n    childNode.addData({\n      failure: true\n    });\n    childNode.updateTimestamp();\n    throw e;\n  }\n}\n/**\n * A supporting utility wrapper function, to be used inside a diagnostic session started\n * by `withDiagnostics` function.\n * Treats requests originating in  provided `callback` as metadata calls.\n * To realize this, starts a temporary diagnostic session, after execution of callback is\n * finished. Merges this temporary diagnostic session to the original diagnostic session\n * represented by the input parameter `node`.\n * @hidden\n */\nexport async function withMetadataDiagnostics(callback, node, type) {\n  const diagnosticNodeForMetadataCall = new DiagnosticNodeInternal(node.diagnosticLevel, DiagnosticNodeType.METADATA_REQUEST_NODE, null);\n  try {\n    const response = await callback(diagnosticNodeForMetadataCall);\n    node.addChildNode(diagnosticNodeForMetadataCall, CosmosDbDiagnosticLevel.debug, type);\n    return response;\n  } catch (e) {\n    node.addChildNode(diagnosticNodeForMetadataCall, CosmosDbDiagnosticLevel.debug, type);\n    throw e;\n  }\n}\n/**\n * Utility wrapper function to managed lifecycle of a Diagnostic session.\n * Meant to be used at the root of the client operation. i.e. item.read(),\n * queryIterator.fetchAll().\n *\n * This utility starts a new diagnostic session. So using it any where else\n * other than start of operation, will result is different diagnostic sessions.\n *\n * Workings :\n * 1. Takes a callback function as input.\n * 2. Creates a new instance of DiagnosticNodeInternal, which can be though as starting\n * a new diagnostic session.\n * 3. Executes the callback function.\n * 4. If execution was successful. Converts DiagnosticNodeInternal to CosmosDiagnostics\n * and injects it to the response object and returns this object.\n * 5. If execution threw an exception. Sill converts DiagnosticNodeInternal to CosmosDiagnostics\n * and injects it to the Error object, and rethrows the Error object.\n *\n * @hidden\n */\nexport async function withDiagnostics(callback, clientContext, type = DiagnosticNodeType.CLIENT_REQUEST_NODE) {\n  const diagnosticNode = new DiagnosticNodeInternal(clientContext.diagnosticLevel, type, null);\n  try {\n    const response = await callback(diagnosticNode);\n    diagnosticNode.updateTimestamp();\n    const diagnostics = diagnosticNode.toDiagnostic(clientContext.getClientConfig());\n    if (typeof response === \"object\" && response !== null) {\n      response.diagnostics = diagnostics;\n    }\n    clientContext.recordDiagnostics(diagnostics);\n    return response;\n  } catch (e) {\n    diagnosticNode.updateTimestamp();\n    diagnosticNode.addData({\n      failure: true\n    });\n    const diagnostics = diagnosticNode.toDiagnostic(clientContext.getClientConfig());\n    e.diagnostics = diagnostics;\n    clientContext.recordDiagnostics(diagnostics);\n    throw e;\n  }\n}","map":{"version":3,"names":["CosmosDiagnostics","DiagnosticNodeInternal","DiagnosticNodeType","getCurrentTimestampInMs","CosmosDbDiagnosticLevel","randomUUID","getEmptyCosmosDiagnostics","requestDurationInMs","requestStartTimeUTCInMs","totalRequestPayloadLengthInBytes","totalResponsePayloadLengthInBytes","locationEndpointsContacted","retryDiagnostics","failedAttempts","metadataDiagnostics","metadataLookups","gatewayStatistics","id","nodeType","CLIENT_REQUEST_NODE","children","data","startTimeUTCInMs","durationInMs","addDignosticChild","callback","node","type","childNode","initializeChildNode","debug","response","updateTimestamp","e","addData","failure","withMetadataDiagnostics","diagnosticNodeForMetadataCall","diagnosticLevel","METADATA_REQUEST_NODE","addChildNode","withDiagnostics","clientContext","diagnosticNode","diagnostics","toDiagnostic","getClientConfig","recordDiagnostics"],"sources":["/Users/ajitpawar/microsoft/bap/POCs/Scenario_checker_for_maker/mcs-scenario-checker-for-maker/node_modules/@azure/cosmos/src/utils/diagnostics.ts"],"sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\nimport type { MetadataLookUpType } from \"../CosmosDiagnostics\";\nimport { CosmosDiagnostics } from \"../CosmosDiagnostics\";\nimport type { DiagnosticDataValue } from \"../diagnostics/DiagnosticNodeInternal\";\nimport { DiagnosticNodeInternal, DiagnosticNodeType } from \"../diagnostics/DiagnosticNodeInternal\";\nimport type { ClientContext } from \"../ClientContext\";\nimport { getCurrentTimestampInMs } from \"./time\";\nimport { CosmosDbDiagnosticLevel } from \"../diagnostics/CosmosDbDiagnosticLevel\";\nimport { randomUUID } from \"@azure/core-util\";\n\n/**\n * @hidden\n * Utility function to create an Empty CosmosDiagnostic object.\n */\nexport function getEmptyCosmosDiagnostics(): CosmosDiagnostics {\n  return new CosmosDiagnostics(\n    {\n      requestDurationInMs: 0,\n      requestStartTimeUTCInMs: getCurrentTimestampInMs(),\n      totalRequestPayloadLengthInBytes: 0,\n      totalResponsePayloadLengthInBytes: 0,\n      locationEndpointsContacted: [],\n      retryDiagnostics: {\n        failedAttempts: [],\n      },\n      metadataDiagnostics: {\n        metadataLookups: [],\n      },\n      gatewayStatistics: [],\n    },\n    {\n      id: randomUUID(),\n      nodeType: DiagnosticNodeType.CLIENT_REQUEST_NODE,\n      children: [],\n      data: {},\n      startTimeUTCInMs: getCurrentTimestampInMs(),\n      durationInMs: 0,\n    },\n  );\n}\n\n/**\n * @hidden\n */\nexport type ExtractPromise<T> = T extends Promise<infer U> ? U : never;\n\n/**\n * A supporting utility wrapper function, to be used inside a diagnostic session started\n * by `withDiagnostics` function.\n * Created a Diagnostic node and add it as a child to existing diagnostic session.\n * @hidden\n */\nexport async function addDignosticChild<\n  Callback extends (node: DiagnosticNodeInternal) => Promise<any>,\n>(\n  callback: Callback,\n  node: DiagnosticNodeInternal,\n  type: DiagnosticNodeType,\n  data: Partial<DiagnosticDataValue> = {},\n): Promise<ExtractPromise<ReturnType<Callback>>> {\n  const childNode = node.initializeChildNode(type, CosmosDbDiagnosticLevel.debug, data);\n  try {\n    const response = await callback(childNode);\n    childNode.updateTimestamp();\n    return response;\n  } catch (e: any) {\n    childNode.addData({\n      failure: true,\n    });\n    childNode.updateTimestamp();\n    throw e;\n  }\n}\n\n/**\n * A supporting utility wrapper function, to be used inside a diagnostic session started\n * by `withDiagnostics` function.\n * Treats requests originating in  provided `callback` as metadata calls.\n * To realize this, starts a temporary diagnostic session, after execution of callback is\n * finished. Merges this temporary diagnostic session to the original diagnostic session\n * represented by the input parameter `node`.\n * @hidden\n */\nexport async function withMetadataDiagnostics<\n  Callback extends (node: DiagnosticNodeInternal) => Promise<any>,\n>(\n  callback: Callback,\n  node: DiagnosticNodeInternal,\n  type: MetadataLookUpType,\n): Promise<ExtractPromise<ReturnType<Callback>>> {\n  const diagnosticNodeForMetadataCall = new DiagnosticNodeInternal(\n    node.diagnosticLevel,\n    DiagnosticNodeType.METADATA_REQUEST_NODE,\n    null,\n  );\n  try {\n    const response: any = await callback(diagnosticNodeForMetadataCall);\n    node.addChildNode(diagnosticNodeForMetadataCall, CosmosDbDiagnosticLevel.debug, type);\n    return response;\n  } catch (e) {\n    node.addChildNode(diagnosticNodeForMetadataCall, CosmosDbDiagnosticLevel.debug, type);\n    throw e;\n  }\n}\n\n/**\n * Utility wrapper function to managed lifecycle of a Diagnostic session.\n * Meant to be used at the root of the client operation. i.e. item.read(),\n * queryIterator.fetchAll().\n *\n * This utility starts a new diagnostic session. So using it any where else\n * other than start of operation, will result is different diagnostic sessions.\n *\n * Workings :\n * 1. Takes a callback function as input.\n * 2. Creates a new instance of DiagnosticNodeInternal, which can be though as starting\n * a new diagnostic session.\n * 3. Executes the callback function.\n * 4. If execution was successful. Converts DiagnosticNodeInternal to CosmosDiagnostics\n * and injects it to the response object and returns this object.\n * 5. If execution threw an exception. Sill converts DiagnosticNodeInternal to CosmosDiagnostics\n * and injects it to the Error object, and rethrows the Error object.\n *\n * @hidden\n */\nexport async function withDiagnostics<\n  Callback extends (node: DiagnosticNodeInternal) => Promise<any>,\n>(\n  callback: Callback,\n  clientContext: ClientContext,\n  type: DiagnosticNodeType = DiagnosticNodeType.CLIENT_REQUEST_NODE,\n): Promise<ExtractPromise<ReturnType<Callback>>> {\n  const diagnosticNode = new DiagnosticNodeInternal(clientContext.diagnosticLevel, type, null);\n  try {\n    const response: any = await callback(diagnosticNode);\n    diagnosticNode.updateTimestamp();\n    const diagnostics = diagnosticNode.toDiagnostic(clientContext.getClientConfig());\n    if (typeof response === \"object\" && response !== null) {\n      (response as any).diagnostics = diagnostics;\n    }\n    clientContext.recordDiagnostics(diagnostics);\n    return response;\n  } catch (e: any) {\n    diagnosticNode.updateTimestamp();\n    diagnosticNode.addData({\n      failure: true,\n    });\n    const diagnostics = diagnosticNode.toDiagnostic(clientContext.getClientConfig());\n    e.diagnostics = diagnostics;\n    clientContext.recordDiagnostics(diagnostics);\n    throw e;\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}