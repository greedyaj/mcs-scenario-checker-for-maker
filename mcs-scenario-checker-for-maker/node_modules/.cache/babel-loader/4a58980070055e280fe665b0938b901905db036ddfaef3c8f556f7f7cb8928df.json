{"ast":null,"code":"// TODO: this smells funny\n/** @hidden */\nconst TYPEORDCOMPARATOR = Object.freeze({\n  NoValue: {\n    ord: 0\n  },\n  undefined: {\n    ord: 1\n  },\n  boolean: {\n    ord: 2,\n    compFunc: (a, b) => {\n      return a === b ? 0 : a > b ? 1 : -1;\n    }\n  },\n  number: {\n    ord: 4,\n    compFunc: (a, b) => {\n      return a === b ? 0 : a > b ? 1 : -1;\n    }\n  },\n  string: {\n    ord: 5,\n    compFunc: (a, b) => {\n      return a === b ? 0 : a > b ? 1 : -1;\n    }\n  }\n});\n/** @hidden */\nexport class OrderByDocumentProducerComparator {\n  constructor(sortOrder) {\n    this.sortOrder = sortOrder;\n  } // TODO: This should be an enum\n  targetPartitionKeyRangeDocProdComparator(docProd1, docProd2) {\n    const a = docProd1.getTargetParitionKeyRange()[\"minInclusive\"];\n    const b = docProd2.getTargetParitionKeyRange()[\"minInclusive\"];\n    return a === b ? 0 : a > b ? 1 : -1;\n  }\n  compare(docProd1, docProd2) {\n    // Need to check for split, since we don't want to dereference \"item\" of undefined / exception\n    if (docProd1.gotSplit()) {\n      return -1;\n    }\n    if (docProd2.gotSplit()) {\n      return 1;\n    }\n    const orderByItemsRes1 = this.getOrderByItems(docProd1.peekBufferedItems()[0]);\n    const orderByItemsRes2 = this.getOrderByItems(docProd2.peekBufferedItems()[0]);\n    // validate order by items and types\n    // TODO: once V1 order by on different types is fixed this need to change\n    this.validateOrderByItems(orderByItemsRes1, orderByItemsRes2);\n    // no async call in the for loop\n    for (let i = 0; i < orderByItemsRes1.length; i++) {\n      // compares the orderby items one by one\n      const compRes = this.compareOrderByItem(orderByItemsRes1[i], orderByItemsRes2[i]);\n      if (compRes !== 0) {\n        if (this.sortOrder[i] === \"Ascending\") {\n          return compRes;\n        } else if (this.sortOrder[i] === \"Descending\") {\n          return -compRes;\n        }\n      }\n    }\n    return this.targetPartitionKeyRangeDocProdComparator(docProd1, docProd2);\n  }\n  // TODO: This smells funny\n  compareValue(item1, type1, item2, type2) {\n    if (type1 === \"object\" || type2 === \"object\") {\n      throw new Error(\"Tried to compare an object type\");\n    }\n    const type1Ord = TYPEORDCOMPARATOR[type1].ord;\n    const type2Ord = TYPEORDCOMPARATOR[type2].ord;\n    const typeCmp = type1Ord - type2Ord;\n    if (typeCmp !== 0) {\n      // if the types are different, use type ordinal\n      return typeCmp;\n    }\n    // both are of the same type\n    if (type1Ord === TYPEORDCOMPARATOR[\"undefined\"].ord || type1Ord === TYPEORDCOMPARATOR[\"NoValue\"].ord) {\n      // if both types are undefined or Null they are equal\n      return 0;\n    }\n    const compFunc = TYPEORDCOMPARATOR[type1].compFunc;\n    if (typeof compFunc === \"undefined\") {\n      throw new Error(\"Cannot find the comparison function\");\n    }\n    // same type and type is defined compare the items\n    return compFunc(item1, item2);\n  }\n  compareOrderByItem(orderByItem1, orderByItem2) {\n    const type1 = this.getType(orderByItem1);\n    const type2 = this.getType(orderByItem2);\n    return this.compareValue(orderByItem1[\"item\"], type1, orderByItem2[\"item\"], type2);\n  }\n  validateOrderByItems(res1, res2) {\n    if (res1.length !== res2.length) {\n      throw new Error(`Expected ${res1.length}, but got ${res2.length}.`);\n    }\n    if (res1.length !== this.sortOrder.length) {\n      throw new Error(\"orderByItems cannot have a different size than sort orders.\");\n    }\n    for (let i = 0; i < this.sortOrder.length; i++) {\n      const type1 = this.getType(res1[i]);\n      const type2 = this.getType(res2[i]);\n      if (type1 !== type2) {\n        throw new Error(`Expected ${type1}, but got ${type2}. Cannot execute cross partition order-by queries on mixed types. Consider filtering your query using IS_STRING or IS_NUMBER to get around this exception.`);\n      }\n    }\n  }\n  getType(orderByItem) {\n    // TODO: any item?\n    if (orderByItem === undefined || orderByItem.item === undefined) {\n      return \"NoValue\";\n    }\n    const type = typeof orderByItem.item;\n    if (TYPEORDCOMPARATOR[type] === undefined) {\n      throw new Error(`unrecognizable type ${type}`);\n    }\n    return type;\n  }\n  getOrderByItems(res) {\n    // TODO: any res?\n    return res[\"orderByItems\"];\n  }\n}","map":{"version":3,"names":["TYPEORDCOMPARATOR","Object","freeze","NoValue","ord","undefined","boolean","compFunc","a","b","number","string","OrderByDocumentProducerComparator","constructor","sortOrder","targetPartitionKeyRangeDocProdComparator","docProd1","docProd2","getTargetParitionKeyRange","compare","gotSplit","orderByItemsRes1","getOrderByItems","peekBufferedItems","orderByItemsRes2","validateOrderByItems","i","length","compRes","compareOrderByItem","compareValue","item1","type1","item2","type2","Error","type1Ord","type2Ord","typeCmp","orderByItem1","orderByItem2","getType","res1","res2","orderByItem","item","type","res"],"sources":["/Users/ajitpawar/microsoft/bap/POCs/Scenario_checker_for_maker/mcs-scenario-checker-for-maker/node_modules/@azure/cosmos/src/queryExecutionContext/orderByDocumentProducerComparator.ts"],"sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport type { DocumentProducer } from \"./documentProducer\";\n\n// TODO: this smells funny\n/** @hidden */\nconst TYPEORDCOMPARATOR: {\n  [type: string]: { ord: number; compFunc?: (a: any, b: any) => number };\n} = Object.freeze({\n  NoValue: {\n    ord: 0,\n  },\n  undefined: {\n    ord: 1,\n  },\n  boolean: {\n    ord: 2,\n    compFunc: (a: boolean, b: boolean) => {\n      return a === b ? 0 : a > b ? 1 : -1;\n    },\n  },\n  number: {\n    ord: 4,\n    compFunc: (a: number, b: number) => {\n      return a === b ? 0 : a > b ? 1 : -1;\n    },\n  },\n  string: {\n    ord: 5,\n    compFunc: (a: string, b: string) => {\n      return a === b ? 0 : a > b ? 1 : -1;\n    },\n  },\n});\n\n/** @hidden */\nexport class OrderByDocumentProducerComparator {\n  constructor(public sortOrder: string[]) {} // TODO: This should be an enum\n\n  private targetPartitionKeyRangeDocProdComparator(\n    docProd1: DocumentProducer,\n    docProd2: DocumentProducer,\n  ): 0 | 1 | -1 {\n    const a = docProd1.getTargetParitionKeyRange()[\"minInclusive\"];\n    const b = docProd2.getTargetParitionKeyRange()[\"minInclusive\"];\n    return a === b ? 0 : a > b ? 1 : -1;\n  }\n\n  public compare(docProd1: DocumentProducer, docProd2: DocumentProducer): number {\n    // Need to check for split, since we don't want to dereference \"item\" of undefined / exception\n    if (docProd1.gotSplit()) {\n      return -1;\n    }\n    if (docProd2.gotSplit()) {\n      return 1;\n    }\n\n    const orderByItemsRes1 = this.getOrderByItems(docProd1.peekBufferedItems()[0]);\n    const orderByItemsRes2 = this.getOrderByItems(docProd2.peekBufferedItems()[0]);\n\n    // validate order by items and types\n    // TODO: once V1 order by on different types is fixed this need to change\n    this.validateOrderByItems(orderByItemsRes1, orderByItemsRes2);\n\n    // no async call in the for loop\n    for (let i = 0; i < orderByItemsRes1.length; i++) {\n      // compares the orderby items one by one\n      const compRes = this.compareOrderByItem(orderByItemsRes1[i], orderByItemsRes2[i]);\n      if (compRes !== 0) {\n        if (this.sortOrder[i] === \"Ascending\") {\n          return compRes;\n        } else if (this.sortOrder[i] === \"Descending\") {\n          return -compRes;\n        }\n      }\n    }\n\n    return this.targetPartitionKeyRangeDocProdComparator(docProd1, docProd2);\n  }\n\n  // TODO: This smells funny\n  public compareValue(item1: unknown, type1: string, item2: unknown, type2: string): number {\n    if (type1 === \"object\" || type2 === \"object\") {\n      throw new Error(\"Tried to compare an object type\");\n    }\n    const type1Ord = TYPEORDCOMPARATOR[type1].ord;\n    const type2Ord = TYPEORDCOMPARATOR[type2].ord;\n    const typeCmp = type1Ord - type2Ord;\n\n    if (typeCmp !== 0) {\n      // if the types are different, use type ordinal\n      return typeCmp;\n    }\n\n    // both are of the same type\n    if (\n      type1Ord === TYPEORDCOMPARATOR[\"undefined\"].ord ||\n      type1Ord === TYPEORDCOMPARATOR[\"NoValue\"].ord\n    ) {\n      // if both types are undefined or Null they are equal\n      return 0;\n    }\n\n    const compFunc = TYPEORDCOMPARATOR[type1].compFunc;\n    if (typeof compFunc === \"undefined\") {\n      throw new Error(\"Cannot find the comparison function\");\n    }\n    // same type and type is defined compare the items\n    return compFunc(item1, item2);\n  }\n\n  private compareOrderByItem(orderByItem1: any, orderByItem2: any): number {\n    const type1 = this.getType(orderByItem1);\n    const type2 = this.getType(orderByItem2);\n    return this.compareValue(orderByItem1[\"item\"], type1, orderByItem2[\"item\"], type2);\n  }\n\n  private validateOrderByItems(res1: string[], res2: string[]): void {\n    if (res1.length !== res2.length) {\n      throw new Error(`Expected ${res1.length}, but got ${res2.length}.`);\n    }\n    if (res1.length !== this.sortOrder.length) {\n      throw new Error(\"orderByItems cannot have a different size than sort orders.\");\n    }\n\n    for (let i = 0; i < this.sortOrder.length; i++) {\n      const type1 = this.getType(res1[i]);\n      const type2 = this.getType(res2[i]);\n      if (type1 !== type2) {\n        throw new Error(\n          `Expected ${type1}, but got ${type2}. Cannot execute cross partition order-by queries on mixed types. Consider filtering your query using IS_STRING or IS_NUMBER to get around this exception.`,\n        );\n      }\n    }\n  }\n\n  private getType(\n    orderByItem: any,\n  ):\n    | \"string\"\n    | \"number\"\n    | \"bigint\"\n    | \"boolean\"\n    | \"symbol\"\n    | \"undefined\"\n    | \"object\"\n    | \"function\"\n    | \"NoValue\" {\n    // TODO: any item?\n    if (orderByItem === undefined || orderByItem.item === undefined) {\n      return \"NoValue\";\n    }\n    const type = typeof orderByItem.item;\n    if (TYPEORDCOMPARATOR[type] === undefined) {\n      throw new Error(`unrecognizable type ${type}`);\n    }\n    return type;\n  }\n\n  private getOrderByItems(res: any): any {\n    // TODO: any res?\n    return res[\"orderByItems\"];\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}