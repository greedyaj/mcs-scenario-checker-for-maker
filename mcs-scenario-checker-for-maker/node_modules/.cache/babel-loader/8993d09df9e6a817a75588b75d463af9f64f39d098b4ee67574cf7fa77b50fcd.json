{"ast":null,"code":"// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nlet safeatob;\n// base64 character set, plus padding character (=)\nconst b64 = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\";\n// Regular expression to check formal correctness of base64 encoded strings\nconst b64re = /^(?:[A-Za-z\\d+/]{4})*?(?:[A-Za-z\\d+/]{2}(?:==)?|[A-Za-z\\d+/]{3}=?)?$/;\nif (\"function\" !== typeof atob) {\n  // atob implementation for React Native\n  safeatob = str => {\n    // atob can work with strings with whitespaces, even inside the encoded part,\n    // but only \\t, \\n, \\f, \\r and ' ', which can be stripped.\n    str = String(str).replace(/[\\t\\n\\f\\r ]+/g, \"\");\n    if (!b64re.test(str)) {\n      throw new TypeError(\"Failed to execute 'atob' on 'Window': The string to be decoded is not correctly encoded.\");\n    }\n    // Adding the padding if missing, for simplicity\n    str += \"==\".slice(2 - (str.length & 3));\n    let bitmap;\n    let result = \"\";\n    let r1;\n    let r2;\n    let i = 0;\n    for (; i < str.length;) {\n      bitmap = b64.indexOf(str.charAt(i++)) << 18 | b64.indexOf(str.charAt(i++)) << 12 | (r1 = b64.indexOf(str.charAt(i++))) << 6 | (r2 = b64.indexOf(str.charAt(i++)));\n      result += r1 === 64 ? String.fromCharCode(bitmap >> 16 & 255) : r2 === 64 ? String.fromCharCode(bitmap >> 16 & 255, bitmap >> 8 & 255) : String.fromCharCode(bitmap >> 16 & 255, bitmap >> 8 & 255, bitmap & 255);\n    }\n    return result;\n  };\n} else {\n  safeatob = atob;\n}\nexport default safeatob;","map":{"version":3,"names":["safeatob","b64","b64re","atob","str","String","replace","test","TypeError","slice","length","bitmap","result","r1","r2","i","indexOf","charAt","fromCharCode"],"sources":["/Users/ajitpawar/microsoft/bap/POCs/Scenario_checker_for_maker/mcs-scenario-checker-for-maker/node_modules/@azure/cosmos/src/utils/atob.browser.ts"],"sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\nlet safeatob: any;\n\n// base64 character set, plus padding character (=)\nconst b64 = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\";\n// Regular expression to check formal correctness of base64 encoded strings\nconst b64re = /^(?:[A-Za-z\\d+/]{4})*?(?:[A-Za-z\\d+/]{2}(?:==)?|[A-Za-z\\d+/]{3}=?)?$/;\n\nif (\"function\" !== typeof atob) {\n  // atob implementation for React Native\n  safeatob = (str: string): string => {\n    // atob can work with strings with whitespaces, even inside the encoded part,\n    // but only \\t, \\n, \\f, \\r and ' ', which can be stripped.\n    str = String(str).replace(/[\\t\\n\\f\\r ]+/g, \"\");\n    if (!b64re.test(str)) {\n      throw new TypeError(\n        \"Failed to execute 'atob' on 'Window': The string to be decoded is not correctly encoded.\",\n      );\n    }\n\n    // Adding the padding if missing, for simplicity\n    str += \"==\".slice(2 - (str.length & 3));\n    let bitmap;\n    let result = \"\";\n    let r1;\n    let r2;\n    let i = 0;\n    for (; i < str.length; ) {\n      bitmap =\n        (b64.indexOf(str.charAt(i++)) << 18) |\n        (b64.indexOf(str.charAt(i++)) << 12) |\n        ((r1 = b64.indexOf(str.charAt(i++))) << 6) |\n        (r2 = b64.indexOf(str.charAt(i++)));\n\n      result +=\n        r1 === 64\n          ? String.fromCharCode((bitmap >> 16) & 255)\n          : r2 === 64\n            ? String.fromCharCode((bitmap >> 16) & 255, (bitmap >> 8) & 255)\n            : String.fromCharCode((bitmap >> 16) & 255, (bitmap >> 8) & 255, bitmap & 255);\n    }\n    return result;\n  };\n} else {\n  safeatob = atob;\n}\n\nexport default safeatob;\n"],"mappings":"AAAA;AACA;AAEA,IAAIA,QAAa;AAEjB;AACA,MAAMC,GAAG,GAAG,mEAAmE;AAC/E;AACA,MAAMC,KAAK,GAAG,sEAAsE;AAEpF,IAAI,UAAU,KAAK,OAAOC,IAAI,EAAE;EAC9B;EACAH,QAAQ,GAAII,GAAW,IAAY;IACjC;IACA;IACAA,GAAG,GAAGC,MAAM,CAACD,GAAG,CAAC,CAACE,OAAO,CAAC,eAAe,EAAE,EAAE,CAAC;IAC9C,IAAI,CAACJ,KAAK,CAACK,IAAI,CAACH,GAAG,CAAC,EAAE;MACpB,MAAM,IAAII,SAAS,CACjB,0FAA0F,CAC3F;IACH;IAEA;IACAJ,GAAG,IAAI,IAAI,CAACK,KAAK,CAAC,CAAC,IAAIL,GAAG,CAACM,MAAM,GAAG,CAAC,CAAC,CAAC;IACvC,IAAIC,MAAM;IACV,IAAIC,MAAM,GAAG,EAAE;IACf,IAAIC,EAAE;IACN,IAAIC,EAAE;IACN,IAAIC,CAAC,GAAG,CAAC;IACT,OAAOA,CAAC,GAAGX,GAAG,CAACM,MAAM,GAAI;MACvBC,MAAM,GACHV,GAAG,CAACe,OAAO,CAACZ,GAAG,CAACa,MAAM,CAACF,CAAC,EAAE,CAAC,CAAC,IAAI,EAAE,GAClCd,GAAG,CAACe,OAAO,CAACZ,GAAG,CAACa,MAAM,CAACF,CAAC,EAAE,CAAC,CAAC,IAAI,EAAG,GACnC,CAACF,EAAE,GAAGZ,GAAG,CAACe,OAAO,CAACZ,GAAG,CAACa,MAAM,CAACF,CAAC,EAAE,CAAC,CAAC,KAAK,CAAE,IACzCD,EAAE,GAAGb,GAAG,CAACe,OAAO,CAACZ,GAAG,CAACa,MAAM,CAACF,CAAC,EAAE,CAAC,CAAC,CAAC;MAErCH,MAAM,IACJC,EAAE,KAAK,EAAE,GACLR,MAAM,CAACa,YAAY,CAAEP,MAAM,IAAI,EAAE,GAAI,GAAG,CAAC,GACzCG,EAAE,KAAK,EAAE,GACPT,MAAM,CAACa,YAAY,CAAEP,MAAM,IAAI,EAAE,GAAI,GAAG,EAAGA,MAAM,IAAI,CAAC,GAAI,GAAG,CAAC,GAC9DN,MAAM,CAACa,YAAY,CAAEP,MAAM,IAAI,EAAE,GAAI,GAAG,EAAGA,MAAM,IAAI,CAAC,GAAI,GAAG,EAAEA,MAAM,GAAG,GAAG,CAAC;IACtF;IACA,OAAOC,MAAM;EACf,CAAC;AACH,CAAC,MAAM;EACLZ,QAAQ,GAAGG,IAAI;AACjB;AAEA,eAAeH,QAAQ","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}