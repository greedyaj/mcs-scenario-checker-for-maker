{"ast":null,"code":"// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport JSBI from \"jsbi\";\nimport { BytePrefix } from \"./prefix\";\nexport function writeNumberForBinaryEncodingJSBI(hash) {\n  let payload = encodeNumberAsUInt64JSBI(hash);\n  let outputStream = Buffer.from(BytePrefix.Number, \"hex\");\n  const firstChunk = JSBI.asUintN(64, JSBI.signedRightShift(payload, JSBI.BigInt(56)));\n  outputStream = Buffer.concat([outputStream, Buffer.from(firstChunk.toString(16), \"hex\")]);\n  payload = JSBI.asUintN(64, JSBI.leftShift(JSBI.BigInt(payload), JSBI.BigInt(0x8)));\n  let byteToWrite = JSBI.BigInt(0);\n  let firstIteration = false;\n  let shifted;\n  let padded;\n  do {\n    if (!firstIteration) {\n      // we pad because after shifting because we will produce characters like \"f\" or similar,\n      // which cannot be encoded as hex in a buffer because they are invalid hex\n      // https://github.com/nodejs/node/issues/24491\n      padded = byteToWrite.toString(16).padStart(2, \"0\");\n      if (padded !== \"00\") {\n        outputStream = Buffer.concat([outputStream, Buffer.from(padded, \"hex\")]);\n      }\n    } else {\n      firstIteration = false;\n    }\n    shifted = JSBI.asUintN(64, JSBI.signedRightShift(payload, JSBI.BigInt(56)));\n    byteToWrite = JSBI.asUintN(64, JSBI.bitwiseOr(shifted, JSBI.BigInt(0x01)));\n    payload = JSBI.asUintN(64, JSBI.leftShift(payload, JSBI.BigInt(7)));\n  } while (JSBI.notEqual(payload, JSBI.BigInt(0)));\n  const lastChunk = JSBI.asUintN(64, JSBI.bitwiseAnd(byteToWrite, JSBI.BigInt(0xfe)));\n  // we pad because after shifting because we will produce characters like \"f\" or similar,\n  // which cannot be encoded as hex in a buffer because they are invalid hex\n  // https://github.com/nodejs/node/issues/24491\n  padded = lastChunk.toString(16).padStart(2, \"0\");\n  if (padded !== \"00\") {\n    outputStream = Buffer.concat([outputStream, Buffer.from(padded, \"hex\")]);\n  }\n  return outputStream;\n}\nfunction encodeNumberAsUInt64JSBI(value) {\n  const rawValueBits = getRawBitsJSBI(value);\n  const mask = JSBI.BigInt(0x8000000000000000);\n  const returned = JSBI.greaterThan(mask, rawValueBits) ? JSBI.bitwiseXor(rawValueBits, mask) : JSBI.add(JSBI.bitwiseNot(rawValueBits), JSBI.BigInt(1));\n  return returned;\n}\nexport function doubleToByteArrayJSBI(double) {\n  const output = Buffer.alloc(8);\n  const lng = getRawBitsJSBI(double);\n  for (let i = 0; i < 8; i++) {\n    output[i] = JSBI.toNumber(JSBI.bitwiseAnd(JSBI.signedRightShift(lng, JSBI.multiply(JSBI.BigInt(i), JSBI.BigInt(8))), JSBI.BigInt(0xff)));\n  }\n  return output;\n}\nfunction getRawBitsJSBI(value) {\n  const view = new DataView(new ArrayBuffer(8));\n  view.setFloat64(0, value);\n  return JSBI.BigInt(`0x${buf2hex(view.buffer)}`);\n}\nfunction buf2hex(buffer) {\n  return Array.prototype.map.call(new Uint8Array(buffer), x => (\"00\" + x.toString(16)).slice(-2)).join(\"\");\n}","map":{"version":3,"names":["JSBI","BytePrefix","writeNumberForBinaryEncodingJSBI","hash","payload","encodeNumberAsUInt64JSBI","outputStream","Buffer","from","Number","firstChunk","asUintN","signedRightShift","BigInt","concat","toString","leftShift","byteToWrite","firstIteration","shifted","padded","padStart","bitwiseOr","notEqual","lastChunk","bitwiseAnd","value","rawValueBits","getRawBitsJSBI","mask","returned","greaterThan","bitwiseXor","add","bitwiseNot","doubleToByteArrayJSBI","double","output","alloc","lng","i","toNumber","multiply","view","DataView","ArrayBuffer","setFloat64","buf2hex","buffer","Array","prototype","map","call","Uint8Array","x","slice","join"],"sources":["/Users/ajitpawar/microsoft/bap/POCs/Scenario_checker_for_maker/mcs-scenario-checker-for-maker/node_modules/@azure/cosmos/src/utils/hashing/encoding/number.ts"],"sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\nimport JSBI from \"jsbi\";\nimport { BytePrefix } from \"./prefix\";\n\nexport function writeNumberForBinaryEncodingJSBI(hash: number): Buffer {\n  let payload = encodeNumberAsUInt64JSBI(hash);\n  let outputStream = Buffer.from(BytePrefix.Number, \"hex\");\n  const firstChunk = JSBI.asUintN(64, JSBI.signedRightShift(payload, JSBI.BigInt(56)));\n\n  outputStream = Buffer.concat([outputStream, Buffer.from(firstChunk.toString(16), \"hex\")]);\n  payload = JSBI.asUintN(64, JSBI.leftShift(JSBI.BigInt(payload), JSBI.BigInt(0x8)));\n\n  let byteToWrite = JSBI.BigInt(0);\n  let firstIteration = false;\n  let shifted: JSBI;\n  let padded: string;\n\n  do {\n    if (!firstIteration) {\n      // we pad because after shifting because we will produce characters like \"f\" or similar,\n      // which cannot be encoded as hex in a buffer because they are invalid hex\n      // https://github.com/nodejs/node/issues/24491\n      padded = byteToWrite.toString(16).padStart(2, \"0\");\n      if (padded !== \"00\") {\n        outputStream = Buffer.concat([outputStream, Buffer.from(padded, \"hex\")]);\n      }\n    } else {\n      firstIteration = false;\n    }\n\n    shifted = JSBI.asUintN(64, JSBI.signedRightShift(payload, JSBI.BigInt(56)));\n    byteToWrite = JSBI.asUintN(64, JSBI.bitwiseOr(shifted, JSBI.BigInt(0x01)));\n    payload = JSBI.asUintN(64, JSBI.leftShift(payload, JSBI.BigInt(7)));\n  } while (JSBI.notEqual(payload, JSBI.BigInt(0)));\n\n  const lastChunk = JSBI.asUintN(64, JSBI.bitwiseAnd(byteToWrite, JSBI.BigInt(0xfe)));\n  // we pad because after shifting because we will produce characters like \"f\" or similar,\n  // which cannot be encoded as hex in a buffer because they are invalid hex\n  // https://github.com/nodejs/node/issues/24491\n  padded = lastChunk.toString(16).padStart(2, \"0\");\n  if (padded !== \"00\") {\n    outputStream = Buffer.concat([outputStream, Buffer.from(padded, \"hex\")]);\n  }\n\n  return outputStream;\n}\n\nfunction encodeNumberAsUInt64JSBI(value: number): JSBI {\n  const rawValueBits = getRawBitsJSBI(value);\n  const mask = JSBI.BigInt(0x8000000000000000);\n  const returned = JSBI.greaterThan(mask, rawValueBits)\n    ? JSBI.bitwiseXor(rawValueBits, mask)\n    : JSBI.add(JSBI.bitwiseNot(rawValueBits), JSBI.BigInt(1));\n  return returned;\n}\n\nexport function doubleToByteArrayJSBI(double: number): Buffer {\n  const output: Buffer = Buffer.alloc(8);\n  const lng = getRawBitsJSBI(double);\n  for (let i = 0; i < 8; i++) {\n    output[i] = JSBI.toNumber(\n      JSBI.bitwiseAnd(\n        JSBI.signedRightShift(lng, JSBI.multiply(JSBI.BigInt(i), JSBI.BigInt(8))),\n        JSBI.BigInt(0xff),\n      ),\n    );\n  }\n  return output;\n}\n\nfunction getRawBitsJSBI(value: number): JSBI {\n  const view = new DataView(new ArrayBuffer(8));\n  view.setFloat64(0, value);\n  return JSBI.BigInt(`0x${buf2hex(view.buffer)}`);\n}\n\nfunction buf2hex(buffer: ArrayBuffer): string {\n  return Array.prototype.map\n    .call(new Uint8Array(buffer), (x: number) => (\"00\" + x.toString(16)).slice(-2))\n    .join(\"\");\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}