{"ast":null,"code":"import { Constants } from \"../common/constants\";\nimport { PartitionKeyRangeCache } from \"./partitionKeyRangeCache\";\nimport { QueryRange } from \"./QueryRange\";\n/** @hidden */\nexport const PARITIONKEYRANGE = Constants.PartitionKeyRange;\n/** @hidden */\nexport class SmartRoutingMapProvider {\n  constructor(clientContext) {\n    this.partitionKeyRangeCache = new PartitionKeyRangeCache(clientContext);\n  }\n  static _secondRangeIsAfterFirstRange(range1, range2) {\n    if (typeof range1.max === \"undefined\") {\n      throw new Error(\"range1 must have max\");\n    }\n    if (typeof range2.min === \"undefined\") {\n      throw new Error(\"range2 must have min\");\n    }\n    if (range1.max > range2.min) {\n      // r.min < #previous_r.max\n      return false;\n    } else {\n      if (range1.max === range2.min && range1.isMaxInclusive && range2.isMinInclusive) {\n        // the inclusive ending endpoint of previous_r is the same as the inclusive beginning endpoint of r\n        // they share a point\n        return false;\n      }\n      return true;\n    }\n  }\n  static _isSortedAndNonOverlapping(ranges) {\n    for (let idx = 1; idx < ranges.length; idx++) {\n      const previousR = ranges[idx - 1];\n      const r = ranges[idx];\n      if (!this._secondRangeIsAfterFirstRange(previousR, r)) {\n        return false;\n      }\n    }\n    return true;\n  }\n  static _stringMax(a, b) {\n    return a >= b ? a : b;\n  }\n  static _stringCompare(a, b) {\n    return a === b ? 0 : a > b ? 1 : -1;\n  }\n  static _subtractRange(r, partitionKeyRange) {\n    const left = this._stringMax(partitionKeyRange[PARITIONKEYRANGE.MaxExclusive], r.min);\n    const leftInclusive = this._stringCompare(left, r.min) === 0 ? r.isMinInclusive : false;\n    return new QueryRange(left, r.max, leftInclusive, r.isMaxInclusive);\n  }\n  /**\n   * Given the sorted ranges and a collection, invokes the callback on the list of overlapping partition key ranges\n   * @param callback - Function execute on the overlapping partition key ranges result,\n   *                   takes two parameters error, partition key ranges\n   * @hidden\n   */\n  async getOverlappingRanges(collectionLink, sortedRanges, diagnosticNode) {\n    // validate if the list is non- overlapping and sorted                             TODO: any PartitionKeyRanges\n    if (!SmartRoutingMapProvider._isSortedAndNonOverlapping(sortedRanges)) {\n      throw new Error(\"the list of ranges is not a non-overlapping sorted ranges\");\n    }\n    let partitionKeyRanges = []; // TODO: any ParitionKeyRanges\n    if (sortedRanges.length === 0) {\n      return partitionKeyRanges;\n    }\n    const collectionRoutingMap = await this.partitionKeyRangeCache.onCollectionRoutingMap(collectionLink, diagnosticNode);\n    let index = 0;\n    let currentProvidedRange = sortedRanges[index];\n    for (;;) {\n      if (currentProvidedRange.isEmpty()) {\n        // skip and go to the next item\n        if (++index >= sortedRanges.length) {\n          return partitionKeyRanges;\n        }\n        currentProvidedRange = sortedRanges[index];\n        continue;\n      }\n      let queryRange;\n      if (partitionKeyRanges.length > 0) {\n        queryRange = SmartRoutingMapProvider._subtractRange(currentProvidedRange, partitionKeyRanges[partitionKeyRanges.length - 1]);\n      } else {\n        queryRange = currentProvidedRange;\n      }\n      const overlappingRanges = collectionRoutingMap.getOverlappingRanges(queryRange);\n      if (overlappingRanges.length <= 0) {\n        throw new Error(`error: returned overlapping ranges for queryRange ${queryRange} is empty`);\n      }\n      partitionKeyRanges = partitionKeyRanges.concat(overlappingRanges);\n      const lastKnownTargetRange = QueryRange.parsePartitionKeyRange(partitionKeyRanges[partitionKeyRanges.length - 1]);\n      if (!lastKnownTargetRange) {\n        throw new Error(\"expected lastKnowTargetRange to be truthy\");\n      }\n      // the overlapping ranges must contain the requested range\n      if (SmartRoutingMapProvider._stringCompare(currentProvidedRange.max, lastKnownTargetRange.max) > 0) {\n        throw new Error(`error: returned overlapping ranges ${overlappingRanges} \\\n        does not contain the requested range ${queryRange}`);\n      }\n      // the current range is contained in partitionKeyRanges just move forward\n      if (++index >= sortedRanges.length) {\n        return partitionKeyRanges;\n      }\n      currentProvidedRange = sortedRanges[index];\n      while (SmartRoutingMapProvider._stringCompare(currentProvidedRange.max, lastKnownTargetRange.max) <= 0) {\n        // the current range is covered too.just move forward\n        if (++index >= sortedRanges.length) {\n          return partitionKeyRanges;\n        }\n        currentProvidedRange = sortedRanges[index];\n      }\n    }\n  }\n}","map":{"version":3,"names":["Constants","PartitionKeyRangeCache","QueryRange","PARITIONKEYRANGE","PartitionKeyRange","SmartRoutingMapProvider","constructor","clientContext","partitionKeyRangeCache","_secondRangeIsAfterFirstRange","range1","range2","max","Error","min","isMaxInclusive","isMinInclusive","_isSortedAndNonOverlapping","ranges","idx","length","previousR","r","_stringMax","a","b","_stringCompare","_subtractRange","partitionKeyRange","left","MaxExclusive","leftInclusive","getOverlappingRanges","collectionLink","sortedRanges","diagnosticNode","partitionKeyRanges","collectionRoutingMap","onCollectionRoutingMap","index","currentProvidedRange","isEmpty","queryRange","overlappingRanges","concat","lastKnownTargetRange","parsePartitionKeyRange"],"sources":["/Users/ajitpawar/microsoft/bap/POCs/Scenario_checker_for_maker/mcs-scenario-checker-for-maker/node_modules/@azure/cosmos/src/routing/smartRoutingMapProvider.ts"],"sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport type { ClientContext } from \"../ClientContext\";\nimport { Constants } from \"../common/constants\";\nimport type { DiagnosticNodeInternal } from \"../diagnostics/DiagnosticNodeInternal\";\nimport { PartitionKeyRangeCache } from \"./partitionKeyRangeCache\";\nimport { QueryRange } from \"./QueryRange\";\n\n/** @hidden */\nexport const PARITIONKEYRANGE = Constants.PartitionKeyRange;\n\n/** @hidden */\nexport class SmartRoutingMapProvider {\n  private partitionKeyRangeCache: PartitionKeyRangeCache;\n\n  constructor(clientContext: ClientContext) {\n    this.partitionKeyRangeCache = new PartitionKeyRangeCache(clientContext);\n  }\n  private static _secondRangeIsAfterFirstRange(range1: QueryRange, range2: QueryRange): boolean {\n    if (typeof range1.max === \"undefined\") {\n      throw new Error(\"range1 must have max\");\n    }\n\n    if (typeof range2.min === \"undefined\") {\n      throw new Error(\"range2 must have min\");\n    }\n\n    if (range1.max > range2.min) {\n      // r.min < #previous_r.max\n      return false;\n    } else {\n      if (range1.max === range2.min && range1.isMaxInclusive && range2.isMinInclusive) {\n        // the inclusive ending endpoint of previous_r is the same as the inclusive beginning endpoint of r\n        // they share a point\n        return false;\n      }\n      return true;\n    }\n  }\n\n  private static _isSortedAndNonOverlapping(ranges: QueryRange[]): boolean {\n    for (let idx = 1; idx < ranges.length; idx++) {\n      const previousR = ranges[idx - 1];\n      const r = ranges[idx];\n      if (!this._secondRangeIsAfterFirstRange(previousR, r)) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  private static _stringMax(a: string, b: string): string {\n    return a >= b ? a : b;\n  }\n\n  private static _stringCompare(a: string, b: string): 1 | 0 | -1 {\n    return a === b ? 0 : a > b ? 1 : -1;\n  }\n\n  private static _subtractRange(r: QueryRange, partitionKeyRange: any): QueryRange {\n    const left = this._stringMax(partitionKeyRange[PARITIONKEYRANGE.MaxExclusive], r.min);\n    const leftInclusive = this._stringCompare(left, r.min) === 0 ? r.isMinInclusive : false;\n    return new QueryRange(left, r.max, leftInclusive, r.isMaxInclusive);\n  }\n\n  /**\n   * Given the sorted ranges and a collection, invokes the callback on the list of overlapping partition key ranges\n   * @param callback - Function execute on the overlapping partition key ranges result,\n   *                   takes two parameters error, partition key ranges\n   * @hidden\n   */\n  public async getOverlappingRanges(\n    collectionLink: string,\n    sortedRanges: QueryRange[],\n    diagnosticNode: DiagnosticNodeInternal,\n  ): Promise<any[]> {\n    // validate if the list is non- overlapping and sorted                             TODO: any PartitionKeyRanges\n    if (!SmartRoutingMapProvider._isSortedAndNonOverlapping(sortedRanges)) {\n      throw new Error(\"the list of ranges is not a non-overlapping sorted ranges\");\n    }\n\n    let partitionKeyRanges: any[] = []; // TODO: any ParitionKeyRanges\n\n    if (sortedRanges.length === 0) {\n      return partitionKeyRanges;\n    }\n\n    const collectionRoutingMap = await this.partitionKeyRangeCache.onCollectionRoutingMap(\n      collectionLink,\n      diagnosticNode,\n    );\n\n    let index = 0;\n    let currentProvidedRange = sortedRanges[index];\n    for (;;) {\n      if (currentProvidedRange.isEmpty()) {\n        // skip and go to the next item\n        if (++index >= sortedRanges.length) {\n          return partitionKeyRanges;\n        }\n        currentProvidedRange = sortedRanges[index];\n        continue;\n      }\n\n      let queryRange;\n      if (partitionKeyRanges.length > 0) {\n        queryRange = SmartRoutingMapProvider._subtractRange(\n          currentProvidedRange,\n          partitionKeyRanges[partitionKeyRanges.length - 1],\n        );\n      } else {\n        queryRange = currentProvidedRange;\n      }\n\n      const overlappingRanges = collectionRoutingMap.getOverlappingRanges(queryRange);\n      if (overlappingRanges.length <= 0) {\n        throw new Error(`error: returned overlapping ranges for queryRange ${queryRange} is empty`);\n      }\n      partitionKeyRanges = partitionKeyRanges.concat(overlappingRanges);\n\n      const lastKnownTargetRange = QueryRange.parsePartitionKeyRange(\n        partitionKeyRanges[partitionKeyRanges.length - 1],\n      );\n      if (!lastKnownTargetRange) {\n        throw new Error(\"expected lastKnowTargetRange to be truthy\");\n      }\n      // the overlapping ranges must contain the requested range\n\n      if (\n        SmartRoutingMapProvider._stringCompare(currentProvidedRange.max, lastKnownTargetRange.max) >\n        0\n      ) {\n        throw new Error(`error: returned overlapping ranges ${overlappingRanges} \\\n        does not contain the requested range ${queryRange}`);\n      }\n\n      // the current range is contained in partitionKeyRanges just move forward\n      if (++index >= sortedRanges.length) {\n        return partitionKeyRanges;\n      }\n      currentProvidedRange = sortedRanges[index];\n\n      while (\n        SmartRoutingMapProvider._stringCompare(\n          currentProvidedRange.max,\n          lastKnownTargetRange.max,\n        ) <= 0\n      ) {\n        // the current range is covered too.just move forward\n        if (++index >= sortedRanges.length) {\n          return partitionKeyRanges;\n        }\n        currentProvidedRange = sortedRanges[index];\n      }\n    }\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}