{"ast":null,"code":"import { Constants } from \"../common\";\n/** @hidden */\nexport class QueryRange {\n  /**\n   * Represents a QueryRange.\n   *\n   * @param rangeMin                - min\n   * @param rangeMin                - max\n   * @param isMinInclusive         - isMinInclusive\n   * @param isMaxInclusive         - isMaxInclusive\n   * @hidden\n   */\n  constructor(rangeMin, rangeMax, isMinInclusive, isMaxInclusive) {\n    this.min = rangeMin;\n    this.max = rangeMax;\n    this.isMinInclusive = isMinInclusive;\n    this.isMaxInclusive = isMaxInclusive;\n  }\n  overlaps(other) {\n    const range1 = this; // eslint-disable-line @typescript-eslint/no-this-alias\n    const range2 = other;\n    if (range1 === undefined || range2 === undefined) {\n      return false;\n    }\n    if (range1.isEmpty() || range2.isEmpty()) {\n      return false;\n    }\n    if (range1.min <= range2.max || range2.min <= range1.max) {\n      if (range1.min === range2.max && !(range1.isMinInclusive && range2.isMaxInclusive) || range2.min === range1.max && !(range2.isMinInclusive && range1.isMaxInclusive)) {\n        return false;\n      }\n      return true;\n    }\n    return false;\n  }\n  isFullRange() {\n    return this.min === Constants.EffectivePartitionKeyConstants.MinimumInclusiveEffectivePartitionKey && this.max === Constants.EffectivePartitionKeyConstants.MaximumExclusiveEffectivePartitionKey && this.isMinInclusive === true && this.isMaxInclusive === false;\n  }\n  isEmpty() {\n    return !(this.isMinInclusive && this.isMaxInclusive) && this.min === this.max;\n  }\n  /**\n   * Parse a QueryRange from a partitionKeyRange\n   * @returns QueryRange\n   * @hidden\n   */\n  static parsePartitionKeyRange(partitionKeyRange) {\n    return new QueryRange(partitionKeyRange[Constants.PartitionKeyRange.MinInclusive], partitionKeyRange[Constants.PartitionKeyRange.MaxExclusive], true, false);\n  }\n  /**\n   * Parse a QueryRange from a dictionary\n   * @returns QueryRange\n   * @hidden\n   */\n  static parseFromDict(queryRangeDict) {\n    return new QueryRange(queryRangeDict.min, queryRangeDict.max, queryRangeDict.isMinInclusive, queryRangeDict.isMaxInclusive);\n  }\n}","map":{"version":3,"names":["Constants","QueryRange","constructor","rangeMin","rangeMax","isMinInclusive","isMaxInclusive","min","max","overlaps","other","range1","range2","undefined","isEmpty","isFullRange","EffectivePartitionKeyConstants","MinimumInclusiveEffectivePartitionKey","MaximumExclusiveEffectivePartitionKey","parsePartitionKeyRange","partitionKeyRange","PartitionKeyRange","MinInclusive","MaxExclusive","parseFromDict","queryRangeDict"],"sources":["/Users/ajitpawar/microsoft/bap/POCs/Scenario_checker_for_maker/mcs-scenario-checker-for-maker/node_modules/@azure/cosmos/src/routing/QueryRange.ts"],"sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport type { PartitionKeyRange } from \"../client/Container/PartitionKeyRange\";\nimport { Constants } from \"../common\";\nimport type { QueryRange as ResponseQueryRange } from \"../request/ErrorResponse\";\n\n/** @hidden */\nexport class QueryRange {\n  public min: string;\n  public max: string;\n  public isMinInclusive: boolean;\n  public isMaxInclusive: boolean;\n\n  /**\n   * Represents a QueryRange.\n   *\n   * @param rangeMin                - min\n   * @param rangeMin                - max\n   * @param isMinInclusive         - isMinInclusive\n   * @param isMaxInclusive         - isMaxInclusive\n   * @hidden\n   */\n  constructor(\n    rangeMin: string,\n    rangeMax: string,\n    isMinInclusive: boolean,\n    isMaxInclusive: boolean,\n  ) {\n    this.min = rangeMin;\n    this.max = rangeMax;\n    this.isMinInclusive = isMinInclusive;\n    this.isMaxInclusive = isMaxInclusive;\n  }\n  public overlaps(other: QueryRange): boolean {\n    const range1 = this; // eslint-disable-line @typescript-eslint/no-this-alias\n    const range2 = other;\n    if (range1 === undefined || range2 === undefined) {\n      return false;\n    }\n    if (range1.isEmpty() || range2.isEmpty()) {\n      return false;\n    }\n\n    if (range1.min <= range2.max || range2.min <= range1.max) {\n      if (\n        (range1.min === range2.max && !(range1.isMinInclusive && range2.isMaxInclusive)) ||\n        (range2.min === range1.max && !(range2.isMinInclusive && range1.isMaxInclusive))\n      ) {\n        return false;\n      }\n      return true;\n    }\n    return false;\n  }\n\n  public isFullRange(): boolean {\n    return (\n      this.min === Constants.EffectivePartitionKeyConstants.MinimumInclusiveEffectivePartitionKey &&\n      this.max === Constants.EffectivePartitionKeyConstants.MaximumExclusiveEffectivePartitionKey &&\n      this.isMinInclusive === true &&\n      this.isMaxInclusive === false\n    );\n  }\n\n  public isEmpty(): boolean {\n    return !(this.isMinInclusive && this.isMaxInclusive) && this.min === this.max;\n  }\n  /**\n   * Parse a QueryRange from a partitionKeyRange\n   * @returns QueryRange\n   * @hidden\n   */\n  public static parsePartitionKeyRange(partitionKeyRange: PartitionKeyRange): QueryRange {\n    return new QueryRange(\n      partitionKeyRange[Constants.PartitionKeyRange.MinInclusive],\n      partitionKeyRange[Constants.PartitionKeyRange.MaxExclusive],\n      true,\n      false,\n    );\n  }\n  /**\n   * Parse a QueryRange from a dictionary\n   * @returns QueryRange\n   * @hidden\n   */\n  public static parseFromDict(queryRangeDict: ResponseQueryRange): QueryRange {\n    return new QueryRange(\n      queryRangeDict.min,\n      queryRangeDict.max,\n      queryRangeDict.isMinInclusive,\n      queryRangeDict.isMaxInclusive,\n    );\n  }\n}\n"],"mappings":"AAGA,SAASA,SAAS,QAAQ,WAAW;AAGrC;AACA,OAAM,MAAOC,UAAU;EAMrB;;;;;;;;;EASAC,YACEC,QAAgB,EAChBC,QAAgB,EAChBC,cAAuB,EACvBC,cAAuB;IAEvB,IAAI,CAACC,GAAG,GAAGJ,QAAQ;IACnB,IAAI,CAACK,GAAG,GAAGJ,QAAQ;IACnB,IAAI,CAACC,cAAc,GAAGA,cAAc;IACpC,IAAI,CAACC,cAAc,GAAGA,cAAc;EACtC;EACOG,QAAQA,CAACC,KAAiB;IAC/B,MAAMC,MAAM,GAAG,IAAI,CAAC,CAAC;IACrB,MAAMC,MAAM,GAAGF,KAAK;IACpB,IAAIC,MAAM,KAAKE,SAAS,IAAID,MAAM,KAAKC,SAAS,EAAE;MAChD,OAAO,KAAK;IACd;IACA,IAAIF,MAAM,CAACG,OAAO,EAAE,IAAIF,MAAM,CAACE,OAAO,EAAE,EAAE;MACxC,OAAO,KAAK;IACd;IAEA,IAAIH,MAAM,CAACJ,GAAG,IAAIK,MAAM,CAACJ,GAAG,IAAII,MAAM,CAACL,GAAG,IAAII,MAAM,CAACH,GAAG,EAAE;MACxD,IACGG,MAAM,CAACJ,GAAG,KAAKK,MAAM,CAACJ,GAAG,IAAI,EAAEG,MAAM,CAACN,cAAc,IAAIO,MAAM,CAACN,cAAc,CAAC,IAC9EM,MAAM,CAACL,GAAG,KAAKI,MAAM,CAACH,GAAG,IAAI,EAAEI,MAAM,CAACP,cAAc,IAAIM,MAAM,CAACL,cAAc,CAAE,EAChF;QACA,OAAO,KAAK;MACd;MACA,OAAO,IAAI;IACb;IACA,OAAO,KAAK;EACd;EAEOS,WAAWA,CAAA;IAChB,OACE,IAAI,CAACR,GAAG,KAAKP,SAAS,CAACgB,8BAA8B,CAACC,qCAAqC,IAC3F,IAAI,CAACT,GAAG,KAAKR,SAAS,CAACgB,8BAA8B,CAACE,qCAAqC,IAC3F,IAAI,CAACb,cAAc,KAAK,IAAI,IAC5B,IAAI,CAACC,cAAc,KAAK,KAAK;EAEjC;EAEOQ,OAAOA,CAAA;IACZ,OAAO,EAAE,IAAI,CAACT,cAAc,IAAI,IAAI,CAACC,cAAc,CAAC,IAAI,IAAI,CAACC,GAAG,KAAK,IAAI,CAACC,GAAG;EAC/E;EACA;;;;;EAKO,OAAOW,sBAAsBA,CAACC,iBAAoC;IACvE,OAAO,IAAInB,UAAU,CACnBmB,iBAAiB,CAACpB,SAAS,CAACqB,iBAAiB,CAACC,YAAY,CAAC,EAC3DF,iBAAiB,CAACpB,SAAS,CAACqB,iBAAiB,CAACE,YAAY,CAAC,EAC3D,IAAI,EACJ,KAAK,CACN;EACH;EACA;;;;;EAKO,OAAOC,aAAaA,CAACC,cAAkC;IAC5D,OAAO,IAAIxB,UAAU,CACnBwB,cAAc,CAAClB,GAAG,EAClBkB,cAAc,CAACjB,GAAG,EAClBiB,cAAc,CAACpB,cAAc,EAC7BoB,cAAc,CAACnB,cAAc,CAC9B;EACH","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}