{"ast":null,"code":"import { OperationType } from \"./constants\";\nconst trimLeftSlashes = new RegExp(\"^[/]+\");\nconst trimRightSlashes = new RegExp(\"[/]+$\");\nconst illegalResourceIdCharacters = new RegExp(\"[/\\\\\\\\?#]\");\nconst illegalItemResourceIdCharacters = new RegExp(\"[/\\\\\\\\#]\");\n/** @hidden */\nexport function jsonStringifyAndEscapeNonASCII(arg) {\n  // TODO: better way for this? Not sure.\n  // escapes non-ASCII characters as \\uXXXX\n  return JSON.stringify(arg).replace(/[\\u007F-\\uFFFF]/g, m => {\n    return \"\\\\u\" + (\"0000\" + m.charCodeAt(0).toString(16)).slice(-4);\n  });\n}\n/**\n * @hidden\n */\nexport function parseLink(resourcePath) {\n  if (resourcePath.length === 0) {\n    /* for DatabaseAccount case, both type and objectBody will be undefined. */\n    return {\n      type: undefined,\n      objectBody: undefined\n    };\n  }\n  if (resourcePath[resourcePath.length - 1] !== \"/\") {\n    resourcePath = resourcePath + \"/\";\n  }\n  if (resourcePath[0] !== \"/\") {\n    resourcePath = \"/\" + resourcePath;\n  }\n  /*\n         The path will be in the form of /[resourceType]/[resourceId]/ ....\n         /[resourceType]//[resourceType]/[resourceId]/ .... /[resourceType]/[resourceId]/\n         or /[resourceType]/[resourceId]/ .... /[resourceType]/[resourceId]/[resourceType]/[resourceId]/ ....\n          /[resourceType]/[resourceId]/\n         The result of split will be in the form of\n         [[[resourceType], [resourceId] ... ,[resourceType], [resourceId], \"\"]\n         In the first case, to extract the resourceId it will the element before last ( at length -2 )\n         and the type will be before it ( at length -3 )\n         In the second case, to extract the resource type it will the element before last ( at length -2 )\n        */\n  const pathParts = resourcePath.split(\"/\");\n  let id;\n  let type;\n  if (pathParts.length % 2 === 0) {\n    // request in form /[resourceType]/[resourceId]/ .... /[resourceType]/[resourceId].\n    id = pathParts[pathParts.length - 2];\n    type = pathParts[pathParts.length - 3];\n  } else {\n    // request in form /[resourceType]/[resourceId]/ .... /[resourceType]/.\n    id = pathParts[pathParts.length - 3];\n    type = pathParts[pathParts.length - 2];\n  }\n  const result = {\n    type,\n    objectBody: {\n      id,\n      self: resourcePath\n    }\n  };\n  return result;\n}\n/**\n * @hidden\n */\nexport function isReadRequest(operationType) {\n  return operationType === OperationType.Read || operationType === OperationType.Query;\n}\n/**\n * @hidden\n */\nexport function sleep(time) {\n  return new Promise(resolve => {\n    setTimeout(() => {\n      resolve();\n    }, time);\n  });\n}\n/**\n * @hidden\n */\nexport function getContainerLink(link) {\n  return link.split(\"/\").slice(0, 4).join(\"/\");\n}\n/**\n * @hidden\n */\nexport function prepareURL(endpoint, path) {\n  return trimSlashes(endpoint) + path;\n}\n/**\n * @hidden\n */\nexport function trimSlashes(source) {\n  return source.replace(trimLeftSlashes, \"\").replace(trimRightSlashes, \"\");\n}\n/**\n * @hidden\n */\nexport function getHexaDigit() {\n  return Math.floor(Math.random() * 16).toString(16);\n}\n/**\n * @hidden\n */\nexport function parsePath(path) {\n  const pathParts = [];\n  let currentIndex = 0;\n  const throwError = () => {\n    throw new Error(\"Path \" + path + \" is invalid at index \" + currentIndex);\n  };\n  const getEscapedToken = () => {\n    const quote = path[currentIndex];\n    let newIndex = ++currentIndex;\n    for (;;) {\n      newIndex = path.indexOf(quote, newIndex);\n      if (newIndex === -1) {\n        throwError();\n      }\n      if (path[newIndex - 1] !== \"\\\\\") {\n        break;\n      }\n      ++newIndex;\n    }\n    const token = path.substr(currentIndex, newIndex - currentIndex);\n    currentIndex = newIndex + 1;\n    return token;\n  };\n  const getToken = () => {\n    const newIndex = path.indexOf(\"/\", currentIndex);\n    let token = null;\n    if (newIndex === -1) {\n      token = path.substr(currentIndex);\n      currentIndex = path.length;\n    } else {\n      token = path.substr(currentIndex, newIndex - currentIndex);\n      currentIndex = newIndex;\n    }\n    token = token.trim();\n    return token;\n  };\n  while (currentIndex < path.length) {\n    if (path[currentIndex] !== \"/\") {\n      throwError();\n    }\n    if (++currentIndex === path.length) {\n      break;\n    }\n    if (path[currentIndex] === '\"' || path[currentIndex] === \"'\") {\n      pathParts.push(getEscapedToken());\n    } else {\n      pathParts.push(getToken());\n    }\n  }\n  return pathParts;\n}\n/**\n * @hidden\n */\nexport function isResourceValid(resource, err) {\n  // TODO: fix strictness issues so that caller contexts respects the types of the functions\n  if (resource.id) {\n    if (typeof resource.id !== \"string\") {\n      err.message = \"Id must be a string.\";\n      return false;\n    }\n    if (resource.id.indexOf(\"/\") !== -1 || resource.id.indexOf(\"\\\\\") !== -1 || resource.id.indexOf(\"?\") !== -1 || resource.id.indexOf(\"#\") !== -1) {\n      err.message = \"Id contains illegal chars.\";\n      return false;\n    }\n    if (resource.id[resource.id.length - 1] === \" \") {\n      err.message = \"Id ends with a space.\";\n      return false;\n    }\n  }\n  return true;\n}\n/**\n * @hidden\n */\nexport function isItemResourceValid(resource, err) {\n  // TODO: fix strictness issues so that caller contexts respects the types of the functions\n  if (resource.id) {\n    if (typeof resource.id !== \"string\") {\n      err.message = \"Id must be a string.\";\n      return false;\n    }\n    if (resource.id.indexOf(\"/\") !== -1 || resource.id.indexOf(\"\\\\\") !== -1 || resource.id.indexOf(\"#\") !== -1) {\n      err.message = \"Id contains illegal chars.\";\n      return false;\n    }\n  }\n  return true;\n}\n/** @hidden */\nexport function getIdFromLink(resourceLink) {\n  resourceLink = trimSlashes(resourceLink);\n  return resourceLink;\n}\n/** @hidden */\nexport function getPathFromLink(resourceLink, resourceType) {\n  resourceLink = trimSlashes(resourceLink);\n  if (resourceType) {\n    return \"/\" + encodeURI(resourceLink) + \"/\" + resourceType;\n  } else {\n    return \"/\" + encodeURI(resourceLink);\n  }\n}\n/**\n * @hidden\n */\nexport function isStringNullOrEmpty(inputString) {\n  // checks whether string is null, undefined, empty or only contains space\n  return !inputString || /^\\s*$/.test(inputString);\n}\n/**\n * @hidden\n */\nexport function trimSlashFromLeftAndRight(inputString) {\n  if (typeof inputString !== \"string\") {\n    throw new Error(\"invalid input: input is not string\");\n  }\n  return inputString.replace(trimLeftSlashes, \"\").replace(trimRightSlashes, \"\");\n}\n/**\n * @hidden\n */\nexport function validateResourceId(resourceId) {\n  // if resourceId is not a string or is empty throw an error\n  if (typeof resourceId !== \"string\" || isStringNullOrEmpty(resourceId)) {\n    throw new Error(\"Resource ID must be a string and cannot be undefined, null or empty\");\n  }\n  // if resource id contains illegal characters throw an error\n  if (illegalResourceIdCharacters.test(resourceId)) {\n    throw new Error(\"Illegal characters ['/', '\\\\', '#', '?'] cannot be used in Resource ID\");\n  }\n  return true;\n}\n/**\n * @hidden\n */\nexport function validateItemResourceId(resourceId) {\n  // if resourceId is not a string or is empty throw an error\n  if (typeof resourceId !== \"string\" || isStringNullOrEmpty(resourceId)) {\n    throw new Error(\"Resource ID must be a string and cannot be undefined, null or empty\");\n  }\n  // if resource id contains illegal characters throw an error\n  if (illegalItemResourceIdCharacters.test(resourceId)) {\n    throw new Error(\"Illegal characters ['/', '\\\\', '#'] cannot be used in Resource ID\");\n  }\n  return true;\n}\n/**\n * @hidden\n */\nexport function getResourceIdFromPath(resourcePath) {\n  if (!resourcePath || typeof resourcePath !== \"string\") {\n    return null;\n  }\n  const trimmedPath = trimSlashFromLeftAndRight(resourcePath);\n  const pathSegments = trimmedPath.split(\"/\");\n  // number of segments of a path must always be even\n  if (pathSegments.length % 2 !== 0) {\n    return null;\n  }\n  return pathSegments[pathSegments.length - 1];\n}\n/**\n * @hidden\n */\nexport function parseConnectionString(connectionString) {\n  const keyValueStrings = connectionString.split(\";\");\n  const {\n    AccountEndpoint,\n    AccountKey\n  } = keyValueStrings.reduce((connectionObject, keyValueString) => {\n    const [key, ...value] = keyValueString.split(\"=\");\n    connectionObject[key] = value.join(\"=\");\n    return connectionObject;\n  }, {});\n  if (!AccountEndpoint || !AccountKey) {\n    throw new Error(\"Could not parse the provided connection string\");\n  }\n  return {\n    endpoint: AccountEndpoint,\n    key: AccountKey\n  };\n}","map":{"version":3,"names":["OperationType","trimLeftSlashes","RegExp","trimRightSlashes","illegalResourceIdCharacters","illegalItemResourceIdCharacters","jsonStringifyAndEscapeNonASCII","arg","JSON","stringify","replace","m","charCodeAt","toString","slice","parseLink","resourcePath","length","type","undefined","objectBody","pathParts","split","id","result","self","isReadRequest","operationType","Read","Query","sleep","time","Promise","resolve","setTimeout","getContainerLink","link","join","prepareURL","endpoint","path","trimSlashes","source","getHexaDigit","Math","floor","random","parsePath","currentIndex","throwError","Error","getEscapedToken","quote","newIndex","indexOf","token","substr","getToken","trim","push","isResourceValid","resource","err","message","isItemResourceValid","getIdFromLink","resourceLink","getPathFromLink","resourceType","encodeURI","isStringNullOrEmpty","inputString","test","trimSlashFromLeftAndRight","validateResourceId","resourceId","validateItemResourceId","getResourceIdFromPath","trimmedPath","pathSegments","parseConnectionString","connectionString","keyValueStrings","AccountEndpoint","AccountKey","reduce","connectionObject","keyValueString","key","value"],"sources":["/Users/ajitpawar/microsoft/bap/POCs/Scenario_checker_for_maker/mcs-scenario-checker-for-maker/node_modules/@azure/cosmos/src/common/helper.ts"],"sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport type { CosmosClientOptions } from \"../CosmosClientOptions\";\nimport type { ResourceType } from \"./constants\";\nimport { OperationType } from \"./constants\";\n\nconst trimLeftSlashes = new RegExp(\"^[/]+\");\nconst trimRightSlashes = new RegExp(\"[/]+$\");\nconst illegalResourceIdCharacters = new RegExp(\"[/\\\\\\\\?#]\");\nconst illegalItemResourceIdCharacters = new RegExp(\"[/\\\\\\\\#]\");\n\n/** @hidden */\nexport function jsonStringifyAndEscapeNonASCII(arg: unknown): string {\n  // TODO: better way for this? Not sure.\n  // escapes non-ASCII characters as \\uXXXX\n  return JSON.stringify(arg).replace(/[\\u007F-\\uFFFF]/g, (m) => {\n    return \"\\\\u\" + (\"0000\" + m.charCodeAt(0).toString(16)).slice(-4);\n  });\n}\n\n/**\n * @hidden\n */\nexport function parseLink(resourcePath: string): {\n  type: ResourceType;\n  objectBody: {\n    id: string;\n    self: string;\n  };\n} {\n  if (resourcePath.length === 0) {\n    /* for DatabaseAccount case, both type and objectBody will be undefined. */\n    return {\n      type: undefined,\n      objectBody: undefined,\n    };\n  }\n\n  if (resourcePath[resourcePath.length - 1] !== \"/\") {\n    resourcePath = resourcePath + \"/\";\n  }\n\n  if (resourcePath[0] !== \"/\") {\n    resourcePath = \"/\" + resourcePath;\n  }\n\n  /*\n         The path will be in the form of /[resourceType]/[resourceId]/ ....\n         /[resourceType]//[resourceType]/[resourceId]/ .... /[resourceType]/[resourceId]/\n         or /[resourceType]/[resourceId]/ .... /[resourceType]/[resourceId]/[resourceType]/[resourceId]/ ....\n          /[resourceType]/[resourceId]/\n         The result of split will be in the form of\n         [[[resourceType], [resourceId] ... ,[resourceType], [resourceId], \"\"]\n         In the first case, to extract the resourceId it will the element before last ( at length -2 )\n         and the type will be before it ( at length -3 )\n         In the second case, to extract the resource type it will the element before last ( at length -2 )\n        */\n  const pathParts = resourcePath.split(\"/\");\n  let id;\n  let type: ResourceType;\n  if (pathParts.length % 2 === 0) {\n    // request in form /[resourceType]/[resourceId]/ .... /[resourceType]/[resourceId].\n    id = pathParts[pathParts.length - 2];\n    type = pathParts[pathParts.length - 3] as ResourceType;\n  } else {\n    // request in form /[resourceType]/[resourceId]/ .... /[resourceType]/.\n    id = pathParts[pathParts.length - 3];\n    type = pathParts[pathParts.length - 2] as ResourceType;\n  }\n\n  const result = {\n    type,\n    objectBody: {\n      id,\n      self: resourcePath,\n    },\n  };\n\n  return result;\n}\n\n/**\n * @hidden\n */\nexport function isReadRequest(operationType: OperationType): boolean {\n  return operationType === OperationType.Read || operationType === OperationType.Query;\n}\n\n/**\n * @hidden\n */\nexport function sleep(time: number): Promise<void> {\n  return new Promise((resolve) => {\n    setTimeout(() => {\n      resolve();\n    }, time);\n  });\n}\n\n/**\n * @hidden\n */\nexport function getContainerLink(link: string): string {\n  return link.split(\"/\").slice(0, 4).join(\"/\");\n}\n\n/**\n * @hidden\n */\nexport function prepareURL(endpoint: string, path: string): string {\n  return trimSlashes(endpoint) + path;\n}\n\n/**\n * @hidden\n */\nexport function trimSlashes(source: string): string {\n  return source.replace(trimLeftSlashes, \"\").replace(trimRightSlashes, \"\");\n}\n\n/**\n * @hidden\n */\nexport function getHexaDigit(): string {\n  return Math.floor(Math.random() * 16).toString(16);\n}\n\n/**\n * @hidden\n */\nexport function parsePath(path: string): string[] {\n  const pathParts = [];\n  let currentIndex = 0;\n\n  const throwError = (): never => {\n    throw new Error(\"Path \" + path + \" is invalid at index \" + currentIndex);\n  };\n\n  const getEscapedToken = (): string => {\n    const quote = path[currentIndex];\n    let newIndex = ++currentIndex;\n\n    for (;;) {\n      newIndex = path.indexOf(quote, newIndex);\n      if (newIndex === -1) {\n        throwError();\n      }\n\n      if (path[newIndex - 1] !== \"\\\\\") {\n        break;\n      }\n\n      ++newIndex;\n    }\n\n    const token = path.substr(currentIndex, newIndex - currentIndex);\n    currentIndex = newIndex + 1;\n    return token;\n  };\n\n  const getToken = (): string => {\n    const newIndex = path.indexOf(\"/\", currentIndex);\n    let token = null;\n    if (newIndex === -1) {\n      token = path.substr(currentIndex);\n      currentIndex = path.length;\n    } else {\n      token = path.substr(currentIndex, newIndex - currentIndex);\n      currentIndex = newIndex;\n    }\n\n    token = token.trim();\n    return token;\n  };\n\n  while (currentIndex < path.length) {\n    if (path[currentIndex] !== \"/\") {\n      throwError();\n    }\n\n    if (++currentIndex === path.length) {\n      break;\n    }\n\n    if (path[currentIndex] === '\"' || path[currentIndex] === \"'\") {\n      pathParts.push(getEscapedToken());\n    } else {\n      pathParts.push(getToken());\n    }\n  }\n\n  return pathParts;\n}\n\n/**\n * @hidden\n */\nexport function isResourceValid(resource: { id?: string }, err: { message?: string }): boolean {\n  // TODO: fix strictness issues so that caller contexts respects the types of the functions\n  if (resource.id) {\n    if (typeof resource.id !== \"string\") {\n      err.message = \"Id must be a string.\";\n      return false;\n    }\n\n    if (\n      resource.id.indexOf(\"/\") !== -1 ||\n      resource.id.indexOf(\"\\\\\") !== -1 ||\n      resource.id.indexOf(\"?\") !== -1 ||\n      resource.id.indexOf(\"#\") !== -1\n    ) {\n      err.message = \"Id contains illegal chars.\";\n      return false;\n    }\n\n    if (resource.id[resource.id.length - 1] === \" \") {\n      err.message = \"Id ends with a space.\";\n      return false;\n    }\n  }\n  return true;\n}\n\n/**\n * @hidden\n */\nexport function isItemResourceValid(resource: { id?: string }, err: { message?: string }): boolean {\n  // TODO: fix strictness issues so that caller contexts respects the types of the functions\n  if (resource.id) {\n    if (typeof resource.id !== \"string\") {\n      err.message = \"Id must be a string.\";\n      return false;\n    }\n\n    if (\n      resource.id.indexOf(\"/\") !== -1 ||\n      resource.id.indexOf(\"\\\\\") !== -1 ||\n      resource.id.indexOf(\"#\") !== -1\n    ) {\n      err.message = \"Id contains illegal chars.\";\n      return false;\n    }\n  }\n  return true;\n}\n\n/** @hidden */\nexport function getIdFromLink(resourceLink: string): string {\n  resourceLink = trimSlashes(resourceLink);\n  return resourceLink;\n}\n\n/** @hidden */\nexport function getPathFromLink(resourceLink: string, resourceType?: string): string {\n  resourceLink = trimSlashes(resourceLink);\n  if (resourceType) {\n    return \"/\" + encodeURI(resourceLink) + \"/\" + resourceType;\n  } else {\n    return \"/\" + encodeURI(resourceLink);\n  }\n}\n\n/**\n * @hidden\n */\nexport function isStringNullOrEmpty(inputString: string): boolean {\n  // checks whether string is null, undefined, empty or only contains space\n  return !inputString || /^\\s*$/.test(inputString);\n}\n\n/**\n * @hidden\n */\nexport function trimSlashFromLeftAndRight(inputString: string): string {\n  if (typeof inputString !== \"string\") {\n    throw new Error(\"invalid input: input is not string\");\n  }\n\n  return inputString.replace(trimLeftSlashes, \"\").replace(trimRightSlashes, \"\");\n}\n\n/**\n * @hidden\n */\nexport function validateResourceId(resourceId: string): boolean {\n  // if resourceId is not a string or is empty throw an error\n  if (typeof resourceId !== \"string\" || isStringNullOrEmpty(resourceId)) {\n    throw new Error(\"Resource ID must be a string and cannot be undefined, null or empty\");\n  }\n\n  // if resource id contains illegal characters throw an error\n  if (illegalResourceIdCharacters.test(resourceId)) {\n    throw new Error(\"Illegal characters ['/', '\\\\', '#', '?'] cannot be used in Resource ID\");\n  }\n\n  return true;\n}\n\n/**\n * @hidden\n */\nexport function validateItemResourceId(resourceId: string): boolean {\n  // if resourceId is not a string or is empty throw an error\n  if (typeof resourceId !== \"string\" || isStringNullOrEmpty(resourceId)) {\n    throw new Error(\"Resource ID must be a string and cannot be undefined, null or empty\");\n  }\n\n  // if resource id contains illegal characters throw an error\n  if (illegalItemResourceIdCharacters.test(resourceId)) {\n    throw new Error(\"Illegal characters ['/', '\\\\', '#'] cannot be used in Resource ID\");\n  }\n\n  return true;\n}\n\n/**\n * @hidden\n */\nexport function getResourceIdFromPath(resourcePath: string): string {\n  if (!resourcePath || typeof resourcePath !== \"string\") {\n    return null;\n  }\n\n  const trimmedPath = trimSlashFromLeftAndRight(resourcePath);\n  const pathSegments = trimmedPath.split(\"/\");\n\n  // number of segments of a path must always be even\n  if (pathSegments.length % 2 !== 0) {\n    return null;\n  }\n\n  return pathSegments[pathSegments.length - 1];\n}\n\n/**\n * @hidden\n */\ninterface ConnectionObject {\n  AccountEndpoint: string;\n  AccountKey: string;\n}\n\n/**\n * @hidden\n */\nexport function parseConnectionString(connectionString: string): CosmosClientOptions {\n  const keyValueStrings = connectionString.split(\";\");\n  const { AccountEndpoint, AccountKey } = keyValueStrings.reduce(\n    (connectionObject, keyValueString: string) => {\n      const [key, ...value] = keyValueString.split(\"=\");\n      (connectionObject as any)[key] = value.join(\"=\");\n      return connectionObject;\n    },\n    {} as ConnectionObject,\n  );\n  if (!AccountEndpoint || !AccountKey) {\n    throw new Error(\"Could not parse the provided connection string\");\n  }\n  return {\n    endpoint: AccountEndpoint,\n    key: AccountKey,\n  };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}