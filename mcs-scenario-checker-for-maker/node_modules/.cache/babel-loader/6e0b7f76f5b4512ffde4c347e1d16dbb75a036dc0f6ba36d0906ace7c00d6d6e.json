{"ast":null,"code":"// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport { Constants } from \"../common/constants\";\nimport { InMemoryCollectionRoutingMap } from \"./inMemoryCollectionRoutingMap\";\n/**\n * @hidden\n */\nfunction compareRanges(a, b) {\n  const aVal = a[0][Constants.PartitionKeyRange.MinInclusive];\n  const bVal = b[0][Constants.PartitionKeyRange.MinInclusive];\n  if (aVal > bVal) {\n    return 1;\n  }\n  if (aVal < bVal) {\n    return -1;\n  }\n  return 0;\n}\n/** @hidden */\nexport function createCompleteRoutingMap(partitionKeyRangeInfoTuppleList) {\n  const rangeById = {}; // TODO: any\n  const rangeByInfo = {}; // TODO: any\n  let sortedRanges = [];\n  // the for loop doesn't invoke any async callback\n  for (const r of partitionKeyRangeInfoTuppleList) {\n    rangeById[r[0][Constants.PartitionKeyRange.Id]] = r;\n    rangeByInfo[r[1]] = r[0];\n    sortedRanges.push(r);\n  }\n  sortedRanges = sortedRanges.sort(compareRanges);\n  const partitionKeyOrderedRange = sortedRanges.map(r => r[0]);\n  const orderedPartitionInfo = sortedRanges.map(r => r[1]);\n  if (!isCompleteSetOfRange(partitionKeyOrderedRange)) {\n    return undefined;\n  }\n  return new InMemoryCollectionRoutingMap(partitionKeyOrderedRange, orderedPartitionInfo);\n}\n/**\n * @hidden\n */\nfunction isCompleteSetOfRange(partitionKeyOrderedRange) {\n  // TODO: any\n  let isComplete = false;\n  if (partitionKeyOrderedRange.length > 0) {\n    const firstRange = partitionKeyOrderedRange[0];\n    const lastRange = partitionKeyOrderedRange[partitionKeyOrderedRange.length - 1];\n    isComplete = firstRange[Constants.PartitionKeyRange.MinInclusive] === Constants.EffectivePartitionKeyConstants.MinimumInclusiveEffectivePartitionKey;\n    isComplete = isComplete && lastRange[Constants.PartitionKeyRange.MaxExclusive] === Constants.EffectivePartitionKeyConstants.MaximumExclusiveEffectivePartitionKey;\n    for (let i = 1; i < partitionKeyOrderedRange.length; i++) {\n      const previousRange = partitionKeyOrderedRange[i - 1];\n      const currentRange = partitionKeyOrderedRange[i];\n      isComplete = isComplete && previousRange[Constants.PartitionKeyRange.MaxExclusive] === currentRange[Constants.PartitionKeyRange.MinInclusive];\n      if (!isComplete) {\n        if (previousRange[Constants.PartitionKeyRange.MaxExclusive] > currentRange[Constants.PartitionKeyRange.MinInclusive]) {\n          throw Error(\"Ranges overlap\");\n        }\n        break;\n      }\n    }\n  }\n  return isComplete;\n}","map":{"version":3,"names":["Constants","InMemoryCollectionRoutingMap","compareRanges","a","b","aVal","PartitionKeyRange","MinInclusive","bVal","createCompleteRoutingMap","partitionKeyRangeInfoTuppleList","rangeById","rangeByInfo","sortedRanges","r","Id","push","sort","partitionKeyOrderedRange","map","orderedPartitionInfo","isCompleteSetOfRange","undefined","isComplete","length","firstRange","lastRange","EffectivePartitionKeyConstants","MinimumInclusiveEffectivePartitionKey","MaxExclusive","MaximumExclusiveEffectivePartitionKey","i","previousRange","currentRange","Error"],"sources":["/Users/ajitpawar/microsoft/bap/POCs/Scenario_checker_for_maker/mcs-scenario-checker-for-maker/node_modules/@azure/cosmos/src/routing/CollectionRoutingMapFactory.ts"],"sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport { Constants } from \"../common/constants\";\nimport { InMemoryCollectionRoutingMap } from \"./inMemoryCollectionRoutingMap\";\n\n/**\n * @hidden\n */\nfunction compareRanges(a: any, b: any): 0 | 1 | -1 {\n  const aVal = a[0][Constants.PartitionKeyRange.MinInclusive];\n  const bVal = b[0][Constants.PartitionKeyRange.MinInclusive];\n  if (aVal > bVal) {\n    return 1;\n  }\n  if (aVal < bVal) {\n    return -1;\n  }\n  return 0;\n}\n\n/** @hidden */\nexport function createCompleteRoutingMap(\n  partitionKeyRangeInfoTuppleList: any[],\n): InMemoryCollectionRoutingMap {\n  const rangeById: any = {}; // TODO: any\n  const rangeByInfo: any = {}; // TODO: any\n\n  let sortedRanges = [];\n\n  // the for loop doesn't invoke any async callback\n  for (const r of partitionKeyRangeInfoTuppleList) {\n    rangeById[r[0][Constants.PartitionKeyRange.Id]] = r;\n    rangeByInfo[r[1]] = r[0];\n    sortedRanges.push(r);\n  }\n\n  sortedRanges = sortedRanges.sort(compareRanges);\n  const partitionKeyOrderedRange = sortedRanges.map((r) => r[0]);\n  const orderedPartitionInfo = sortedRanges.map((r) => r[1]);\n\n  if (!isCompleteSetOfRange(partitionKeyOrderedRange)) {\n    return undefined;\n  }\n  return new InMemoryCollectionRoutingMap(partitionKeyOrderedRange, orderedPartitionInfo);\n}\n\n/**\n * @hidden\n */\nfunction isCompleteSetOfRange(partitionKeyOrderedRange: any): boolean {\n  // TODO: any\n  let isComplete = false;\n  if (partitionKeyOrderedRange.length > 0) {\n    const firstRange = partitionKeyOrderedRange[0];\n    const lastRange = partitionKeyOrderedRange[partitionKeyOrderedRange.length - 1];\n    isComplete =\n      firstRange[Constants.PartitionKeyRange.MinInclusive] ===\n      Constants.EffectivePartitionKeyConstants.MinimumInclusiveEffectivePartitionKey;\n    isComplete =\n      isComplete &&\n      lastRange[Constants.PartitionKeyRange.MaxExclusive] ===\n        Constants.EffectivePartitionKeyConstants.MaximumExclusiveEffectivePartitionKey;\n\n    for (let i = 1; i < partitionKeyOrderedRange.length; i++) {\n      const previousRange = partitionKeyOrderedRange[i - 1];\n      const currentRange = partitionKeyOrderedRange[i];\n      isComplete =\n        isComplete &&\n        previousRange[Constants.PartitionKeyRange.MaxExclusive] ===\n          currentRange[Constants.PartitionKeyRange.MinInclusive];\n\n      if (!isComplete) {\n        if (\n          previousRange[Constants.PartitionKeyRange.MaxExclusive] >\n          currentRange[Constants.PartitionKeyRange.MinInclusive]\n        ) {\n          throw Error(\"Ranges overlap\");\n        }\n        break;\n      }\n    }\n  }\n  return isComplete;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}