{"ast":null,"code":"// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport { Constants } from \"../common/constants\";\nimport { sleep } from \"../common/helper\";\nimport { StatusCodes, SubStatusCodes } from \"../common/statusCodes\";\nimport { DiagnosticNodeType } from \"../diagnostics/DiagnosticNodeInternal\";\nimport { TimeoutErrorCode } from \"../request/TimeoutError\";\nimport { addDignosticChild } from \"../utils/diagnostics\";\nimport { getCurrentTimestampInMs } from \"../utils/time\";\nimport { DefaultRetryPolicy } from \"./defaultRetryPolicy\";\nimport { EndpointDiscoveryRetryPolicy } from \"./endpointDiscoveryRetryPolicy\";\nimport { ResourceThrottleRetryPolicy } from \"./resourceThrottleRetryPolicy\";\nimport { SessionRetryPolicy } from \"./sessionRetryPolicy\";\nimport { TimeoutFailoverRetryPolicy } from \"./timeoutFailoverRetryPolicy\";\n/**\n * @hidden\n */\nexport async function execute({\n  diagnosticNode,\n  retryContext = {\n    retryCount: 0\n  },\n  retryPolicies,\n  requestContext,\n  executeRequest\n}) {\n  // TODO: any response\n  return addDignosticChild(async localDiagnosticNode => {\n    localDiagnosticNode.addData({\n      requestAttempNumber: retryContext.retryCount\n    });\n    if (!retryPolicies) {\n      retryPolicies = {\n        endpointDiscoveryRetryPolicy: new EndpointDiscoveryRetryPolicy(requestContext.globalEndpointManager, requestContext.operationType),\n        resourceThrottleRetryPolicy: new ResourceThrottleRetryPolicy(requestContext.connectionPolicy.retryOptions.maxRetryAttemptCount, requestContext.connectionPolicy.retryOptions.fixedRetryIntervalInMilliseconds, requestContext.connectionPolicy.retryOptions.maxWaitTimeInSeconds),\n        sessionReadRetryPolicy: new SessionRetryPolicy(requestContext.globalEndpointManager, requestContext.resourceType, requestContext.operationType, requestContext.connectionPolicy),\n        defaultRetryPolicy: new DefaultRetryPolicy(requestContext.operationType),\n        timeoutFailoverRetryPolicy: new TimeoutFailoverRetryPolicy(requestContext.globalEndpointManager, requestContext.headers, requestContext.method, requestContext.resourceType, requestContext.operationType, requestContext.connectionPolicy.enableEndpointDiscovery)\n      };\n    }\n    if (retryContext && retryContext.clearSessionTokenNotAvailable) {\n      requestContext.client.clearSessionToken(requestContext.path);\n      delete requestContext.headers[\"x-ms-session-token\"];\n    }\n    if (retryContext && retryContext.retryLocationServerIndex) {\n      requestContext.endpoint = await requestContext.globalEndpointManager.resolveServiceEndpoint(localDiagnosticNode, requestContext.resourceType, requestContext.operationType, retryContext.retryLocationServerIndex);\n    } else {\n      requestContext.endpoint = await requestContext.globalEndpointManager.resolveServiceEndpoint(localDiagnosticNode, requestContext.resourceType, requestContext.operationType);\n    }\n    const startTimeUTCInMs = getCurrentTimestampInMs();\n    const correlatedActivityId = requestContext.headers[Constants.HttpHeaders.CorrelatedActivityId];\n    try {\n      const response = await executeRequest(localDiagnosticNode, requestContext);\n      response.headers[Constants.ThrottleRetryCount] = retryPolicies.resourceThrottleRetryPolicy.currentRetryAttemptCount;\n      response.headers[Constants.ThrottleRetryWaitTimeInMs] = retryPolicies.resourceThrottleRetryPolicy.cummulativeWaitTimeinMs;\n      if (correlatedActivityId) {\n        response.headers[Constants.HttpHeaders.CorrelatedActivityId] = correlatedActivityId;\n      }\n      return response;\n    } catch (err) {\n      // TODO: any error\n      let retryPolicy = null;\n      const headers = err.headers || {};\n      if (correlatedActivityId) {\n        headers[Constants.HttpHeaders.CorrelatedActivityId] = correlatedActivityId;\n      }\n      if (err.code === StatusCodes.ENOTFOUND || err.code === \"REQUEST_SEND_ERROR\" || err.code === StatusCodes.Forbidden && (err.substatus === SubStatusCodes.DatabaseAccountNotFound || err.substatus === SubStatusCodes.WriteForbidden)) {\n        retryPolicy = retryPolicies.endpointDiscoveryRetryPolicy;\n      } else if (err.code === StatusCodes.TooManyRequests) {\n        retryPolicy = retryPolicies.resourceThrottleRetryPolicy;\n      } else if (err.code === StatusCodes.NotFound && err.substatus === SubStatusCodes.ReadSessionNotAvailable) {\n        retryPolicy = retryPolicies.sessionReadRetryPolicy;\n      } else if (err.code === StatusCodes.ServiceUnavailable || err.code === TimeoutErrorCode) {\n        retryPolicy = retryPolicies.timeoutFailoverRetryPolicy;\n      } else {\n        retryPolicy = retryPolicies.defaultRetryPolicy;\n      }\n      const results = await retryPolicy.shouldRetry(err, localDiagnosticNode, retryContext, requestContext.endpoint);\n      if (!results) {\n        headers[Constants.ThrottleRetryCount] = retryPolicies.resourceThrottleRetryPolicy.currentRetryAttemptCount;\n        headers[Constants.ThrottleRetryWaitTimeInMs] = retryPolicies.resourceThrottleRetryPolicy.cummulativeWaitTimeinMs;\n        err.headers = Object.assign(Object.assign({}, err.headers), headers);\n        throw err;\n      } else {\n        requestContext.retryCount++;\n        const newUrl = results[1]; // TODO: any hack\n        if (newUrl !== undefined) {\n          requestContext.endpoint = newUrl;\n        }\n        localDiagnosticNode.recordFailedNetworkCall(startTimeUTCInMs, requestContext, retryContext.retryCount, err.code, err.subsstatusCode, headers);\n        await sleep(retryPolicy.retryAfterInMs);\n        return execute({\n          diagnosticNode,\n          executeRequest,\n          requestContext,\n          retryContext,\n          retryPolicies\n        });\n      }\n    }\n  }, diagnosticNode, DiagnosticNodeType.HTTP_REQUEST);\n}","map":{"version":3,"names":["Constants","sleep","StatusCodes","SubStatusCodes","DiagnosticNodeType","TimeoutErrorCode","addDignosticChild","getCurrentTimestampInMs","DefaultRetryPolicy","EndpointDiscoveryRetryPolicy","ResourceThrottleRetryPolicy","SessionRetryPolicy","TimeoutFailoverRetryPolicy","execute","diagnosticNode","retryContext","retryCount","retryPolicies","requestContext","executeRequest","localDiagnosticNode","addData","requestAttempNumber","endpointDiscoveryRetryPolicy","globalEndpointManager","operationType","resourceThrottleRetryPolicy","connectionPolicy","retryOptions","maxRetryAttemptCount","fixedRetryIntervalInMilliseconds","maxWaitTimeInSeconds","sessionReadRetryPolicy","resourceType","defaultRetryPolicy","timeoutFailoverRetryPolicy","headers","method","enableEndpointDiscovery","clearSessionTokenNotAvailable","client","clearSessionToken","path","retryLocationServerIndex","endpoint","resolveServiceEndpoint","startTimeUTCInMs","correlatedActivityId","HttpHeaders","CorrelatedActivityId","response","ThrottleRetryCount","currentRetryAttemptCount","ThrottleRetryWaitTimeInMs","cummulativeWaitTimeinMs","err","retryPolicy","code","ENOTFOUND","Forbidden","substatus","DatabaseAccountNotFound","WriteForbidden","TooManyRequests","NotFound","ReadSessionNotAvailable","ServiceUnavailable","results","shouldRetry","Object","assign","newUrl","undefined","recordFailedNetworkCall","subsstatusCode","retryAfterInMs","HTTP_REQUEST"],"sources":["/Users/ajitpawar/microsoft/bap/POCs/Scenario_checker_for_maker/mcs-scenario-checker-for-maker/node_modules/@azure/cosmos/src/retry/retryUtility.ts"],"sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport { Constants } from \"../common/constants\";\nimport { sleep } from \"../common/helper\";\nimport { StatusCodes, SubStatusCodes } from \"../common/statusCodes\";\nimport type { DiagnosticNodeInternal } from \"../diagnostics/DiagnosticNodeInternal\";\nimport { DiagnosticNodeType } from \"../diagnostics/DiagnosticNodeInternal\";\nimport type { Response } from \"../request\";\nimport type { RequestContext } from \"../request/RequestContext\";\nimport { TimeoutErrorCode } from \"../request/TimeoutError\";\nimport { addDignosticChild } from \"../utils/diagnostics\";\nimport { getCurrentTimestampInMs } from \"../utils/time\";\nimport { DefaultRetryPolicy } from \"./defaultRetryPolicy\";\nimport { EndpointDiscoveryRetryPolicy } from \"./endpointDiscoveryRetryPolicy\";\nimport { ResourceThrottleRetryPolicy } from \"./resourceThrottleRetryPolicy\";\nimport type { RetryContext } from \"./RetryContext\";\nimport type { RetryPolicy } from \"./RetryPolicy\";\nimport { SessionRetryPolicy } from \"./sessionRetryPolicy\";\nimport { TimeoutFailoverRetryPolicy } from \"./timeoutFailoverRetryPolicy\";\n\n/**\n * @hidden\n */\ninterface ExecuteArgs {\n  retryContext?: RetryContext;\n  diagnosticNode: DiagnosticNodeInternal;\n  retryPolicies?: RetryPolicies;\n  requestContext: RequestContext;\n  executeRequest: (\n    diagnosticNode: DiagnosticNodeInternal,\n    requestContext: RequestContext,\n  ) => Promise<Response<any>>;\n}\n\n/**\n * @hidden\n */\ninterface RetryPolicies {\n  endpointDiscoveryRetryPolicy: EndpointDiscoveryRetryPolicy;\n  resourceThrottleRetryPolicy: ResourceThrottleRetryPolicy;\n  sessionReadRetryPolicy: SessionRetryPolicy;\n  defaultRetryPolicy: DefaultRetryPolicy;\n  timeoutFailoverRetryPolicy: TimeoutFailoverRetryPolicy;\n}\n\n/**\n * @hidden\n */\nexport async function execute({\n  diagnosticNode,\n  retryContext = { retryCount: 0 },\n  retryPolicies,\n  requestContext,\n  executeRequest,\n}: ExecuteArgs): Promise<Response<any>> {\n  // TODO: any response\n  return addDignosticChild(\n    async (localDiagnosticNode: DiagnosticNodeInternal) => {\n      localDiagnosticNode.addData({ requestAttempNumber: retryContext.retryCount });\n      if (!retryPolicies) {\n        retryPolicies = {\n          endpointDiscoveryRetryPolicy: new EndpointDiscoveryRetryPolicy(\n            requestContext.globalEndpointManager,\n            requestContext.operationType,\n          ),\n          resourceThrottleRetryPolicy: new ResourceThrottleRetryPolicy(\n            requestContext.connectionPolicy.retryOptions.maxRetryAttemptCount,\n            requestContext.connectionPolicy.retryOptions.fixedRetryIntervalInMilliseconds,\n            requestContext.connectionPolicy.retryOptions.maxWaitTimeInSeconds,\n          ),\n          sessionReadRetryPolicy: new SessionRetryPolicy(\n            requestContext.globalEndpointManager,\n            requestContext.resourceType,\n            requestContext.operationType,\n            requestContext.connectionPolicy,\n          ),\n          defaultRetryPolicy: new DefaultRetryPolicy(requestContext.operationType),\n          timeoutFailoverRetryPolicy: new TimeoutFailoverRetryPolicy(\n            requestContext.globalEndpointManager,\n            requestContext.headers,\n            requestContext.method,\n            requestContext.resourceType,\n            requestContext.operationType,\n            requestContext.connectionPolicy.enableEndpointDiscovery,\n          ),\n        };\n      }\n      if (retryContext && retryContext.clearSessionTokenNotAvailable) {\n        requestContext.client.clearSessionToken(requestContext.path);\n        delete requestContext.headers[\"x-ms-session-token\"];\n      }\n      if (retryContext && retryContext.retryLocationServerIndex) {\n        requestContext.endpoint = await requestContext.globalEndpointManager.resolveServiceEndpoint(\n          localDiagnosticNode,\n          requestContext.resourceType,\n          requestContext.operationType,\n          retryContext.retryLocationServerIndex,\n        );\n      } else {\n        requestContext.endpoint = await requestContext.globalEndpointManager.resolveServiceEndpoint(\n          localDiagnosticNode,\n          requestContext.resourceType,\n          requestContext.operationType,\n        );\n      }\n      const startTimeUTCInMs = getCurrentTimestampInMs();\n      const correlatedActivityId =\n        requestContext.headers[Constants.HttpHeaders.CorrelatedActivityId];\n      try {\n        const response = await executeRequest(localDiagnosticNode, requestContext);\n        response.headers[Constants.ThrottleRetryCount] =\n          retryPolicies.resourceThrottleRetryPolicy.currentRetryAttemptCount;\n        response.headers[Constants.ThrottleRetryWaitTimeInMs] =\n          retryPolicies.resourceThrottleRetryPolicy.cummulativeWaitTimeinMs;\n        if (correlatedActivityId) {\n          response.headers[Constants.HttpHeaders.CorrelatedActivityId] = correlatedActivityId;\n        }\n        return response;\n      } catch (err: any) {\n        // TODO: any error\n        let retryPolicy: RetryPolicy = null;\n        const headers = err.headers || {};\n        if (correlatedActivityId) {\n          headers[Constants.HttpHeaders.CorrelatedActivityId] = correlatedActivityId;\n        }\n        if (\n          err.code === StatusCodes.ENOTFOUND ||\n          err.code === \"REQUEST_SEND_ERROR\" ||\n          (err.code === StatusCodes.Forbidden &&\n            (err.substatus === SubStatusCodes.DatabaseAccountNotFound ||\n              err.substatus === SubStatusCodes.WriteForbidden))\n        ) {\n          retryPolicy = retryPolicies.endpointDiscoveryRetryPolicy;\n        } else if (err.code === StatusCodes.TooManyRequests) {\n          retryPolicy = retryPolicies.resourceThrottleRetryPolicy;\n        } else if (\n          err.code === StatusCodes.NotFound &&\n          err.substatus === SubStatusCodes.ReadSessionNotAvailable\n        ) {\n          retryPolicy = retryPolicies.sessionReadRetryPolicy;\n        } else if (err.code === StatusCodes.ServiceUnavailable || err.code === TimeoutErrorCode) {\n          retryPolicy = retryPolicies.timeoutFailoverRetryPolicy;\n        } else {\n          retryPolicy = retryPolicies.defaultRetryPolicy;\n        }\n        const results = await retryPolicy.shouldRetry(\n          err,\n          localDiagnosticNode,\n          retryContext,\n          requestContext.endpoint,\n        );\n        if (!results) {\n          headers[Constants.ThrottleRetryCount] =\n            retryPolicies.resourceThrottleRetryPolicy.currentRetryAttemptCount;\n          headers[Constants.ThrottleRetryWaitTimeInMs] =\n            retryPolicies.resourceThrottleRetryPolicy.cummulativeWaitTimeinMs;\n          err.headers = { ...err.headers, ...headers };\n          throw err;\n        } else {\n          requestContext.retryCount++;\n          const newUrl = (results as any)[1]; // TODO: any hack\n          if (newUrl !== undefined) {\n            requestContext.endpoint = newUrl;\n          }\n          localDiagnosticNode.recordFailedNetworkCall(\n            startTimeUTCInMs,\n            requestContext,\n            retryContext.retryCount,\n            err.code,\n            err.subsstatusCode,\n            headers,\n          );\n          await sleep(retryPolicy.retryAfterInMs);\n          return execute({\n            diagnosticNode,\n            executeRequest,\n            requestContext,\n            retryContext,\n            retryPolicies,\n          });\n        }\n      }\n    },\n    diagnosticNode,\n    DiagnosticNodeType.HTTP_REQUEST,\n  );\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}