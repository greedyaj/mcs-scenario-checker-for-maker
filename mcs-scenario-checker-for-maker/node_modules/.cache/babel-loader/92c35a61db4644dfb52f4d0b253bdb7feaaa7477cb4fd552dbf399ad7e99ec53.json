{"ast":null,"code":"// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n/**\n * Models vector clock bases session token. Session token has the following format:\n * `{Version}#{GlobalLSN}#{RegionId1}={LocalLsn1}#{RegionId2}={LocalLsn2}....#{RegionIdN}={LocalLsnN}`\n * 'Version' captures the configuration number of the partition which returned this session token.\n * 'Version' is incremented everytime topology of the partition is updated (say due to Add/Remove/Failover).\n *\n * The choice of separators '#' and '=' is important. Separators ';' and ',' are used to delimit\n * per-partitionKeyRange session token\n * @hidden\n *\n */\nexport class VectorSessionToken {\n  constructor(version, globalLsn, localLsnByregion, sessionToken) {\n    this.version = version;\n    this.globalLsn = globalLsn;\n    this.localLsnByregion = localLsnByregion;\n    this.sessionToken = sessionToken;\n    if (!this.sessionToken) {\n      const regionAndLocalLsn = [];\n      for (const [key, value] of this.localLsnByregion.entries()) {\n        regionAndLocalLsn.push(`${key}${VectorSessionToken.REGION_PROGRESS_SEPARATOR}${value}`);\n      }\n      const regionProgress = regionAndLocalLsn.join(VectorSessionToken.SEGMENT_SEPARATOR);\n      if (regionProgress === \"\") {\n        this.sessionToken = `${this.version}${VectorSessionToken.SEGMENT_SEPARATOR}${this.globalLsn}`;\n      } else {\n        this.sessionToken = `${this.version}${VectorSessionToken.SEGMENT_SEPARATOR}${this.globalLsn}${VectorSessionToken.SEGMENT_SEPARATOR}${regionProgress}`;\n      }\n    }\n  }\n  static create(sessionToken) {\n    const [versionStr, globalLsnStr, ...regionSegments] = sessionToken.split(VectorSessionToken.SEGMENT_SEPARATOR);\n    const version = parseInt(versionStr, 10);\n    const globalLsn = parseFloat(globalLsnStr);\n    if (typeof version !== \"number\" || typeof globalLsn !== \"number\") {\n      return null;\n    }\n    const lsnByRegion = new Map();\n    for (const regionSegment of regionSegments) {\n      const [regionIdStr, localLsnStr] = regionSegment.split(VectorSessionToken.REGION_PROGRESS_SEPARATOR);\n      if (!regionIdStr || !localLsnStr) {\n        return null;\n      }\n      const regionId = parseInt(regionIdStr, 10);\n      let localLsn;\n      try {\n        localLsn = localLsnStr;\n      } catch (err) {\n        // TODO: log error\n        return null;\n      }\n      if (typeof regionId !== \"number\") {\n        return null;\n      }\n      lsnByRegion.set(regionId, localLsn);\n    }\n    return new VectorSessionToken(version, globalLsn, lsnByRegion, sessionToken);\n  }\n  equals(other) {\n    return !other ? false : this.version === other.version && this.globalLsn === other.globalLsn && this.areRegionProgressEqual(other.localLsnByregion);\n  }\n  merge(other) {\n    if (other == null) {\n      throw new Error(\"other (Vector Session Token) must not be null\");\n    }\n    if (this.version === other.version && this.localLsnByregion.size !== other.localLsnByregion.size) {\n      throw new Error(`Compared session tokens ${this.sessionToken} and ${other.sessionToken} have unexpected regions`);\n    }\n    const [higherVersionSessionToken, lowerVersionSessionToken] = this.version < other.version ? [other, this] : [this, other];\n    const highestLocalLsnByRegion = new Map();\n    for (const [regionId, highLocalLsn] of higherVersionSessionToken.localLsnByregion.entries()) {\n      const lowLocalLsn = lowerVersionSessionToken.localLsnByregion.get(regionId);\n      if (lowLocalLsn) {\n        highestLocalLsnByRegion.set(regionId, max(highLocalLsn, lowLocalLsn));\n      } else if (this.version === other.version) {\n        throw new Error(`Compared session tokens have unexpected regions. Session 1: ${this.sessionToken} - Session 2: ${this.sessionToken}`);\n      } else {\n        highestLocalLsnByRegion.set(regionId, highLocalLsn);\n      }\n    }\n    return new VectorSessionToken(Math.max(this.version, other.version), Math.max(this.globalLsn, other.globalLsn), highestLocalLsnByRegion);\n  }\n  toString() {\n    return this.sessionToken;\n  }\n  areRegionProgressEqual(other) {\n    if (this.localLsnByregion.size !== other.size) {\n      return false;\n    }\n    for (const [regionId, localLsn] of this.localLsnByregion.entries()) {\n      const otherLocalLsn = other.get(regionId);\n      if (localLsn !== otherLocalLsn) {\n        return false;\n      }\n    }\n    return true;\n  }\n}\nVectorSessionToken.SEGMENT_SEPARATOR = \"#\";\nVectorSessionToken.REGION_PROGRESS_SEPARATOR = \"=\";\n/**\n * @hidden\n */\nfunction max(int1, int2) {\n  // NOTE: This only works for positive numbers\n  if (int1.length === int2.length) {\n    return int1 > int2 ? int1 : int2;\n  } else if (int1.length > int2.length) {\n    return int1;\n  } else {\n    return int2;\n  }\n}","map":{"version":3,"names":["VectorSessionToken","constructor","version","globalLsn","localLsnByregion","sessionToken","regionAndLocalLsn","key","value","entries","push","REGION_PROGRESS_SEPARATOR","regionProgress","join","SEGMENT_SEPARATOR","create","versionStr","globalLsnStr","regionSegments","split","parseInt","parseFloat","lsnByRegion","Map","regionSegment","regionIdStr","localLsnStr","regionId","localLsn","err","set","equals","other","areRegionProgressEqual","merge","Error","size","higherVersionSessionToken","lowerVersionSessionToken","highestLocalLsnByRegion","highLocalLsn","lowLocalLsn","get","max","Math","toString","otherLocalLsn","int1","int2","length"],"sources":["/Users/ajitpawar/microsoft/bap/POCs/Scenario_checker_for_maker/mcs-scenario-checker-for-maker/node_modules/@azure/cosmos/src/session/VectorSessionToken.ts"],"sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n/**\n * Models vector clock bases session token. Session token has the following format:\n * `{Version}#{GlobalLSN}#{RegionId1}={LocalLsn1}#{RegionId2}={LocalLsn2}....#{RegionIdN}={LocalLsnN}`\n * 'Version' captures the configuration number of the partition which returned this session token.\n * 'Version' is incremented everytime topology of the partition is updated (say due to Add/Remove/Failover).\n *\n * The choice of separators '#' and '=' is important. Separators ';' and ',' are used to delimit\n * per-partitionKeyRange session token\n * @hidden\n *\n */\nexport class VectorSessionToken {\n  private static readonly SEGMENT_SEPARATOR = \"#\";\n  private static readonly REGION_PROGRESS_SEPARATOR = \"=\";\n\n  constructor(\n    private readonly version: number,\n    private readonly globalLsn: number,\n    private readonly localLsnByregion: Map<number, string>,\n    private readonly sessionToken?: string,\n  ) {\n    if (!this.sessionToken) {\n      const regionAndLocalLsn = [];\n      for (const [key, value] of this.localLsnByregion.entries()) {\n        regionAndLocalLsn.push(`${key}${VectorSessionToken.REGION_PROGRESS_SEPARATOR}${value}`);\n      }\n      const regionProgress = regionAndLocalLsn.join(VectorSessionToken.SEGMENT_SEPARATOR);\n      if (regionProgress === \"\") {\n        this.sessionToken = `${this.version}${VectorSessionToken.SEGMENT_SEPARATOR}${this.globalLsn}`;\n      } else {\n        this.sessionToken = `${this.version}${VectorSessionToken.SEGMENT_SEPARATOR}${this.globalLsn}${VectorSessionToken.SEGMENT_SEPARATOR}${regionProgress}`;\n      }\n    }\n  }\n\n  public static create(sessionToken: string): VectorSessionToken | null {\n    const [versionStr, globalLsnStr, ...regionSegments] = sessionToken.split(\n      VectorSessionToken.SEGMENT_SEPARATOR,\n    );\n\n    const version = parseInt(versionStr, 10);\n    const globalLsn = parseFloat(globalLsnStr);\n\n    if (typeof version !== \"number\" || typeof globalLsn !== \"number\") {\n      return null;\n    }\n\n    const lsnByRegion = new Map<number, string>();\n    for (const regionSegment of regionSegments) {\n      const [regionIdStr, localLsnStr] = regionSegment.split(\n        VectorSessionToken.REGION_PROGRESS_SEPARATOR,\n      );\n\n      if (!regionIdStr || !localLsnStr) {\n        return null;\n      }\n\n      const regionId = parseInt(regionIdStr, 10);\n      let localLsn: string;\n      try {\n        localLsn = localLsnStr;\n      } catch (err: any) {\n        // TODO: log error\n        return null;\n      }\n      if (typeof regionId !== \"number\") {\n        return null;\n      }\n\n      lsnByRegion.set(regionId, localLsn);\n    }\n\n    return new VectorSessionToken(version, globalLsn, lsnByRegion, sessionToken);\n  }\n\n  public equals(other: VectorSessionToken): boolean {\n    return !other\n      ? false\n      : this.version === other.version &&\n          this.globalLsn === other.globalLsn &&\n          this.areRegionProgressEqual(other.localLsnByregion);\n  }\n\n  public merge(other: VectorSessionToken): VectorSessionToken {\n    if (other == null) {\n      throw new Error(\"other (Vector Session Token) must not be null\");\n    }\n\n    if (\n      this.version === other.version &&\n      this.localLsnByregion.size !== other.localLsnByregion.size\n    ) {\n      throw new Error(\n        `Compared session tokens ${this.sessionToken} and ${other.sessionToken} have unexpected regions`,\n      );\n    }\n\n    const [higherVersionSessionToken, lowerVersionSessionToken]: [\n      VectorSessionToken,\n      VectorSessionToken,\n    ] = this.version < other.version ? [other, this] : [this, other];\n\n    const highestLocalLsnByRegion = new Map<number, string>();\n\n    for (const [regionId, highLocalLsn] of higherVersionSessionToken.localLsnByregion.entries()) {\n      const lowLocalLsn = lowerVersionSessionToken.localLsnByregion.get(regionId);\n      if (lowLocalLsn) {\n        highestLocalLsnByRegion.set(regionId, max(highLocalLsn, lowLocalLsn));\n      } else if (this.version === other.version) {\n        throw new Error(\n          `Compared session tokens have unexpected regions. Session 1: ${this.sessionToken} - Session 2: ${this.sessionToken}`,\n        );\n      } else {\n        highestLocalLsnByRegion.set(regionId, highLocalLsn);\n      }\n    }\n\n    return new VectorSessionToken(\n      Math.max(this.version, other.version),\n      Math.max(this.globalLsn, other.globalLsn),\n      highestLocalLsnByRegion,\n    );\n  }\n\n  public toString(): string | undefined {\n    return this.sessionToken;\n  }\n\n  private areRegionProgressEqual(other: Map<number, string>): boolean {\n    if (this.localLsnByregion.size !== other.size) {\n      return false;\n    }\n\n    for (const [regionId, localLsn] of this.localLsnByregion.entries()) {\n      const otherLocalLsn = other.get(regionId);\n\n      if (localLsn !== otherLocalLsn) {\n        return false;\n      }\n    }\n    return true;\n  }\n}\n\n/**\n * @hidden\n */\nfunction max(int1: string, int2: string): string {\n  // NOTE: This only works for positive numbers\n  if (int1.length === int2.length) {\n    return int1 > int2 ? int1 : int2;\n  } else if (int1.length > int2.length) {\n    return int1;\n  } else {\n    return int2;\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}