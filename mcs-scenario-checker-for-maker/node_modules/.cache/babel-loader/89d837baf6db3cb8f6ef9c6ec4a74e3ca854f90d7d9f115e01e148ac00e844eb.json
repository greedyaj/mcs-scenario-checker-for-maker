{"ast":null,"code":"import { createDocumentCollectionUri, getIdFromLink, getPathFromLink, HTTPMethod, isResourceValid, ResourceType } from \"../../common\";\nimport { ResourceResponse } from \"../../request\";\nimport { Conflict, Conflicts } from \"../Conflict\";\nimport { Item, Items } from \"../Item\";\nimport { Scripts } from \"../Script/Scripts\";\nimport { ContainerResponse } from \"./ContainerResponse\";\nimport { Offer } from \"../Offer\";\nimport { OfferResponse } from \"../Offer/OfferResponse\";\nimport { FeedRangeInternal } from \"../ChangeFeed\";\nimport { getEmptyCosmosDiagnostics, withDiagnostics, withMetadataDiagnostics } from \"../../utils/diagnostics\";\nimport { MetadataLookUpType } from \"../../CosmosDiagnostics\";\n/**\n * Operations for reading, replacing, or deleting a specific, existing container by id.\n *\n * @see {@link Containers} for creating new containers, and reading/querying all containers; use `.containers`.\n *\n * Note: all these operations make calls against a fixed budget.\n * You should design your system such that these calls scale sublinearly with your application.\n * For instance, do not call `container(id).read()` before every single `item.read()` call, to ensure the container exists;\n * do this once on application start up.\n */\nexport class Container {\n  /**\n   * Operations for creating new items, and reading/querying all items\n   *\n   * For reading, replacing, or deleting an existing item, use `.item(id)`.\n   *\n   * @example Create a new item\n   * ```typescript\n   * const {body: createdItem} = await container.items.create({id: \"<item id>\", properties: {}});\n   * ```\n   */\n  get items() {\n    if (!this.$items) {\n      this.$items = new Items(this, this.clientContext);\n    }\n    return this.$items;\n  }\n  /**\n   * All operations for Stored Procedures, Triggers, and User Defined Functions\n   */\n  get scripts() {\n    if (!this.$scripts) {\n      this.$scripts = new Scripts(this, this.clientContext);\n    }\n    return this.$scripts;\n  }\n  /**\n   * Operations for reading and querying conflicts for the given container.\n   *\n   * For reading or deleting a specific conflict, use `.conflict(id)`.\n   */\n  get conflicts() {\n    if (!this.$conflicts) {\n      this.$conflicts = new Conflicts(this, this.clientContext);\n    }\n    return this.$conflicts;\n  }\n  /**\n   * Returns a reference URL to the resource. Used for linking in Permissions.\n   */\n  get url() {\n    return createDocumentCollectionUri(this.database.id, this.id);\n  }\n  /**\n   * Returns a container instance. Note: You should get this from `database.container(id)`, rather than creating your own object.\n   * @param database - The parent {@link Database}.\n   * @param id - The id of the given container.\n   * @hidden\n   */\n  constructor(database, id, clientContext) {\n    this.database = database;\n    this.id = id;\n    this.clientContext = clientContext;\n  }\n  /**\n   * Used to read, replace, or delete a specific, existing {@link Item} by id.\n   *\n   * Use `.items` for creating new items, or querying/reading all items.\n   *\n   * @param id - The id of the {@link Item}.\n   * @param partitionKeyValue - The value of the {@link Item} partition key\n   * @example Replace an item\n   * `const {body: replacedItem} = await container.item(\"<item id>\", \"<partition key value>\").replace({id: \"<item id>\", title: \"Updated post\", authorID: 5});`\n   */\n  item(id, partitionKeyValue) {\n    return new Item(this, id, this.clientContext, partitionKeyValue);\n  }\n  /**\n   * Used to read, replace, or delete a specific, existing {@link Conflict} by id.\n   *\n   * Use `.conflicts` for creating new conflicts, or querying/reading all conflicts.\n   * @param id - The id of the {@link Conflict}.\n   */\n  conflict(id, partitionKey) {\n    return new Conflict(this, id, this.clientContext, partitionKey);\n  }\n  /** Read the container's definition */\n  async read(options) {\n    return withDiagnostics(async diagnosticNode => {\n      return this.readInternal(diagnosticNode, options);\n    }, this.clientContext);\n  }\n  /**\n   * @hidden\n   */\n  async readInternal(diagnosticNode, options) {\n    const path = getPathFromLink(this.url);\n    const id = getIdFromLink(this.url);\n    const response = await this.clientContext.read({\n      path,\n      resourceType: ResourceType.container,\n      resourceId: id,\n      options,\n      diagnosticNode\n    });\n    this.clientContext.partitionKeyDefinitionCache[this.url] = response.result.partitionKey;\n    return new ContainerResponse(response.result, response.headers, response.code, this, getEmptyCosmosDiagnostics());\n  }\n  /** Replace the container's definition */\n  async replace(body, options) {\n    return withDiagnostics(async diagnosticNode => {\n      const err = {};\n      if (!isResourceValid(body, err)) {\n        throw err;\n      }\n      const path = getPathFromLink(this.url);\n      const id = getIdFromLink(this.url);\n      const response = await this.clientContext.replace({\n        body,\n        path,\n        resourceType: ResourceType.container,\n        resourceId: id,\n        options,\n        diagnosticNode\n      });\n      return new ContainerResponse(response.result, response.headers, response.code, this, getEmptyCosmosDiagnostics());\n    }, this.clientContext);\n  }\n  /** Delete the container */\n  async delete(options) {\n    return withDiagnostics(async diagnosticNode => {\n      const path = getPathFromLink(this.url);\n      const id = getIdFromLink(this.url);\n      const response = await this.clientContext.delete({\n        path,\n        resourceType: ResourceType.container,\n        resourceId: id,\n        options,\n        diagnosticNode\n      });\n      return new ContainerResponse(response.result, response.headers, response.code, this, getEmptyCosmosDiagnostics());\n    }, this.clientContext);\n  }\n  /**\n   * Gets the partition key definition first by looking into the cache otherwise by reading the collection.\n   * @deprecated This method has been renamed to readPartitionKeyDefinition.\n   */\n  async getPartitionKeyDefinition() {\n    return withDiagnostics(async diagnosticNode => {\n      return this.readPartitionKeyDefinition(diagnosticNode);\n    }, this.clientContext);\n  }\n  /**\n   * Gets the partition key definition first by looking into the cache otherwise by reading the collection.\n   * @hidden\n   */\n  async readPartitionKeyDefinition(diagnosticNode) {\n    // $ISSUE-felixfan-2016-03-17: Make name based path and link based path use the same key\n    // $ISSUE-felixfan-2016-03-17: Refresh partitionKeyDefinitionCache when necessary\n    if (this.url in this.clientContext.partitionKeyDefinitionCache) {\n      diagnosticNode.addData({\n        readFromCache: true\n      });\n      return new ResourceResponse(this.clientContext.partitionKeyDefinitionCache[this.url], {}, 0, getEmptyCosmosDiagnostics());\n    }\n    const {\n      headers,\n      statusCode,\n      diagnostics\n    } = await withMetadataDiagnostics(async node => {\n      return this.readInternal(node);\n    }, diagnosticNode, MetadataLookUpType.ContainerLookUp);\n    return new ResourceResponse(this.clientContext.partitionKeyDefinitionCache[this.url], headers, statusCode, diagnostics);\n  }\n  /**\n   * Gets offer on container. If none exists, returns an OfferResponse with undefined.\n   */\n  async readOffer(options = {}) {\n    return withDiagnostics(async diagnosticNode => {\n      const {\n        resource: container\n      } = await this.read();\n      const path = \"/offers\";\n      const url = container._self;\n      const response = await this.clientContext.queryFeed({\n        path,\n        resourceId: \"\",\n        resourceType: ResourceType.offer,\n        query: `SELECT * from root where root.resource = \"${url}\"`,\n        resultFn: result => result.Offers,\n        options,\n        diagnosticNode\n      });\n      const offer = response.result[0] ? new Offer(this.database.client, response.result[0].id, this.clientContext) : undefined;\n      return new OfferResponse(response.result[0], response.headers, response.code, getEmptyCosmosDiagnostics(), offer);\n    }, this.clientContext);\n  }\n  async getQueryPlan(query) {\n    return withDiagnostics(async diagnosticNode => {\n      const path = getPathFromLink(this.url);\n      return this.clientContext.getQueryPlan(path + \"/docs\", ResourceType.item, getIdFromLink(this.url), query, {}, diagnosticNode);\n    }, this.clientContext);\n  }\n  readPartitionKeyRanges(feedOptions) {\n    feedOptions = feedOptions || {};\n    return this.clientContext.queryPartitionKeyRanges(this.url, undefined, feedOptions);\n  }\n  /**\n   *\n   * @returns all the feed ranges for which changefeed could be fetched.\n   */\n  async getFeedRanges() {\n    return withDiagnostics(async diagnosticNode => {\n      const {\n        resources\n      } = await this.readPartitionKeyRanges().fetchAllInternal(diagnosticNode);\n      const feedRanges = [];\n      for (const resource of resources) {\n        const feedRange = new FeedRangeInternal(resource.minInclusive, resource.maxExclusive);\n        Object.freeze(feedRange);\n        feedRanges.push(feedRange);\n      }\n      return feedRanges;\n    }, this.clientContext);\n  }\n  /**\n   * Delete all documents belong to the container for the provided partition key value\n   * @param partitionKey - The partition key value of the items to be deleted\n   */\n  async deleteAllItemsForPartitionKey(partitionKey, options) {\n    return withDiagnostics(async diagnosticNode => {\n      let path = getPathFromLink(this.url);\n      const id = getIdFromLink(this.url);\n      path = path + \"/operations/partitionkeydelete\";\n      const response = await this.clientContext.delete({\n        path,\n        resourceType: ResourceType.container,\n        resourceId: id,\n        options,\n        partitionKey: partitionKey,\n        method: HTTPMethod.post,\n        diagnosticNode\n      });\n      return new ContainerResponse(response.result, response.headers, response.code, this, getEmptyCosmosDiagnostics());\n    }, this.clientContext);\n  }\n}","map":{"version":3,"names":["createDocumentCollectionUri","getIdFromLink","getPathFromLink","HTTPMethod","isResourceValid","ResourceType","ResourceResponse","Conflict","Conflicts","Item","Items","Scripts","ContainerResponse","Offer","OfferResponse","FeedRangeInternal","getEmptyCosmosDiagnostics","withDiagnostics","withMetadataDiagnostics","MetadataLookUpType","Container","items","$items","clientContext","scripts","$scripts","conflicts","$conflicts","url","database","id","constructor","item","partitionKeyValue","conflict","partitionKey","read","options","diagnosticNode","readInternal","path","response","resourceType","container","resourceId","partitionKeyDefinitionCache","result","headers","code","replace","body","err","delete","getPartitionKeyDefinition","readPartitionKeyDefinition","addData","readFromCache","statusCode","diagnostics","node","ContainerLookUp","readOffer","resource","_self","queryFeed","offer","query","resultFn","Offers","client","undefined","getQueryPlan","readPartitionKeyRanges","feedOptions","queryPartitionKeyRanges","getFeedRanges","resources","fetchAllInternal","feedRanges","feedRange","minInclusive","maxExclusive","Object","freeze","push","deleteAllItemsForPartitionKey","method","post"],"sources":["/Users/ajitpawar/microsoft/bap/POCs/Scenario_checker_for_maker/mcs-scenario-checker-for-maker/node_modules/@azure/cosmos/src/client/Container/Container.ts"],"sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport type { ClientContext } from \"../../ClientContext\";\nimport {\n  createDocumentCollectionUri,\n  getIdFromLink,\n  getPathFromLink,\n  HTTPMethod,\n  isResourceValid,\n  ResourceType,\n} from \"../../common\";\nimport type { PartitionKey, PartitionKeyDefinition } from \"../../documents\";\nimport type { SqlQuerySpec } from \"../../queryExecutionContext\";\nimport type { QueryIterator } from \"../../queryIterator\";\nimport type { FeedOptions, RequestOptions, Response } from \"../../request\";\nimport { ResourceResponse } from \"../../request\";\nimport type { PartitionedQueryExecutionInfo } from \"../../request/ErrorResponse\";\nimport { Conflict, Conflicts } from \"../Conflict\";\nimport type { Database } from \"../Database\";\nimport { Item, Items } from \"../Item\";\nimport { Scripts } from \"../Script/Scripts\";\nimport type { ContainerDefinition } from \"./ContainerDefinition\";\nimport { ContainerResponse } from \"./ContainerResponse\";\nimport type { PartitionKeyRange } from \"./PartitionKeyRange\";\nimport type { OfferDefinition } from \"../Offer\";\nimport { Offer } from \"../Offer\";\nimport { OfferResponse } from \"../Offer/OfferResponse\";\nimport type { Resource } from \"../Resource\";\nimport type { FeedRange } from \"../ChangeFeed\";\nimport { FeedRangeInternal } from \"../ChangeFeed\";\nimport type { DiagnosticNodeInternal } from \"../../diagnostics/DiagnosticNodeInternal\";\nimport {\n  getEmptyCosmosDiagnostics,\n  withDiagnostics,\n  withMetadataDiagnostics,\n} from \"../../utils/diagnostics\";\nimport { MetadataLookUpType } from \"../../CosmosDiagnostics\";\n\n/**\n * Operations for reading, replacing, or deleting a specific, existing container by id.\n *\n * @see {@link Containers} for creating new containers, and reading/querying all containers; use `.containers`.\n *\n * Note: all these operations make calls against a fixed budget.\n * You should design your system such that these calls scale sublinearly with your application.\n * For instance, do not call `container(id).read()` before every single `item.read()` call, to ensure the container exists;\n * do this once on application start up.\n */\nexport class Container {\n  private $items: Items;\n  /**\n   * Operations for creating new items, and reading/querying all items\n   *\n   * For reading, replacing, or deleting an existing item, use `.item(id)`.\n   *\n   * @example Create a new item\n   * ```typescript\n   * const {body: createdItem} = await container.items.create({id: \"<item id>\", properties: {}});\n   * ```\n   */\n  public get items(): Items {\n    if (!this.$items) {\n      this.$items = new Items(this, this.clientContext);\n    }\n    return this.$items;\n  }\n\n  private $scripts: Scripts;\n  /**\n   * All operations for Stored Procedures, Triggers, and User Defined Functions\n   */\n  public get scripts(): Scripts {\n    if (!this.$scripts) {\n      this.$scripts = new Scripts(this, this.clientContext);\n    }\n    return this.$scripts;\n  }\n\n  private $conflicts: Conflicts;\n  /**\n   * Operations for reading and querying conflicts for the given container.\n   *\n   * For reading or deleting a specific conflict, use `.conflict(id)`.\n   */\n  public get conflicts(): Conflicts {\n    if (!this.$conflicts) {\n      this.$conflicts = new Conflicts(this, this.clientContext);\n    }\n    return this.$conflicts;\n  }\n\n  /**\n   * Returns a reference URL to the resource. Used for linking in Permissions.\n   */\n  public get url(): string {\n    return createDocumentCollectionUri(this.database.id, this.id);\n  }\n\n  /**\n   * Returns a container instance. Note: You should get this from `database.container(id)`, rather than creating your own object.\n   * @param database - The parent {@link Database}.\n   * @param id - The id of the given container.\n   * @hidden\n   */\n  constructor(\n    public readonly database: Database,\n    public readonly id: string,\n    private readonly clientContext: ClientContext,\n  ) {}\n\n  /**\n   * Used to read, replace, or delete a specific, existing {@link Item} by id.\n   *\n   * Use `.items` for creating new items, or querying/reading all items.\n   *\n   * @param id - The id of the {@link Item}.\n   * @param partitionKeyValue - The value of the {@link Item} partition key\n   * @example Replace an item\n   * `const {body: replacedItem} = await container.item(\"<item id>\", \"<partition key value>\").replace({id: \"<item id>\", title: \"Updated post\", authorID: 5});`\n   */\n  public item(id: string, partitionKeyValue?: PartitionKey): Item {\n    return new Item(this, id, this.clientContext, partitionKeyValue);\n  }\n\n  /**\n   * Used to read, replace, or delete a specific, existing {@link Conflict} by id.\n   *\n   * Use `.conflicts` for creating new conflicts, or querying/reading all conflicts.\n   * @param id - The id of the {@link Conflict}.\n   */\n  public conflict(id: string, partitionKey?: PartitionKey): Conflict {\n    return new Conflict(this, id, this.clientContext, partitionKey);\n  }\n\n  /** Read the container's definition */\n  public async read(options?: RequestOptions): Promise<ContainerResponse> {\n    return withDiagnostics(async (diagnosticNode: DiagnosticNodeInternal) => {\n      return this.readInternal(diagnosticNode, options);\n    }, this.clientContext);\n  }\n\n  /**\n   * @hidden\n   */\n  public async readInternal(\n    diagnosticNode: DiagnosticNodeInternal,\n    options?: RequestOptions,\n  ): Promise<ContainerResponse> {\n    const path = getPathFromLink(this.url);\n    const id = getIdFromLink(this.url);\n    const response = await this.clientContext.read<ContainerDefinition>({\n      path,\n      resourceType: ResourceType.container,\n      resourceId: id,\n      options,\n      diagnosticNode,\n    });\n    this.clientContext.partitionKeyDefinitionCache[this.url] = response.result.partitionKey;\n    return new ContainerResponse(\n      response.result,\n      response.headers,\n      response.code,\n      this,\n      getEmptyCosmosDiagnostics(),\n    );\n  }\n\n  /** Replace the container's definition */\n  public async replace(\n    body: ContainerDefinition,\n    options?: RequestOptions,\n  ): Promise<ContainerResponse> {\n    return withDiagnostics(async (diagnosticNode: DiagnosticNodeInternal) => {\n      const err = {};\n      if (!isResourceValid(body, err)) {\n        throw err;\n      }\n      const path = getPathFromLink(this.url);\n      const id = getIdFromLink(this.url);\n\n      const response = await this.clientContext.replace<ContainerDefinition>({\n        body,\n        path,\n        resourceType: ResourceType.container,\n        resourceId: id,\n        options,\n        diagnosticNode,\n      });\n      return new ContainerResponse(\n        response.result,\n        response.headers,\n        response.code,\n        this,\n        getEmptyCosmosDiagnostics(),\n      );\n    }, this.clientContext);\n  }\n\n  /** Delete the container */\n  public async delete(options?: RequestOptions): Promise<ContainerResponse> {\n    return withDiagnostics(async (diagnosticNode: DiagnosticNodeInternal) => {\n      const path = getPathFromLink(this.url);\n      const id = getIdFromLink(this.url);\n\n      const response = await this.clientContext.delete<ContainerDefinition>({\n        path,\n        resourceType: ResourceType.container,\n        resourceId: id,\n        options,\n        diagnosticNode,\n      });\n      return new ContainerResponse(\n        response.result,\n        response.headers,\n        response.code,\n        this,\n        getEmptyCosmosDiagnostics(),\n      );\n    }, this.clientContext);\n  }\n\n  /**\n   * Gets the partition key definition first by looking into the cache otherwise by reading the collection.\n   * @deprecated This method has been renamed to readPartitionKeyDefinition.\n   */\n  public async getPartitionKeyDefinition(): Promise<ResourceResponse<PartitionKeyDefinition>> {\n    return withDiagnostics(async (diagnosticNode: DiagnosticNodeInternal) => {\n      return this.readPartitionKeyDefinition(diagnosticNode);\n    }, this.clientContext);\n  }\n\n  /**\n   * Gets the partition key definition first by looking into the cache otherwise by reading the collection.\n   * @hidden\n   */\n  public async readPartitionKeyDefinition(\n    diagnosticNode: DiagnosticNodeInternal,\n  ): Promise<ResourceResponse<PartitionKeyDefinition>> {\n    // $ISSUE-felixfan-2016-03-17: Make name based path and link based path use the same key\n    // $ISSUE-felixfan-2016-03-17: Refresh partitionKeyDefinitionCache when necessary\n    if (this.url in this.clientContext.partitionKeyDefinitionCache) {\n      diagnosticNode.addData({ readFromCache: true });\n      return new ResourceResponse<PartitionKeyDefinition>(\n        this.clientContext.partitionKeyDefinitionCache[this.url],\n        {},\n        0,\n        getEmptyCosmosDiagnostics(),\n      );\n    }\n\n    const { headers, statusCode, diagnostics } = await withMetadataDiagnostics(\n      async (node: DiagnosticNodeInternal) => {\n        return this.readInternal(node);\n      },\n      diagnosticNode,\n      MetadataLookUpType.ContainerLookUp,\n    );\n\n    return new ResourceResponse<PartitionKeyDefinition>(\n      this.clientContext.partitionKeyDefinitionCache[this.url],\n      headers,\n      statusCode,\n      diagnostics,\n    );\n  }\n\n  /**\n   * Gets offer on container. If none exists, returns an OfferResponse with undefined.\n   */\n  public async readOffer(options: RequestOptions = {}): Promise<OfferResponse> {\n    return withDiagnostics(async (diagnosticNode: DiagnosticNodeInternal) => {\n      const { resource: container } = await this.read();\n      const path = \"/offers\";\n      const url = container._self;\n\n      const response = await this.clientContext.queryFeed<OfferDefinition & Resource[]>({\n        path,\n        resourceId: \"\",\n        resourceType: ResourceType.offer,\n        query: `SELECT * from root where root.resource = \"${url}\"`,\n        resultFn: (result) => result.Offers,\n        options,\n        diagnosticNode,\n      });\n      const offer = response.result[0]\n        ? new Offer(this.database.client, response.result[0].id, this.clientContext)\n        : undefined;\n      return new OfferResponse(\n        response.result[0],\n        response.headers,\n        response.code,\n        getEmptyCosmosDiagnostics(),\n        offer,\n      );\n    }, this.clientContext);\n  }\n\n  public async getQueryPlan(\n    query: string | SqlQuerySpec,\n  ): Promise<Response<PartitionedQueryExecutionInfo>> {\n    return withDiagnostics(async (diagnosticNode: DiagnosticNodeInternal) => {\n      const path = getPathFromLink(this.url);\n\n      return this.clientContext.getQueryPlan(\n        path + \"/docs\",\n        ResourceType.item,\n        getIdFromLink(this.url),\n        query,\n        {},\n        diagnosticNode,\n      );\n    }, this.clientContext);\n  }\n\n  public readPartitionKeyRanges(feedOptions?: FeedOptions): QueryIterator<PartitionKeyRange> {\n    feedOptions = feedOptions || {};\n    return this.clientContext.queryPartitionKeyRanges(this.url, undefined, feedOptions);\n  }\n  /**\n   *\n   * @returns all the feed ranges for which changefeed could be fetched.\n   */\n  public async getFeedRanges(): Promise<ReadonlyArray<FeedRange>> {\n    return withDiagnostics(async (diagnosticNode: DiagnosticNodeInternal) => {\n      const { resources } = await this.readPartitionKeyRanges().fetchAllInternal(diagnosticNode);\n\n      const feedRanges: FeedRange[] = [];\n      for (const resource of resources) {\n        const feedRange = new FeedRangeInternal(resource.minInclusive, resource.maxExclusive);\n        Object.freeze(feedRange);\n        feedRanges.push(feedRange);\n      }\n      return feedRanges;\n    }, this.clientContext);\n  }\n\n  /**\n   * Delete all documents belong to the container for the provided partition key value\n   * @param partitionKey - The partition key value of the items to be deleted\n   */\n  public async deleteAllItemsForPartitionKey(\n    partitionKey: PartitionKey,\n    options?: RequestOptions,\n  ): Promise<ContainerResponse> {\n    return withDiagnostics(async (diagnosticNode: DiagnosticNodeInternal) => {\n      let path = getPathFromLink(this.url);\n      const id = getIdFromLink(this.url);\n      path = path + \"/operations/partitionkeydelete\";\n      const response = await this.clientContext.delete<ContainerDefinition>({\n        path,\n        resourceType: ResourceType.container,\n        resourceId: id,\n        options,\n        partitionKey: partitionKey,\n        method: HTTPMethod.post,\n        diagnosticNode,\n      });\n      return new ContainerResponse(\n        response.result,\n        response.headers,\n        response.code,\n        this,\n        getEmptyCosmosDiagnostics(),\n      );\n    }, this.clientContext);\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}