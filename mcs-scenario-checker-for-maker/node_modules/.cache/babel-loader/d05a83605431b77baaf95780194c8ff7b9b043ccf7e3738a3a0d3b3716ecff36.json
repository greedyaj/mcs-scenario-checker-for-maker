{"ast":null,"code":"// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport { bearerTokenAuthenticationPolicy, createEmptyPipeline } from \"@azure/core-rest-pipeline\";\nimport { Constants, HTTPMethod, OperationType, ResourceType } from \"./common/constants\";\nimport { getIdFromLink, getPathFromLink, parseLink } from \"./common/helper\";\nimport { StatusCodes, SubStatusCodes } from \"./common/statusCodes\";\nimport { ConsistencyLevel, DatabaseAccount, convertToInternalPartitionKey } from \"./documents\";\nimport { PluginOn, executePlugins } from \"./plugins/Plugin\";\nimport { QueryIterator } from \"./queryIterator\";\nimport { getHeaders } from \"./request/request\";\nimport { RequestHandler } from \"./request/RequestHandler\";\nimport { SessionContainer } from \"./session/sessionContainer\";\nimport { sanitizeEndpoint } from \"./utils/checkURL\";\nimport { supportedQueryFeaturesBuilder } from \"./utils/supportedQueryFeaturesBuilder\";\nimport { createClientLogger } from \"@azure/logger\";\nimport { LogDiagnosticWriter, NoOpDiagnosticWriter } from \"./diagnostics/DiagnosticWriter\";\nimport { DefaultDiagnosticFormatter } from \"./diagnostics/DiagnosticFormatter\";\nimport { CosmosDbDiagnosticLevel } from \"./diagnostics/CosmosDbDiagnosticLevel\";\nimport { randomUUID } from \"@azure/core-util\";\nconst logger = createClientLogger(\"ClientContext\");\nconst QueryJsonContentType = \"application/query+json\";\nconst HttpHeaders = Constants.HttpHeaders;\n/**\n * @hidden\n * @hidden\n */\nexport class ClientContext {\n  constructor(cosmosClientOptions, globalEndpointManager, clientConfig, diagnosticLevel) {\n    this.cosmosClientOptions = cosmosClientOptions;\n    this.globalEndpointManager = globalEndpointManager;\n    this.clientConfig = clientConfig;\n    this.diagnosticLevel = diagnosticLevel;\n    this.connectionPolicy = cosmosClientOptions.connectionPolicy;\n    this.sessionContainer = new SessionContainer();\n    this.partitionKeyDefinitionCache = {};\n    this.pipeline = null;\n    if (cosmosClientOptions.aadCredentials) {\n      this.pipeline = createEmptyPipeline();\n      const hrefEndpoint = sanitizeEndpoint(cosmosClientOptions.endpoint);\n      const scope = `${hrefEndpoint}/.default`;\n      this.pipeline.addPolicy(bearerTokenAuthenticationPolicy({\n        credential: cosmosClientOptions.aadCredentials,\n        scopes: scope,\n        challengeCallbacks: {\n          async authorizeRequest({\n            request,\n            getAccessToken\n          }) {\n            const tokenResponse = await getAccessToken([scope], {});\n            const AUTH_PREFIX = `type=aad&ver=1.0&sig=`;\n            const authorizationToken = `${AUTH_PREFIX}${tokenResponse.token}`;\n            request.headers.set(\"Authorization\", authorizationToken);\n          }\n        }\n      }));\n    }\n    this.initializeDiagnosticSettings(diagnosticLevel);\n  }\n  /** @hidden */\n  async read({\n    path,\n    resourceType,\n    resourceId,\n    options = {},\n    partitionKey,\n    diagnosticNode\n  }) {\n    try {\n      const request = Object.assign(Object.assign({}, this.getContextDerivedPropsForRequestCreation()), {\n        method: HTTPMethod.get,\n        path,\n        operationType: OperationType.Read,\n        resourceId,\n        options,\n        resourceType,\n        partitionKey\n      });\n      diagnosticNode.addData({\n        operationType: OperationType.Read,\n        resourceType\n      });\n      request.headers = await this.buildHeaders(request);\n      this.applySessionToken(request);\n      // read will use ReadEndpoint since it uses GET operation\n      request.endpoint = await this.globalEndpointManager.resolveServiceEndpoint(diagnosticNode, request.resourceType, request.operationType);\n      const response = await executePlugins(diagnosticNode, request, RequestHandler.request, PluginOn.operation);\n      this.captureSessionToken(undefined, path, OperationType.Read, response.headers);\n      return response;\n    } catch (err) {\n      this.captureSessionToken(err, path, OperationType.Upsert, err.headers);\n      throw err;\n    }\n  }\n  async queryFeed({\n    path,\n    resourceType,\n    resourceId,\n    resultFn,\n    query,\n    options,\n    diagnosticNode,\n    partitionKeyRangeId,\n    partitionKey,\n    startEpk,\n    endEpk,\n    correlatedActivityId\n  }) {\n    // Query operations will use ReadEndpoint even though it uses\n    // GET(for queryFeed) and POST(for regular query operations)\n    const request = Object.assign(Object.assign({}, this.getContextDerivedPropsForRequestCreation()), {\n      method: HTTPMethod.get,\n      path,\n      operationType: OperationType.Query,\n      partitionKeyRangeId,\n      resourceId,\n      resourceType,\n      options,\n      body: query,\n      partitionKey\n    });\n    diagnosticNode.addData({\n      operationType: OperationType.Query,\n      resourceType\n    });\n    const requestId = randomUUID();\n    if (query !== undefined) {\n      request.method = HTTPMethod.post;\n    }\n    request.endpoint = await this.globalEndpointManager.resolveServiceEndpoint(diagnosticNode, request.resourceType, request.operationType);\n    request.headers = await this.buildHeaders(request);\n    if (startEpk !== undefined && endEpk !== undefined) {\n      request.headers[HttpHeaders.StartEpk] = startEpk;\n      request.headers[HttpHeaders.EndEpk] = endEpk;\n      request.headers[HttpHeaders.ReadFeedKeyType] = \"EffectivePartitionKeyRange\";\n    }\n    if (query !== undefined) {\n      if (correlatedActivityId !== undefined) {\n        request.headers[HttpHeaders.CorrelatedActivityId] = correlatedActivityId;\n      }\n      request.headers[HttpHeaders.IsQuery] = \"true\";\n      request.headers[HttpHeaders.ContentType] = QueryJsonContentType;\n      if (typeof query === \"string\") {\n        request.body = {\n          query\n        }; // Converts query text to query object.\n      }\n    }\n    this.applySessionToken(request);\n    logger.info(\"query \" + requestId + \" started\" + (request.partitionKeyRangeId ? \" pkrid: \" + request.partitionKeyRangeId : \"\"));\n    logger.verbose(request);\n    const start = Date.now();\n    const response = await RequestHandler.request(request, diagnosticNode);\n    logger.info(\"query \" + requestId + \" finished - \" + (Date.now() - start) + \"ms\");\n    this.captureSessionToken(undefined, path, OperationType.Query, response.headers);\n    return this.processQueryFeedResponse(response, !!query, resultFn);\n  }\n  async getQueryPlan(path, resourceType, resourceId, query, options = {}, diagnosticNode, correlatedActivityId) {\n    const request = Object.assign(Object.assign({}, this.getContextDerivedPropsForRequestCreation()), {\n      method: HTTPMethod.post,\n      path,\n      operationType: OperationType.Read,\n      resourceId,\n      resourceType,\n      options,\n      body: query\n    });\n    diagnosticNode.addData({\n      operationType: OperationType.Read,\n      resourceType\n    });\n    request.endpoint = await this.globalEndpointManager.resolveServiceEndpoint(diagnosticNode, request.resourceType, request.operationType);\n    request.headers = await this.buildHeaders(request);\n    if (correlatedActivityId !== undefined) {\n      request.headers[HttpHeaders.CorrelatedActivityId] = correlatedActivityId;\n    }\n    request.headers[HttpHeaders.IsQueryPlan] = \"True\";\n    request.headers[HttpHeaders.QueryVersion] = \"1.4\";\n    request.headers[HttpHeaders.ContentType] = QueryJsonContentType;\n    request.headers[HttpHeaders.SupportedQueryFeatures] = supportedQueryFeaturesBuilder(options.disableNonStreamingOrderByQuery);\n    if (typeof query === \"string\") {\n      request.body = {\n        query\n      }; // Converts query text to query object.\n    }\n    this.applySessionToken(request);\n    const response = await RequestHandler.request(request, diagnosticNode);\n    this.captureSessionToken(undefined, path, OperationType.Query, response.headers);\n    return response;\n  }\n  queryPartitionKeyRanges(collectionLink, query, options) {\n    const path = getPathFromLink(collectionLink, ResourceType.pkranges);\n    const id = getIdFromLink(collectionLink);\n    const cb = async (diagNode, innerOptions) => {\n      const response = await this.queryFeed({\n        path,\n        resourceType: ResourceType.pkranges,\n        resourceId: id,\n        resultFn: result => result.PartitionKeyRanges,\n        query,\n        options: innerOptions,\n        diagnosticNode: diagNode\n      });\n      return response;\n    };\n    return new QueryIterator(this, query, options, cb);\n  }\n  async delete({\n    path,\n    resourceType,\n    resourceId,\n    options = {},\n    partitionKey,\n    method = HTTPMethod.delete,\n    diagnosticNode\n  }) {\n    try {\n      const request = Object.assign(Object.assign({}, this.getContextDerivedPropsForRequestCreation()), {\n        method: method,\n        operationType: OperationType.Delete,\n        path,\n        resourceType,\n        options,\n        resourceId,\n        partitionKey\n      });\n      diagnosticNode.addData({\n        operationType: OperationType.Delete,\n        resourceType\n      });\n      request.headers = await this.buildHeaders(request);\n      this.applySessionToken(request);\n      // deleteResource will use WriteEndpoint since it uses DELETE operation\n      request.endpoint = await this.globalEndpointManager.resolveServiceEndpoint(diagnosticNode, request.resourceType, request.operationType);\n      const response = await executePlugins(diagnosticNode, request, RequestHandler.request, PluginOn.operation);\n      if (parseLink(path).type !== \"colls\") {\n        this.captureSessionToken(undefined, path, OperationType.Delete, response.headers);\n      } else {\n        this.clearSessionToken(path);\n      }\n      return response;\n    } catch (err) {\n      this.captureSessionToken(err, path, OperationType.Upsert, err.headers);\n      throw err;\n    }\n  }\n  async patch({\n    body,\n    path,\n    resourceType,\n    resourceId,\n    options = {},\n    partitionKey,\n    diagnosticNode\n  }) {\n    try {\n      const request = Object.assign(Object.assign({}, this.getContextDerivedPropsForRequestCreation()), {\n        method: HTTPMethod.patch,\n        operationType: OperationType.Patch,\n        path,\n        resourceType,\n        body,\n        resourceId,\n        options,\n        partitionKey\n      });\n      diagnosticNode.addData({\n        operationType: OperationType.Patch,\n        resourceType\n      });\n      request.headers = await this.buildHeaders(request);\n      this.applySessionToken(request);\n      // patch will use WriteEndpoint\n      request.endpoint = await this.globalEndpointManager.resolveServiceEndpoint(diagnosticNode, request.resourceType, request.operationType);\n      const response = await executePlugins(diagnosticNode, request, RequestHandler.request, PluginOn.operation);\n      this.captureSessionToken(undefined, path, OperationType.Patch, response.headers);\n      return response;\n    } catch (err) {\n      this.captureSessionToken(err, path, OperationType.Upsert, err.headers);\n      throw err;\n    }\n  }\n  async create({\n    body,\n    path,\n    resourceType,\n    resourceId,\n    diagnosticNode,\n    options = {},\n    partitionKey\n  }) {\n    try {\n      const request = Object.assign(Object.assign({}, this.getContextDerivedPropsForRequestCreation()), {\n        method: HTTPMethod.post,\n        operationType: OperationType.Create,\n        path,\n        resourceType,\n        resourceId,\n        body,\n        options,\n        partitionKey\n      });\n      diagnosticNode.addData({\n        operationType: OperationType.Create,\n        resourceType\n      });\n      request.headers = await this.buildHeaders(request);\n      // create will use WriteEndpoint since it uses POST operation\n      this.applySessionToken(request);\n      request.endpoint = await this.globalEndpointManager.resolveServiceEndpoint(diagnosticNode, request.resourceType, request.operationType);\n      const response = await executePlugins(diagnosticNode, request, RequestHandler.request, PluginOn.operation);\n      this.captureSessionToken(undefined, path, OperationType.Create, response.headers);\n      return response;\n    } catch (err) {\n      this.captureSessionToken(err, path, OperationType.Upsert, err.headers);\n      throw err;\n    }\n  }\n  processQueryFeedResponse(res, isQuery, resultFn) {\n    if (isQuery) {\n      return {\n        result: resultFn(res.result),\n        headers: res.headers,\n        code: res.code\n      };\n    } else {\n      const newResult = resultFn(res.result).map(body => body);\n      return {\n        result: newResult,\n        headers: res.headers,\n        code: res.code\n      };\n    }\n  }\n  applySessionToken(requestContext) {\n    const request = this.getSessionParams(requestContext.path);\n    if (requestContext.headers && requestContext.headers[HttpHeaders.SessionToken]) {\n      return;\n    }\n    const sessionConsistency = requestContext.headers[HttpHeaders.ConsistencyLevel];\n    if (!sessionConsistency) {\n      return;\n    }\n    if (sessionConsistency !== ConsistencyLevel.Session) {\n      return;\n    }\n    if (request.resourceAddress) {\n      const sessionToken = this.sessionContainer.get(request);\n      if (sessionToken) {\n        requestContext.headers[HttpHeaders.SessionToken] = sessionToken;\n      }\n    }\n  }\n  async replace({\n    body,\n    path,\n    resourceType,\n    resourceId,\n    options = {},\n    partitionKey,\n    diagnosticNode\n  }) {\n    try {\n      const request = Object.assign(Object.assign({}, this.getContextDerivedPropsForRequestCreation()), {\n        method: HTTPMethod.put,\n        operationType: OperationType.Replace,\n        path,\n        resourceType,\n        body,\n        resourceId,\n        options,\n        partitionKey\n      });\n      diagnosticNode.addData({\n        operationType: OperationType.Replace,\n        resourceType\n      });\n      request.headers = await this.buildHeaders(request);\n      this.applySessionToken(request);\n      // replace will use WriteEndpoint since it uses PUT operation\n      request.endpoint = await this.globalEndpointManager.resolveServiceEndpoint(diagnosticNode, request.resourceType, request.operationType);\n      const response = await executePlugins(diagnosticNode, request, RequestHandler.request, PluginOn.operation);\n      this.captureSessionToken(undefined, path, OperationType.Replace, response.headers);\n      return response;\n    } catch (err) {\n      this.captureSessionToken(err, path, OperationType.Upsert, err.headers);\n      throw err;\n    }\n  }\n  async upsert({\n    body,\n    path,\n    resourceType,\n    resourceId,\n    options = {},\n    partitionKey,\n    diagnosticNode\n  }) {\n    try {\n      const request = Object.assign(Object.assign({}, this.getContextDerivedPropsForRequestCreation()), {\n        method: HTTPMethod.post,\n        operationType: OperationType.Upsert,\n        path,\n        resourceType,\n        body,\n        resourceId,\n        options,\n        partitionKey\n      });\n      diagnosticNode.addData({\n        operationType: OperationType.Upsert,\n        resourceType\n      });\n      request.headers = await this.buildHeaders(request);\n      request.headers[HttpHeaders.IsUpsert] = true;\n      this.applySessionToken(request);\n      // upsert will use WriteEndpoint since it uses POST operation\n      request.endpoint = await this.globalEndpointManager.resolveServiceEndpoint(diagnosticNode, request.resourceType, request.operationType);\n      const response = await executePlugins(diagnosticNode, request, RequestHandler.request, PluginOn.operation);\n      this.captureSessionToken(undefined, path, OperationType.Upsert, response.headers);\n      return response;\n    } catch (err) {\n      this.captureSessionToken(err, path, OperationType.Upsert, err.headers);\n      throw err;\n    }\n  }\n  async execute({\n    sprocLink,\n    params,\n    options = {},\n    partitionKey,\n    diagnosticNode\n  }) {\n    // Accept a single parameter or an array of parameters.\n    // Didn't add type annotation for this because we should legacy this behavior\n    if (params !== null && params !== undefined && !Array.isArray(params)) {\n      params = [params];\n    }\n    const path = getPathFromLink(sprocLink);\n    const id = getIdFromLink(sprocLink);\n    const request = Object.assign(Object.assign({}, this.getContextDerivedPropsForRequestCreation()), {\n      method: HTTPMethod.post,\n      operationType: OperationType.Execute,\n      path,\n      resourceType: ResourceType.sproc,\n      options,\n      resourceId: id,\n      body: params,\n      partitionKey\n    });\n    diagnosticNode.addData({\n      operationType: OperationType.Execute,\n      resourceType: ResourceType.sproc\n    });\n    request.headers = await this.buildHeaders(request);\n    // executeStoredProcedure will use WriteEndpoint since it uses POST operation\n    request.endpoint = await this.globalEndpointManager.resolveServiceEndpoint(diagnosticNode, request.resourceType, request.operationType);\n    const response = await executePlugins(diagnosticNode, request, RequestHandler.request, PluginOn.operation);\n    return response;\n  }\n  /**\n   * Gets the Database account information.\n   * @param options - `urlConnection` in the options is the endpoint url whose database account needs to be retrieved.\n   * If not present, current client's url will be used.\n   */\n  async getDatabaseAccount(diagnosticNode, options = {}) {\n    const endpoint = options.urlConnection || this.cosmosClientOptions.endpoint;\n    const request = Object.assign(Object.assign({}, this.getContextDerivedPropsForRequestCreation()), {\n      endpoint,\n      method: HTTPMethod.get,\n      operationType: OperationType.Read,\n      path: \"\",\n      resourceType: ResourceType.none,\n      options\n    });\n    diagnosticNode.addData({\n      operationType: OperationType.Read,\n      resourceType: ResourceType.none\n    });\n    request.headers = await this.buildHeaders(request);\n    // await options.beforeOperation({ endpoint, request, headers: requestHeaders });\n    const {\n      result,\n      headers,\n      code,\n      substatus,\n      diagnostics\n    } = await executePlugins(diagnosticNode, request, RequestHandler.request, PluginOn.operation);\n    const databaseAccount = new DatabaseAccount(result, headers);\n    return {\n      result: databaseAccount,\n      headers,\n      diagnostics,\n      code: code,\n      substatus: substatus\n    };\n  }\n  getWriteEndpoint(diagnosticNode) {\n    return this.globalEndpointManager.getWriteEndpoint(diagnosticNode);\n  }\n  getReadEndpoint(diagnosticNode) {\n    return this.globalEndpointManager.getReadEndpoint(diagnosticNode);\n  }\n  getWriteEndpoints() {\n    return this.globalEndpointManager.getWriteEndpoints();\n  }\n  getReadEndpoints() {\n    return this.globalEndpointManager.getReadEndpoints();\n  }\n  async batch({\n    body,\n    path,\n    partitionKey,\n    resourceId,\n    options = {},\n    diagnosticNode\n  }) {\n    try {\n      const request = Object.assign(Object.assign({}, this.getContextDerivedPropsForRequestCreation()), {\n        method: HTTPMethod.post,\n        operationType: OperationType.Batch,\n        path,\n        body,\n        resourceType: ResourceType.item,\n        resourceId,\n        options,\n        partitionKey\n      });\n      diagnosticNode.addData({\n        operationType: OperationType.Batch,\n        resourceType: ResourceType.item\n      });\n      request.headers = await this.buildHeaders(request);\n      request.headers[HttpHeaders.IsBatchRequest] = true;\n      request.headers[HttpHeaders.IsBatchAtomic] = true;\n      this.applySessionToken(request);\n      request.endpoint = await this.globalEndpointManager.resolveServiceEndpoint(diagnosticNode, request.resourceType, request.operationType);\n      const response = await executePlugins(diagnosticNode, request, RequestHandler.request, PluginOn.operation);\n      this.captureSessionToken(undefined, path, OperationType.Batch, response.headers);\n      response.diagnostics = diagnosticNode.toDiagnostic(this.getClientConfig());\n      return response;\n    } catch (err) {\n      this.captureSessionToken(err, path, OperationType.Upsert, err.headers);\n      throw err;\n    }\n  }\n  async bulk({\n    body,\n    path,\n    partitionKeyRangeId,\n    resourceId,\n    bulkOptions = {},\n    options = {},\n    diagnosticNode\n  }) {\n    var _a;\n    try {\n      const request = Object.assign(Object.assign({}, this.getContextDerivedPropsForRequestCreation()), {\n        method: HTTPMethod.post,\n        operationType: OperationType.Batch,\n        path,\n        body,\n        resourceType: ResourceType.item,\n        resourceId,\n        options\n      });\n      diagnosticNode.addData({\n        operationType: OperationType.Batch,\n        resourceType: ResourceType.item\n      });\n      request.headers = await this.buildHeaders(request);\n      request.headers[HttpHeaders.IsBatchRequest] = true;\n      request.headers[HttpHeaders.PartitionKeyRangeID] = partitionKeyRangeId;\n      request.headers[HttpHeaders.IsBatchAtomic] = false;\n      request.headers[HttpHeaders.BatchContinueOnError] = (_a = bulkOptions.continueOnError) !== null && _a !== void 0 ? _a : true;\n      this.applySessionToken(request);\n      request.endpoint = await this.globalEndpointManager.resolveServiceEndpoint(diagnosticNode, request.resourceType, request.operationType);\n      const response = await executePlugins(diagnosticNode, request, RequestHandler.request, PluginOn.operation);\n      this.captureSessionToken(undefined, path, OperationType.Batch, response.headers);\n      return response;\n    } catch (err) {\n      this.captureSessionToken(err, path, OperationType.Upsert, err.headers);\n      throw err;\n    }\n  }\n  captureSessionToken(err, path, operationType, resHeaders) {\n    const request = this.getSessionParams(path);\n    request.operationType = operationType;\n    if (!err || !this.isMasterResource(request.resourceType) && (err.code === StatusCodes.PreconditionFailed || err.code === StatusCodes.Conflict || err.code === StatusCodes.NotFound && err.substatus !== SubStatusCodes.ReadSessionNotAvailable)) {\n      this.sessionContainer.set(request, resHeaders);\n    }\n  }\n  clearSessionToken(path) {\n    const request = this.getSessionParams(path);\n    this.sessionContainer.remove(request);\n  }\n  recordDiagnostics(diagnostic) {\n    const formatted = this.diagnosticFormatter.format(diagnostic);\n    this.diagnosticWriter.write(formatted);\n  }\n  initializeDiagnosticSettings(diagnosticLevel) {\n    this.diagnosticFormatter = new DefaultDiagnosticFormatter();\n    switch (diagnosticLevel) {\n      case CosmosDbDiagnosticLevel.info:\n        this.diagnosticWriter = new NoOpDiagnosticWriter();\n        break;\n      default:\n        this.diagnosticWriter = new LogDiagnosticWriter();\n    }\n  }\n  // TODO: move\n  getSessionParams(resourceLink) {\n    const resourceId = null;\n    let resourceAddress = null;\n    const parserOutput = parseLink(resourceLink);\n    resourceAddress = parserOutput.objectBody.self;\n    const resourceType = parserOutput.type;\n    return {\n      resourceId,\n      resourceAddress,\n      resourceType,\n      isNameBased: true\n    };\n  }\n  isMasterResource(resourceType) {\n    if (resourceType === Constants.Path.OffersPathSegment || resourceType === Constants.Path.DatabasesPathSegment || resourceType === Constants.Path.UsersPathSegment || resourceType === Constants.Path.PermissionsPathSegment || resourceType === Constants.Path.TopologyPathSegment || resourceType === Constants.Path.DatabaseAccountPathSegment || resourceType === Constants.Path.PartitionKeyRangesPathSegment || resourceType === Constants.Path.CollectionsPathSegment) {\n      return true;\n    }\n    return false;\n  }\n  buildHeaders(requestContext) {\n    return getHeaders({\n      clientOptions: this.cosmosClientOptions,\n      defaultHeaders: Object.assign(Object.assign({}, this.cosmosClientOptions.defaultHeaders), requestContext.options.initialHeaders),\n      verb: requestContext.method,\n      path: requestContext.path,\n      resourceId: requestContext.resourceId,\n      resourceType: requestContext.resourceType,\n      options: requestContext.options,\n      partitionKeyRangeId: requestContext.partitionKeyRangeId,\n      useMultipleWriteLocations: this.connectionPolicy.useMultipleWriteLocations,\n      partitionKey: requestContext.partitionKey !== undefined ? convertToInternalPartitionKey(requestContext.partitionKey) : undefined // TODO: Move this check from here to PartitionKey\n    });\n  }\n  /**\n   * Returns collection of properties which are derived from the context for Request Creation.\n   * These properties have client wide scope, as opposed to request specific scope.\n   * @returns\n   */\n  getContextDerivedPropsForRequestCreation() {\n    return {\n      globalEndpointManager: this.globalEndpointManager,\n      requestAgent: this.cosmosClientOptions.agent,\n      connectionPolicy: this.connectionPolicy,\n      client: this,\n      plugins: this.cosmosClientOptions.plugins,\n      pipeline: this.pipeline,\n      httpClient: this.cosmosClientOptions.httpClient\n    };\n  }\n  getClientConfig() {\n    return this.clientConfig;\n  }\n}","map":{"version":3,"names":["bearerTokenAuthenticationPolicy","createEmptyPipeline","Constants","HTTPMethod","OperationType","ResourceType","getIdFromLink","getPathFromLink","parseLink","StatusCodes","SubStatusCodes","ConsistencyLevel","DatabaseAccount","convertToInternalPartitionKey","PluginOn","executePlugins","QueryIterator","getHeaders","RequestHandler","SessionContainer","sanitizeEndpoint","supportedQueryFeaturesBuilder","createClientLogger","LogDiagnosticWriter","NoOpDiagnosticWriter","DefaultDiagnosticFormatter","CosmosDbDiagnosticLevel","randomUUID","logger","QueryJsonContentType","HttpHeaders","ClientContext","constructor","cosmosClientOptions","globalEndpointManager","clientConfig","diagnosticLevel","connectionPolicy","sessionContainer","partitionKeyDefinitionCache","pipeline","aadCredentials","hrefEndpoint","endpoint","scope","addPolicy","credential","scopes","challengeCallbacks","authorizeRequest","request","getAccessToken","tokenResponse","AUTH_PREFIX","authorizationToken","token","headers","set","initializeDiagnosticSettings","read","path","resourceType","resourceId","options","partitionKey","diagnosticNode","Object","assign","getContextDerivedPropsForRequestCreation","method","get","operationType","Read","addData","buildHeaders","applySessionToken","resolveServiceEndpoint","response","operation","captureSessionToken","undefined","err","Upsert","queryFeed","resultFn","query","partitionKeyRangeId","startEpk","endEpk","correlatedActivityId","Query","body","requestId","post","StartEpk","EndEpk","ReadFeedKeyType","CorrelatedActivityId","IsQuery","ContentType","info","verbose","start","Date","now","processQueryFeedResponse","getQueryPlan","IsQueryPlan","QueryVersion","SupportedQueryFeatures","disableNonStreamingOrderByQuery","queryPartitionKeyRanges","collectionLink","pkranges","id","cb","diagNode","innerOptions","result","PartitionKeyRanges","delete","Delete","type","clearSessionToken","patch","Patch","create","Create","res","isQuery","code","newResult","map","requestContext","getSessionParams","SessionToken","sessionConsistency","Session","resourceAddress","sessionToken","replace","put","Replace","upsert","IsUpsert","execute","sprocLink","params","Array","isArray","Execute","sproc","getDatabaseAccount","urlConnection","none","substatus","diagnostics","databaseAccount","getWriteEndpoint","getReadEndpoint","getWriteEndpoints","getReadEndpoints","batch","Batch","item","IsBatchRequest","IsBatchAtomic","toDiagnostic","getClientConfig","bulk","bulkOptions","PartitionKeyRangeID","BatchContinueOnError","_a","continueOnError","resHeaders","isMasterResource","PreconditionFailed","Conflict","NotFound","ReadSessionNotAvailable","remove","recordDiagnostics","diagnostic","formatted","diagnosticFormatter","format","diagnosticWriter","write","resourceLink","parserOutput","objectBody","self","isNameBased","Path","OffersPathSegment","DatabasesPathSegment","UsersPathSegment","PermissionsPathSegment","TopologyPathSegment","DatabaseAccountPathSegment","PartitionKeyRangesPathSegment","CollectionsPathSegment","clientOptions","defaultHeaders","initialHeaders","verb","useMultipleWriteLocations","requestAgent","agent","client","plugins","httpClient"],"sources":["/Users/ajitpawar/microsoft/bap/POCs/Scenario_checker_for_maker/mcs-scenario-checker-for-maker/node_modules/@azure/cosmos/src/ClientContext.ts"],"sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\nimport type { HttpClient, Pipeline } from \"@azure/core-rest-pipeline\";\nimport { bearerTokenAuthenticationPolicy, createEmptyPipeline } from \"@azure/core-rest-pipeline\";\nimport type { PartitionKeyRange } from \"./client/Container/PartitionKeyRange\";\nimport type { Resource } from \"./client/Resource\";\nimport { Constants, HTTPMethod, OperationType, ResourceType } from \"./common/constants\";\nimport { getIdFromLink, getPathFromLink, parseLink } from \"./common/helper\";\nimport { StatusCodes, SubStatusCodes } from \"./common/statusCodes\";\nimport type { Agent, CosmosClientOptions } from \"./CosmosClientOptions\";\nimport type { ConnectionPolicy, PartitionKey } from \"./documents\";\nimport { ConsistencyLevel, DatabaseAccount, convertToInternalPartitionKey } from \"./documents\";\nimport type { GlobalEndpointManager } from \"./globalEndpointManager\";\nimport type { PluginConfig } from \"./plugins/Plugin\";\nimport { PluginOn, executePlugins } from \"./plugins/Plugin\";\nimport type { FetchFunctionCallback, SqlQuerySpec } from \"./queryExecutionContext\";\nimport type { CosmosHeaders } from \"./queryExecutionContext/CosmosHeaders\";\nimport { QueryIterator } from \"./queryIterator\";\nimport type { ErrorResponse } from \"./request\";\nimport type { FeedOptions, RequestOptions, Response } from \"./request\";\nimport type { PartitionedQueryExecutionInfo } from \"./request/ErrorResponse\";\nimport { getHeaders } from \"./request/request\";\nimport type { RequestContext } from \"./request/RequestContext\";\nimport { RequestHandler } from \"./request/RequestHandler\";\nimport { SessionContainer } from \"./session/sessionContainer\";\nimport type { SessionContext } from \"./session/SessionContext\";\nimport type { BulkOptions } from \"./utils/batch\";\nimport { sanitizeEndpoint } from \"./utils/checkURL\";\nimport { supportedQueryFeaturesBuilder } from \"./utils/supportedQueryFeaturesBuilder\";\nimport type { AzureLogger } from \"@azure/logger\";\nimport { createClientLogger } from \"@azure/logger\";\nimport type { ClientConfigDiagnostic, CosmosDiagnostics } from \"./CosmosDiagnostics\";\nimport type { DiagnosticNodeInternal } from \"./diagnostics/DiagnosticNodeInternal\";\nimport type { DiagnosticWriter } from \"./diagnostics/DiagnosticWriter\";\nimport { LogDiagnosticWriter, NoOpDiagnosticWriter } from \"./diagnostics/DiagnosticWriter\";\nimport type { DiagnosticFormatter } from \"./diagnostics/DiagnosticFormatter\";\nimport { DefaultDiagnosticFormatter } from \"./diagnostics/DiagnosticFormatter\";\nimport { CosmosDbDiagnosticLevel } from \"./diagnostics/CosmosDbDiagnosticLevel\";\nimport { randomUUID } from \"@azure/core-util\";\n\nconst logger: AzureLogger = createClientLogger(\"ClientContext\");\n\nconst QueryJsonContentType = \"application/query+json\";\nconst HttpHeaders = Constants.HttpHeaders;\n/**\n * @hidden\n * @hidden\n */\nexport class ClientContext {\n  private readonly sessionContainer: SessionContainer;\n  private connectionPolicy: ConnectionPolicy;\n  private pipeline: Pipeline;\n  private diagnosticWriter: DiagnosticWriter;\n  private diagnosticFormatter: DiagnosticFormatter;\n  public partitionKeyDefinitionCache: { [containerUrl: string]: any }; // TODO: PartitionKeyDefinitionCache\n  public constructor(\n    private cosmosClientOptions: CosmosClientOptions,\n    private globalEndpointManager: GlobalEndpointManager,\n    private clientConfig: ClientConfigDiagnostic,\n    public diagnosticLevel: CosmosDbDiagnosticLevel,\n  ) {\n    this.connectionPolicy = cosmosClientOptions.connectionPolicy;\n    this.sessionContainer = new SessionContainer();\n    this.partitionKeyDefinitionCache = {};\n    this.pipeline = null;\n    if (cosmosClientOptions.aadCredentials) {\n      this.pipeline = createEmptyPipeline();\n      const hrefEndpoint = sanitizeEndpoint(cosmosClientOptions.endpoint);\n      const scope = `${hrefEndpoint}/.default`;\n      this.pipeline.addPolicy(\n        bearerTokenAuthenticationPolicy({\n          credential: cosmosClientOptions.aadCredentials,\n          scopes: scope,\n          challengeCallbacks: {\n            async authorizeRequest({ request, getAccessToken }) {\n              const tokenResponse = await getAccessToken([scope], {});\n              const AUTH_PREFIX = `type=aad&ver=1.0&sig=`;\n              const authorizationToken = `${AUTH_PREFIX}${tokenResponse.token}`;\n              request.headers.set(\"Authorization\", authorizationToken);\n            },\n          },\n        }),\n      );\n    }\n    this.initializeDiagnosticSettings(diagnosticLevel);\n  }\n  /** @hidden */\n  public async read<T>({\n    path,\n    resourceType,\n    resourceId,\n    options = {},\n    partitionKey,\n    diagnosticNode,\n  }: {\n    path: string;\n    resourceType: ResourceType;\n    resourceId: string;\n    options?: RequestOptions;\n    partitionKey?: PartitionKey;\n    diagnosticNode: DiagnosticNodeInternal;\n  }): Promise<Response<T & Resource>> {\n    try {\n      const request: RequestContext = {\n        ...this.getContextDerivedPropsForRequestCreation(),\n        method: HTTPMethod.get,\n        path,\n        operationType: OperationType.Read,\n        resourceId,\n        options,\n        resourceType,\n        partitionKey,\n      };\n      diagnosticNode.addData({\n        operationType: OperationType.Read,\n        resourceType,\n      });\n\n      request.headers = await this.buildHeaders(request);\n      this.applySessionToken(request);\n\n      // read will use ReadEndpoint since it uses GET operation\n      request.endpoint = await this.globalEndpointManager.resolveServiceEndpoint(\n        diagnosticNode,\n        request.resourceType,\n        request.operationType,\n      );\n      const response = await executePlugins(\n        diagnosticNode,\n        request,\n        RequestHandler.request,\n        PluginOn.operation,\n      );\n      this.captureSessionToken(undefined, path, OperationType.Read, response.headers);\n      return response;\n    } catch (err: any) {\n      this.captureSessionToken(err, path, OperationType.Upsert, (err as ErrorResponse).headers);\n      throw err;\n    }\n  }\n\n  public async queryFeed<T>({\n    path,\n    resourceType,\n    resourceId,\n    resultFn,\n    query,\n    options,\n    diagnosticNode,\n    partitionKeyRangeId,\n    partitionKey,\n    startEpk,\n    endEpk,\n    correlatedActivityId,\n  }: {\n    path: string;\n    resourceType: ResourceType;\n    resourceId: string;\n    resultFn: (result: { [key: string]: any }) => any[];\n    query: SqlQuerySpec | string;\n    options: FeedOptions;\n    diagnosticNode: DiagnosticNodeInternal;\n    partitionKeyRangeId?: string;\n    partitionKey?: PartitionKey;\n    startEpk?: string | undefined;\n    endEpk?: string | undefined;\n    correlatedActivityId?: string;\n  }): Promise<Response<T & Resource>> {\n    // Query operations will use ReadEndpoint even though it uses\n    // GET(for queryFeed) and POST(for regular query operations)\n\n    const request: RequestContext = {\n      ...this.getContextDerivedPropsForRequestCreation(),\n      method: HTTPMethod.get,\n      path,\n      operationType: OperationType.Query,\n      partitionKeyRangeId,\n      resourceId,\n      resourceType,\n      options,\n      body: query,\n      partitionKey,\n    };\n    diagnosticNode.addData({\n      operationType: OperationType.Query,\n      resourceType,\n    });\n    const requestId = randomUUID();\n    if (query !== undefined) {\n      request.method = HTTPMethod.post;\n    }\n    request.endpoint = await this.globalEndpointManager.resolveServiceEndpoint(\n      diagnosticNode,\n      request.resourceType,\n      request.operationType,\n    );\n    request.headers = await this.buildHeaders(request);\n\n    if (startEpk !== undefined && endEpk !== undefined) {\n      request.headers[HttpHeaders.StartEpk] = startEpk;\n      request.headers[HttpHeaders.EndEpk] = endEpk;\n      request.headers[HttpHeaders.ReadFeedKeyType] = \"EffectivePartitionKeyRange\";\n    }\n\n    if (query !== undefined) {\n      if (correlatedActivityId !== undefined) {\n        request.headers[HttpHeaders.CorrelatedActivityId] = correlatedActivityId;\n      }\n      request.headers[HttpHeaders.IsQuery] = \"true\";\n      request.headers[HttpHeaders.ContentType] = QueryJsonContentType;\n      if (typeof query === \"string\") {\n        request.body = { query }; // Converts query text to query object.\n      }\n    }\n    this.applySessionToken(request);\n    logger.info(\n      \"query \" +\n        requestId +\n        \" started\" +\n        (request.partitionKeyRangeId ? \" pkrid: \" + request.partitionKeyRangeId : \"\"),\n    );\n    logger.verbose(request);\n    const start = Date.now();\n    const response = await RequestHandler.request(request, diagnosticNode);\n    logger.info(\"query \" + requestId + \" finished - \" + (Date.now() - start) + \"ms\");\n    this.captureSessionToken(undefined, path, OperationType.Query, response.headers);\n    return this.processQueryFeedResponse(response, !!query, resultFn);\n  }\n\n  public async getQueryPlan(\n    path: string,\n    resourceType: ResourceType,\n    resourceId: string,\n    query: SqlQuerySpec | string,\n    options: FeedOptions = {},\n    diagnosticNode: DiagnosticNodeInternal,\n    correlatedActivityId?: string,\n  ): Promise<Response<PartitionedQueryExecutionInfo>> {\n    const request: RequestContext = {\n      ...this.getContextDerivedPropsForRequestCreation(),\n      method: HTTPMethod.post,\n      path,\n      operationType: OperationType.Read,\n      resourceId,\n      resourceType,\n      options,\n      body: query,\n    };\n    diagnosticNode.addData({\n      operationType: OperationType.Read,\n      resourceType,\n    });\n    request.endpoint = await this.globalEndpointManager.resolveServiceEndpoint(\n      diagnosticNode,\n      request.resourceType,\n      request.operationType,\n    );\n    request.headers = await this.buildHeaders(request);\n    if (correlatedActivityId !== undefined) {\n      request.headers[HttpHeaders.CorrelatedActivityId] = correlatedActivityId;\n    }\n    request.headers[HttpHeaders.IsQueryPlan] = \"True\";\n    request.headers[HttpHeaders.QueryVersion] = \"1.4\";\n    request.headers[HttpHeaders.ContentType] = QueryJsonContentType;\n    request.headers[HttpHeaders.SupportedQueryFeatures] = supportedQueryFeaturesBuilder(\n      options.disableNonStreamingOrderByQuery,\n    );\n\n    if (typeof query === \"string\") {\n      request.body = { query }; // Converts query text to query object.\n    }\n\n    this.applySessionToken(request);\n    const response = await RequestHandler.request(request, diagnosticNode);\n    this.captureSessionToken(undefined, path, OperationType.Query, response.headers);\n    return response as any;\n  }\n\n  public queryPartitionKeyRanges(\n    collectionLink: string,\n    query?: string | SqlQuerySpec,\n    options?: FeedOptions,\n  ): QueryIterator<PartitionKeyRange> {\n    const path = getPathFromLink(collectionLink, ResourceType.pkranges);\n    const id = getIdFromLink(collectionLink);\n    const cb: FetchFunctionCallback = async (diagNode, innerOptions) => {\n      const response = await this.queryFeed({\n        path,\n        resourceType: ResourceType.pkranges,\n        resourceId: id,\n        resultFn: (result) => result.PartitionKeyRanges,\n        query,\n        options: innerOptions,\n        diagnosticNode: diagNode,\n      });\n      return response;\n    };\n    return new QueryIterator<PartitionKeyRange>(this, query, options, cb);\n  }\n\n  public async delete<T>({\n    path,\n    resourceType,\n    resourceId,\n    options = {},\n    partitionKey,\n    method = HTTPMethod.delete,\n    diagnosticNode,\n  }: {\n    path: string;\n    resourceType: ResourceType;\n    resourceId: string;\n    options?: RequestOptions;\n    partitionKey?: PartitionKey;\n    method?: HTTPMethod;\n    diagnosticNode: DiagnosticNodeInternal;\n  }): Promise<Response<T & Resource>> {\n    try {\n      const request: RequestContext = {\n        ...this.getContextDerivedPropsForRequestCreation(),\n        method: method,\n        operationType: OperationType.Delete,\n        path,\n        resourceType,\n        options,\n        resourceId,\n        partitionKey,\n      };\n      diagnosticNode.addData({\n        operationType: OperationType.Delete,\n        resourceType,\n      });\n      request.headers = await this.buildHeaders(request);\n      this.applySessionToken(request);\n      // deleteResource will use WriteEndpoint since it uses DELETE operation\n      request.endpoint = await this.globalEndpointManager.resolveServiceEndpoint(\n        diagnosticNode,\n        request.resourceType,\n        request.operationType,\n      );\n      const response = await executePlugins(\n        diagnosticNode,\n        request,\n        RequestHandler.request,\n        PluginOn.operation,\n      );\n      if (parseLink(path).type !== \"colls\") {\n        this.captureSessionToken(undefined, path, OperationType.Delete, response.headers);\n      } else {\n        this.clearSessionToken(path);\n      }\n      return response;\n    } catch (err: any) {\n      this.captureSessionToken(err, path, OperationType.Upsert, (err as ErrorResponse).headers);\n      throw err;\n    }\n  }\n\n  public async patch<T>({\n    body,\n    path,\n    resourceType,\n    resourceId,\n    options = {},\n    partitionKey,\n    diagnosticNode,\n  }: {\n    body: any;\n    path: string;\n    resourceType: ResourceType;\n    resourceId: string;\n    options?: RequestOptions;\n    partitionKey?: PartitionKey;\n    diagnosticNode: DiagnosticNodeInternal;\n  }): Promise<Response<T & Resource>> {\n    try {\n      const request: RequestContext = {\n        ...this.getContextDerivedPropsForRequestCreation(),\n        method: HTTPMethod.patch,\n        operationType: OperationType.Patch,\n        path,\n        resourceType,\n        body,\n        resourceId,\n        options,\n        partitionKey,\n      };\n      diagnosticNode.addData({\n        operationType: OperationType.Patch,\n        resourceType,\n      });\n      request.headers = await this.buildHeaders(request);\n      this.applySessionToken(request);\n\n      // patch will use WriteEndpoint\n      request.endpoint = await this.globalEndpointManager.resolveServiceEndpoint(\n        diagnosticNode,\n        request.resourceType,\n        request.operationType,\n      );\n      const response = await executePlugins(\n        diagnosticNode,\n        request,\n        RequestHandler.request,\n        PluginOn.operation,\n      );\n      this.captureSessionToken(undefined, path, OperationType.Patch, response.headers);\n      return response;\n    } catch (err: any) {\n      this.captureSessionToken(err, path, OperationType.Upsert, (err as ErrorResponse).headers);\n      throw err;\n    }\n  }\n\n  public async create<T, U = T>({\n    body,\n    path,\n    resourceType,\n    resourceId,\n    diagnosticNode,\n    options = {},\n    partitionKey,\n  }: {\n    body: T;\n    path: string;\n    resourceType: ResourceType;\n    resourceId: string;\n    diagnosticNode: DiagnosticNodeInternal;\n    options?: RequestOptions;\n    partitionKey?: PartitionKey;\n  }): Promise<Response<T & U & Resource>> {\n    try {\n      const request: RequestContext = {\n        ...this.getContextDerivedPropsForRequestCreation(),\n        method: HTTPMethod.post,\n        operationType: OperationType.Create,\n        path,\n        resourceType,\n        resourceId,\n        body,\n        options,\n        partitionKey,\n      };\n      diagnosticNode.addData({\n        operationType: OperationType.Create,\n        resourceType,\n      });\n      request.headers = await this.buildHeaders(request);\n      // create will use WriteEndpoint since it uses POST operation\n      this.applySessionToken(request);\n\n      request.endpoint = await this.globalEndpointManager.resolveServiceEndpoint(\n        diagnosticNode,\n        request.resourceType,\n        request.operationType,\n      );\n      const response = await executePlugins(\n        diagnosticNode,\n        request,\n        RequestHandler.request,\n        PluginOn.operation,\n      );\n      this.captureSessionToken(undefined, path, OperationType.Create, response.headers);\n      return response;\n    } catch (err: any) {\n      this.captureSessionToken(err, path, OperationType.Upsert, (err as ErrorResponse).headers);\n      throw err;\n    }\n  }\n\n  private processQueryFeedResponse(\n    res: Response<any>,\n    isQuery: boolean,\n    resultFn: (result: { [key: string]: any }) => any[],\n  ): Response<any> {\n    if (isQuery) {\n      return {\n        result: resultFn(res.result),\n        headers: res.headers,\n        code: res.code,\n      };\n    } else {\n      const newResult = resultFn(res.result).map((body: any) => body);\n      return {\n        result: newResult,\n        headers: res.headers,\n        code: res.code,\n      };\n    }\n  }\n\n  private applySessionToken(requestContext: RequestContext): void {\n    const request = this.getSessionParams(requestContext.path);\n\n    if (requestContext.headers && requestContext.headers[HttpHeaders.SessionToken]) {\n      return;\n    }\n\n    const sessionConsistency: ConsistencyLevel = requestContext.headers[\n      HttpHeaders.ConsistencyLevel\n    ] as ConsistencyLevel;\n    if (!sessionConsistency) {\n      return;\n    }\n\n    if (sessionConsistency !== ConsistencyLevel.Session) {\n      return;\n    }\n\n    if (request.resourceAddress) {\n      const sessionToken = this.sessionContainer.get(request);\n      if (sessionToken) {\n        requestContext.headers[HttpHeaders.SessionToken] = sessionToken;\n      }\n    }\n  }\n\n  public async replace<T>({\n    body,\n    path,\n    resourceType,\n    resourceId,\n    options = {},\n    partitionKey,\n    diagnosticNode,\n  }: {\n    body: any;\n    path: string;\n    resourceType: ResourceType;\n    resourceId: string;\n    options?: RequestOptions;\n    partitionKey?: PartitionKey;\n    diagnosticNode: DiagnosticNodeInternal;\n  }): Promise<Response<T & Resource>> {\n    try {\n      const request: RequestContext = {\n        ...this.getContextDerivedPropsForRequestCreation(),\n        method: HTTPMethod.put,\n        operationType: OperationType.Replace,\n        path,\n        resourceType,\n        body,\n        resourceId,\n        options,\n        partitionKey,\n      };\n      diagnosticNode.addData({\n        operationType: OperationType.Replace,\n        resourceType,\n      });\n      request.headers = await this.buildHeaders(request);\n      this.applySessionToken(request);\n\n      // replace will use WriteEndpoint since it uses PUT operation\n      request.endpoint = await this.globalEndpointManager.resolveServiceEndpoint(\n        diagnosticNode,\n        request.resourceType,\n        request.operationType,\n      );\n      const response = await executePlugins(\n        diagnosticNode,\n        request,\n        RequestHandler.request,\n        PluginOn.operation,\n      );\n      this.captureSessionToken(undefined, path, OperationType.Replace, response.headers);\n      return response;\n    } catch (err: any) {\n      this.captureSessionToken(err, path, OperationType.Upsert, (err as ErrorResponse).headers);\n      throw err;\n    }\n  }\n\n  public async upsert<T, U = T>({\n    body,\n    path,\n    resourceType,\n    resourceId,\n    options = {},\n    partitionKey,\n    diagnosticNode,\n  }: {\n    body: T;\n    path: string;\n    resourceType: ResourceType;\n    resourceId: string;\n    options?: RequestOptions;\n    partitionKey?: PartitionKey;\n    diagnosticNode: DiagnosticNodeInternal;\n  }): Promise<Response<T & U & Resource>> {\n    try {\n      const request: RequestContext = {\n        ...this.getContextDerivedPropsForRequestCreation(),\n        method: HTTPMethod.post,\n        operationType: OperationType.Upsert,\n        path,\n        resourceType,\n        body,\n        resourceId,\n        options,\n        partitionKey,\n      };\n      diagnosticNode.addData({\n        operationType: OperationType.Upsert,\n        resourceType,\n      });\n      request.headers = await this.buildHeaders(request);\n      request.headers[HttpHeaders.IsUpsert] = true;\n      this.applySessionToken(request);\n\n      // upsert will use WriteEndpoint since it uses POST operation\n      request.endpoint = await this.globalEndpointManager.resolveServiceEndpoint(\n        diagnosticNode,\n        request.resourceType,\n        request.operationType,\n      );\n      const response = await executePlugins(\n        diagnosticNode,\n        request,\n        RequestHandler.request,\n        PluginOn.operation,\n      );\n      this.captureSessionToken(undefined, path, OperationType.Upsert, response.headers);\n      return response;\n    } catch (err: any) {\n      this.captureSessionToken(err, path, OperationType.Upsert, (err as ErrorResponse).headers);\n      throw err;\n    }\n  }\n\n  public async execute<T>({\n    sprocLink,\n    params,\n    options = {},\n    partitionKey,\n    diagnosticNode,\n  }: {\n    sprocLink: string;\n    params?: any[];\n    options?: RequestOptions;\n    partitionKey?: PartitionKey;\n    diagnosticNode: DiagnosticNodeInternal;\n  }): Promise<Response<T>> {\n    // Accept a single parameter or an array of parameters.\n    // Didn't add type annotation for this because we should legacy this behavior\n    if (params !== null && params !== undefined && !Array.isArray(params)) {\n      params = [params];\n    }\n    const path = getPathFromLink(sprocLink);\n    const id = getIdFromLink(sprocLink);\n\n    const request: RequestContext = {\n      ...this.getContextDerivedPropsForRequestCreation(),\n      method: HTTPMethod.post,\n      operationType: OperationType.Execute,\n      path,\n      resourceType: ResourceType.sproc,\n      options,\n      resourceId: id,\n      body: params,\n      partitionKey,\n    };\n    diagnosticNode.addData({\n      operationType: OperationType.Execute,\n      resourceType: ResourceType.sproc,\n    });\n    request.headers = await this.buildHeaders(request);\n    // executeStoredProcedure will use WriteEndpoint since it uses POST operation\n    request.endpoint = await this.globalEndpointManager.resolveServiceEndpoint(\n      diagnosticNode,\n      request.resourceType,\n      request.operationType,\n    );\n    const response = await executePlugins(\n      diagnosticNode,\n      request,\n      RequestHandler.request,\n      PluginOn.operation,\n    );\n    return response;\n  }\n\n  /**\n   * Gets the Database account information.\n   * @param options - `urlConnection` in the options is the endpoint url whose database account needs to be retrieved.\n   * If not present, current client's url will be used.\n   */\n  public async getDatabaseAccount(\n    diagnosticNode: DiagnosticNodeInternal,\n    options: RequestOptions = {},\n  ): Promise<Response<DatabaseAccount>> {\n    const endpoint = options.urlConnection || this.cosmosClientOptions.endpoint;\n    const request: RequestContext = {\n      ...this.getContextDerivedPropsForRequestCreation(),\n      endpoint,\n      method: HTTPMethod.get,\n      operationType: OperationType.Read,\n      path: \"\",\n      resourceType: ResourceType.none,\n      options,\n    };\n    diagnosticNode.addData({\n      operationType: OperationType.Read,\n      resourceType: ResourceType.none,\n    });\n    request.headers = await this.buildHeaders(request);\n    // await options.beforeOperation({ endpoint, request, headers: requestHeaders });\n    const { result, headers, code, substatus, diagnostics } = await executePlugins(\n      diagnosticNode,\n      request,\n      RequestHandler.request,\n      PluginOn.operation,\n    );\n\n    const databaseAccount = new DatabaseAccount(result, headers);\n    return {\n      result: databaseAccount,\n      headers,\n      diagnostics,\n      code: code,\n      substatus: substatus,\n    };\n  }\n\n  public getWriteEndpoint(diagnosticNode: DiagnosticNodeInternal): Promise<string> {\n    return this.globalEndpointManager.getWriteEndpoint(diagnosticNode);\n  }\n\n  public getReadEndpoint(diagnosticNode: DiagnosticNodeInternal): Promise<string> {\n    return this.globalEndpointManager.getReadEndpoint(diagnosticNode);\n  }\n\n  public getWriteEndpoints(): Promise<readonly string[]> {\n    return this.globalEndpointManager.getWriteEndpoints();\n  }\n\n  public getReadEndpoints(): Promise<readonly string[]> {\n    return this.globalEndpointManager.getReadEndpoints();\n  }\n\n  public async batch<T>({\n    body,\n    path,\n    partitionKey,\n    resourceId,\n    options = {},\n    diagnosticNode,\n  }: {\n    body: T;\n    path: string;\n    partitionKey: PartitionKey;\n    resourceId: string;\n    options?: RequestOptions;\n    diagnosticNode: DiagnosticNodeInternal;\n  }): Promise<Response<any>> {\n    try {\n      const request: RequestContext = {\n        ...this.getContextDerivedPropsForRequestCreation(),\n        method: HTTPMethod.post,\n        operationType: OperationType.Batch,\n        path,\n        body,\n        resourceType: ResourceType.item,\n        resourceId,\n        options,\n        partitionKey,\n      };\n      diagnosticNode.addData({\n        operationType: OperationType.Batch,\n        resourceType: ResourceType.item,\n      });\n      request.headers = await this.buildHeaders(request);\n      request.headers[HttpHeaders.IsBatchRequest] = true;\n      request.headers[HttpHeaders.IsBatchAtomic] = true;\n\n      this.applySessionToken(request);\n\n      request.endpoint = await this.globalEndpointManager.resolveServiceEndpoint(\n        diagnosticNode,\n        request.resourceType,\n        request.operationType,\n      );\n      const response = await executePlugins(\n        diagnosticNode,\n        request,\n        RequestHandler.request,\n        PluginOn.operation,\n      );\n      this.captureSessionToken(undefined, path, OperationType.Batch, response.headers);\n      response.diagnostics = diagnosticNode.toDiagnostic(this.getClientConfig());\n      return response;\n    } catch (err: any) {\n      this.captureSessionToken(err, path, OperationType.Upsert, (err as ErrorResponse).headers);\n      throw err;\n    }\n  }\n\n  public async bulk<T>({\n    body,\n    path,\n    partitionKeyRangeId,\n    resourceId,\n    bulkOptions = {},\n    options = {},\n    diagnosticNode,\n  }: {\n    body: T;\n    path: string;\n    partitionKeyRangeId: string;\n    resourceId: string;\n    bulkOptions?: BulkOptions;\n    options?: RequestOptions;\n    diagnosticNode: DiagnosticNodeInternal;\n  }): Promise<Response<any>> {\n    try {\n      const request: RequestContext = {\n        ...this.getContextDerivedPropsForRequestCreation(),\n        method: HTTPMethod.post,\n        operationType: OperationType.Batch,\n        path,\n        body,\n        resourceType: ResourceType.item,\n        resourceId,\n        options,\n      };\n      diagnosticNode.addData({\n        operationType: OperationType.Batch,\n        resourceType: ResourceType.item,\n      });\n      request.headers = await this.buildHeaders(request);\n      request.headers[HttpHeaders.IsBatchRequest] = true;\n      request.headers[HttpHeaders.PartitionKeyRangeID] = partitionKeyRangeId;\n      request.headers[HttpHeaders.IsBatchAtomic] = false;\n      request.headers[HttpHeaders.BatchContinueOnError] = bulkOptions.continueOnError ?? true;\n      this.applySessionToken(request);\n\n      request.endpoint = await this.globalEndpointManager.resolveServiceEndpoint(\n        diagnosticNode,\n        request.resourceType,\n        request.operationType,\n      );\n      const response = await executePlugins(\n        diagnosticNode,\n        request,\n        RequestHandler.request,\n        PluginOn.operation,\n      );\n      this.captureSessionToken(undefined, path, OperationType.Batch, response.headers);\n      return response;\n    } catch (err: any) {\n      this.captureSessionToken(err, path, OperationType.Upsert, (err as ErrorResponse).headers);\n      throw err;\n    }\n  }\n\n  private captureSessionToken(\n    err: ErrorResponse,\n    path: string,\n    operationType: OperationType,\n    resHeaders: CosmosHeaders,\n  ): void {\n    const request = this.getSessionParams(path);\n    request.operationType = operationType;\n    if (\n      !err ||\n      (!this.isMasterResource(request.resourceType) &&\n        (err.code === StatusCodes.PreconditionFailed ||\n          err.code === StatusCodes.Conflict ||\n          (err.code === StatusCodes.NotFound &&\n            err.substatus !== SubStatusCodes.ReadSessionNotAvailable)))\n    ) {\n      this.sessionContainer.set(request, resHeaders);\n    }\n  }\n\n  public clearSessionToken(path: string): void {\n    const request = this.getSessionParams(path);\n    this.sessionContainer.remove(request);\n  }\n\n  public recordDiagnostics(diagnostic: CosmosDiagnostics): void {\n    const formatted = this.diagnosticFormatter.format(diagnostic);\n    this.diagnosticWriter.write(formatted);\n  }\n\n  public initializeDiagnosticSettings(diagnosticLevel: CosmosDbDiagnosticLevel): void {\n    this.diagnosticFormatter = new DefaultDiagnosticFormatter();\n    switch (diagnosticLevel) {\n      case CosmosDbDiagnosticLevel.info:\n        this.diagnosticWriter = new NoOpDiagnosticWriter();\n        break;\n      default:\n        this.diagnosticWriter = new LogDiagnosticWriter();\n    }\n  }\n\n  // TODO: move\n  private getSessionParams(resourceLink: string): SessionContext {\n    const resourceId: string = null;\n    let resourceAddress: string = null;\n    const parserOutput = parseLink(resourceLink);\n\n    resourceAddress = parserOutput.objectBody.self;\n\n    const resourceType = parserOutput.type;\n    return {\n      resourceId,\n      resourceAddress,\n      resourceType,\n      isNameBased: true,\n    };\n  }\n\n  private isMasterResource(resourceType: string): boolean {\n    if (\n      resourceType === Constants.Path.OffersPathSegment ||\n      resourceType === Constants.Path.DatabasesPathSegment ||\n      resourceType === Constants.Path.UsersPathSegment ||\n      resourceType === Constants.Path.PermissionsPathSegment ||\n      resourceType === Constants.Path.TopologyPathSegment ||\n      resourceType === Constants.Path.DatabaseAccountPathSegment ||\n      resourceType === Constants.Path.PartitionKeyRangesPathSegment ||\n      resourceType === Constants.Path.CollectionsPathSegment\n    ) {\n      return true;\n    }\n\n    return false;\n  }\n\n  private buildHeaders(requestContext: RequestContext): Promise<CosmosHeaders> {\n    return getHeaders({\n      clientOptions: this.cosmosClientOptions,\n      defaultHeaders: {\n        ...this.cosmosClientOptions.defaultHeaders,\n        ...requestContext.options.initialHeaders,\n      },\n      verb: requestContext.method,\n      path: requestContext.path,\n      resourceId: requestContext.resourceId,\n      resourceType: requestContext.resourceType,\n      options: requestContext.options,\n      partitionKeyRangeId: requestContext.partitionKeyRangeId,\n      useMultipleWriteLocations: this.connectionPolicy.useMultipleWriteLocations,\n      partitionKey:\n        requestContext.partitionKey !== undefined\n          ? convertToInternalPartitionKey(requestContext.partitionKey)\n          : undefined, // TODO: Move this check from here to PartitionKey\n    });\n  }\n\n  /**\n   * Returns collection of properties which are derived from the context for Request Creation.\n   * These properties have client wide scope, as opposed to request specific scope.\n   * @returns\n   */\n  private getContextDerivedPropsForRequestCreation(): {\n    globalEndpointManager: GlobalEndpointManager;\n    connectionPolicy: ConnectionPolicy;\n    requestAgent: Agent;\n    client?: ClientContext;\n    pipeline?: Pipeline;\n    plugins: PluginConfig[];\n    httpClient?: HttpClient;\n  } {\n    return {\n      globalEndpointManager: this.globalEndpointManager,\n      requestAgent: this.cosmosClientOptions.agent,\n      connectionPolicy: this.connectionPolicy,\n      client: this,\n      plugins: this.cosmosClientOptions.plugins,\n      pipeline: this.pipeline,\n      httpClient: this.cosmosClientOptions.httpClient,\n    };\n  }\n\n  public getClientConfig(): ClientConfigDiagnostic {\n    return this.clientConfig;\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}