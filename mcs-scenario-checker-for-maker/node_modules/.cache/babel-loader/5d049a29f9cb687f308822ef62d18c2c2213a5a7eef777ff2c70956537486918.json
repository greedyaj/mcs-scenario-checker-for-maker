{"ast":null,"code":"import { ErrorResponse } from \"../../request\";\nimport { isPrimitivePartitionKeyValue } from \"../../utils/typeChecks\";\nimport { ChangeFeedStartFromBeginning } from \"./ChangeFeedStartFromBeginning\";\nimport { Constants } from \"../../common\";\nimport { ChangeFeedStartFromTime } from \"./ChangeFeedStartFromTime\";\nimport { FeedRangeInternal } from \"./FeedRange\";\n/**\n * @hidden\n * Validates the change feed options passed by the user\n */\nexport function validateChangeFeedIteratorOptions(options) {\n  if (!isChangeFeedIteratorOptions(options)) {\n    throw new ErrorResponse(\"Invalid Changefeed Iterator Options.\");\n  }\n  if ((options === null || options === void 0 ? void 0 : options.maxItemCount) && typeof (options === null || options === void 0 ? void 0 : options.maxItemCount) !== \"number\") {\n    throw new ErrorResponse(\"maxItemCount must be number\");\n  }\n  if ((options === null || options === void 0 ? void 0 : options.maxItemCount) !== undefined && (options === null || options === void 0 ? void 0 : options.maxItemCount) < 1) {\n    throw new ErrorResponse(\"maxItemCount must be a positive number\");\n  }\n}\nfunction isChangeFeedIteratorOptions(options) {\n  if (typeof options !== \"object\") {\n    return false;\n  }\n  if (Object.keys(options).length === 0 && JSON.stringify(options) === \"{}\") {\n    return true;\n  }\n  return options && !(isPrimitivePartitionKeyValue(options) || Array.isArray(options));\n}\n/**\n * @hidden\n * Checks if pkRange entirely covers the given overLapping range or there is only partial overlap.\n *\n * If no complete overlap, exact range which overlaps is retured which is used to set minEpk and maxEpk headers while quering change feed.\n */\nexport async function extractOverlappingRanges(epkRange, overLappingRange) {\n  if (overLappingRange.minInclusive >= epkRange.min && overLappingRange.maxExclusive <= epkRange.max) {\n    return [undefined, undefined];\n  } else if (overLappingRange.minInclusive <= epkRange.min && overLappingRange.maxExclusive >= epkRange.max) {\n    return [epkRange.min, epkRange.max];\n  }\n  // Right Side of overlapping range is covered\n  else if (overLappingRange.minInclusive <= epkRange.min && overLappingRange.maxExclusive <= epkRange.max && overLappingRange.maxExclusive >= epkRange.min) {\n    return [epkRange.min, overLappingRange.maxExclusive];\n  }\n  // Left Side of overlapping range is covered\n  else {\n    return [overLappingRange.minInclusive, epkRange.max];\n  }\n}\n/**\n * @hidden\n * Checks if the object is a valid EpkRange\n */\nexport function isEpkRange(obj) {\n  return obj instanceof FeedRangeInternal && typeof obj.minInclusive === \"string\" && typeof obj.maxExclusive === \"string\" && obj.minInclusive >= Constants.EffectivePartitionKeyConstants.MinimumInclusiveEffectivePartitionKey && obj.maxExclusive <= Constants.EffectivePartitionKeyConstants.MaximumExclusiveEffectivePartitionKey && obj.maxExclusive > obj.minInclusive;\n}\n/**\n * @hidden\n */\nexport function buildInternalChangeFeedOptions(options, continuationToken, startTime, startFromNow) {\n  const internalCfOptions = {};\n  internalCfOptions.maxItemCount = options === null || options === void 0 ? void 0 : options.maxItemCount;\n  internalCfOptions.sessionToken = options === null || options === void 0 ? void 0 : options.sessionToken;\n  internalCfOptions.continuationToken = continuationToken;\n  internalCfOptions.changeFeedMode = options === null || options === void 0 ? void 0 : options.changeFeedMode;\n  // Default option of changefeed is to start from now.\n  if (startFromNow) {\n    internalCfOptions.startFromNow = true;\n  } else {\n    internalCfOptions.startTime = startTime;\n  }\n  return internalCfOptions;\n}\n/**\n * @hidden\n */\nexport function fetchStartTime(changeFeedStartFrom) {\n  if (changeFeedStartFrom instanceof ChangeFeedStartFromBeginning) {\n    return undefined;\n  } else if (changeFeedStartFrom instanceof ChangeFeedStartFromTime) {\n    return changeFeedStartFrom.getStartTime();\n  }\n}\n/**\n * @hidden\n */\nexport function isNullOrEmpty(text) {\n  return text === null || text === undefined || text.trim() === \"\";\n}","map":{"version":3,"names":["ErrorResponse","isPrimitivePartitionKeyValue","ChangeFeedStartFromBeginning","Constants","ChangeFeedStartFromTime","FeedRangeInternal","validateChangeFeedIteratorOptions","options","isChangeFeedIteratorOptions","maxItemCount","undefined","Object","keys","length","JSON","stringify","Array","isArray","extractOverlappingRanges","epkRange","overLappingRange","minInclusive","min","maxExclusive","max","isEpkRange","obj","EffectivePartitionKeyConstants","MinimumInclusiveEffectivePartitionKey","MaximumExclusiveEffectivePartitionKey","buildInternalChangeFeedOptions","continuationToken","startTime","startFromNow","internalCfOptions","sessionToken","changeFeedMode","fetchStartTime","changeFeedStartFrom","getStartTime","isNullOrEmpty","text","trim"],"sources":["/Users/ajitpawar/microsoft/bap/POCs/Scenario_checker_for_maker/mcs-scenario-checker-for-maker/node_modules/@azure/cosmos/src/client/ChangeFeed/changeFeedUtils.ts"],"sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport type { ChangeFeedIteratorOptions } from \"./ChangeFeedIteratorOptions\";\nimport { ErrorResponse } from \"../../request\";\nimport type { PartitionKeyRange } from \"../Container\";\nimport type { InternalChangeFeedIteratorOptions } from \"./InternalChangeFeedOptions\";\nimport { isPrimitivePartitionKeyValue } from \"../../utils/typeChecks\";\nimport type { ChangeFeedStartFrom } from \"./ChangeFeedStartFrom\";\nimport { ChangeFeedStartFromBeginning } from \"./ChangeFeedStartFromBeginning\";\nimport { Constants } from \"../../common\";\nimport { ChangeFeedStartFromTime } from \"./ChangeFeedStartFromTime\";\nimport type { QueryRange } from \"../../routing\";\nimport { FeedRangeInternal } from \"./FeedRange\";\n\n/**\n * @hidden\n * Validates the change feed options passed by the user\n */\nexport function validateChangeFeedIteratorOptions(options: ChangeFeedIteratorOptions): void {\n  if (!isChangeFeedIteratorOptions(options)) {\n    throw new ErrorResponse(\"Invalid Changefeed Iterator Options.\");\n  }\n  if (options?.maxItemCount && typeof options?.maxItemCount !== \"number\") {\n    throw new ErrorResponse(\"maxItemCount must be number\");\n  }\n  if (options?.maxItemCount !== undefined && options?.maxItemCount < 1) {\n    throw new ErrorResponse(\"maxItemCount must be a positive number\");\n  }\n}\n\nfunction isChangeFeedIteratorOptions(options: unknown): options is ChangeFeedIteratorOptions {\n  if (typeof options !== \"object\") {\n    return false;\n  }\n  if (Object.keys(options).length === 0 && JSON.stringify(options) === \"{}\") {\n    return true;\n  }\n  return options && !(isPrimitivePartitionKeyValue(options) || Array.isArray(options));\n}\n\n/**\n * @hidden\n * Checks if pkRange entirely covers the given overLapping range or there is only partial overlap.\n *\n * If no complete overlap, exact range which overlaps is retured which is used to set minEpk and maxEpk headers while quering change feed.\n */\nexport async function extractOverlappingRanges(\n  epkRange: QueryRange,\n  overLappingRange: PartitionKeyRange,\n): Promise<[string, string]> {\n  if (\n    overLappingRange.minInclusive >= epkRange.min &&\n    overLappingRange.maxExclusive <= epkRange.max\n  ) {\n    return [undefined, undefined];\n  } else if (\n    overLappingRange.minInclusive <= epkRange.min &&\n    overLappingRange.maxExclusive >= epkRange.max\n  ) {\n    return [epkRange.min, epkRange.max];\n  }\n  // Right Side of overlapping range is covered\n  else if (\n    overLappingRange.minInclusive <= epkRange.min &&\n    overLappingRange.maxExclusive <= epkRange.max &&\n    overLappingRange.maxExclusive >= epkRange.min\n  ) {\n    return [epkRange.min, overLappingRange.maxExclusive];\n  }\n  // Left Side of overlapping range is covered\n  else {\n    return [overLappingRange.minInclusive, epkRange.max];\n  }\n}\n\n/**\n * @hidden\n * Checks if the object is a valid EpkRange\n */\nexport function isEpkRange(obj: unknown): boolean {\n  return (\n    obj instanceof FeedRangeInternal &&\n    typeof obj.minInclusive === \"string\" &&\n    typeof obj.maxExclusive === \"string\" &&\n    obj.minInclusive >=\n      Constants.EffectivePartitionKeyConstants.MinimumInclusiveEffectivePartitionKey &&\n    obj.maxExclusive <=\n      Constants.EffectivePartitionKeyConstants.MaximumExclusiveEffectivePartitionKey &&\n    obj.maxExclusive > obj.minInclusive\n  );\n}\n\n/**\n * @hidden\n */\nexport function buildInternalChangeFeedOptions(\n  options: ChangeFeedIteratorOptions,\n  continuationToken?: string,\n  startTime?: Date,\n  startFromNow?: boolean,\n): InternalChangeFeedIteratorOptions {\n  const internalCfOptions = {} as InternalChangeFeedIteratorOptions;\n  internalCfOptions.maxItemCount = options?.maxItemCount;\n  internalCfOptions.sessionToken = options?.sessionToken;\n  internalCfOptions.continuationToken = continuationToken;\n  internalCfOptions.changeFeedMode = options?.changeFeedMode;\n  // Default option of changefeed is to start from now.\n  if (startFromNow) {\n    internalCfOptions.startFromNow = true;\n  } else {\n    internalCfOptions.startTime = startTime;\n  }\n  return internalCfOptions;\n}\n/**\n * @hidden\n */\nexport function fetchStartTime(changeFeedStartFrom: ChangeFeedStartFrom): Date | undefined {\n  if (changeFeedStartFrom instanceof ChangeFeedStartFromBeginning) {\n    return undefined;\n  } else if (changeFeedStartFrom instanceof ChangeFeedStartFromTime) {\n    return changeFeedStartFrom.getStartTime();\n  }\n}\n\n/**\n * @hidden\n */\nexport function isNullOrEmpty(text: string | null | undefined): boolean {\n  return text === null || text === undefined || text.trim() === \"\";\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}