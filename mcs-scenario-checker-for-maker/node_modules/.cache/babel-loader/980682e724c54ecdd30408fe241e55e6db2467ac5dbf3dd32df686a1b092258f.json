{"ast":null,"code":"// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport { OperationType, ResourceType, isReadRequest } from \"./common\";\nimport { Constants } from \"./common/constants\";\nimport { MetadataLookUpType } from \"./CosmosDiagnostics\";\nimport { withMetadataDiagnostics } from \"./utils/diagnostics\";\n/**\n * @hidden\n * This internal class implements the logic for endpoint management for geo-replicated database accounts.\n */\nexport class GlobalEndpointManager {\n  /**\n   * @param options - The document client instance.\n   * @internal\n   */\n  constructor(options, readDatabaseAccount) {\n    this.readDatabaseAccount = readDatabaseAccount;\n    this.writeableLocations = [];\n    this.readableLocations = [];\n    this.unavailableReadableLocations = [];\n    this.unavailableWriteableLocations = [];\n    this.options = options;\n    this.defaultEndpoint = options.endpoint;\n    this.enableEndpointDiscovery = options.connectionPolicy.enableEndpointDiscovery;\n    this.isRefreshing = false;\n    this.preferredLocations = this.options.connectionPolicy.preferredLocations;\n    this.preferredLocationsCount = this.preferredLocations ? this.preferredLocations.length : 0;\n  }\n  /**\n   * Gets the current read endpoint from the endpoint cache.\n   */\n  async getReadEndpoint(diagnosticNode) {\n    return this.resolveServiceEndpoint(diagnosticNode, ResourceType.item, OperationType.Read);\n  }\n  /**\n   * Gets the current write endpoint from the endpoint cache.\n   */\n  async getWriteEndpoint(diagnosticNode) {\n    return this.resolveServiceEndpoint(diagnosticNode, ResourceType.item, OperationType.Replace);\n  }\n  async getReadEndpoints() {\n    return this.readableLocations.map(loc => loc.databaseAccountEndpoint);\n  }\n  async getWriteEndpoints() {\n    return this.writeableLocations.map(loc => loc.databaseAccountEndpoint);\n  }\n  async markCurrentLocationUnavailableForRead(diagnosticNode, endpoint) {\n    await this.refreshEndpointList(diagnosticNode);\n    const location = this.readableLocations.find(loc => loc.databaseAccountEndpoint === endpoint);\n    if (location) {\n      location.unavailable = true;\n      location.lastUnavailabilityTimestampInMs = Date.now();\n      this.unavailableReadableLocations.push(location);\n    }\n  }\n  async markCurrentLocationUnavailableForWrite(diagnosticNode, endpoint) {\n    await this.refreshEndpointList(diagnosticNode);\n    const location = this.writeableLocations.find(loc => loc.databaseAccountEndpoint === endpoint);\n    if (location) {\n      location.unavailable = true;\n      location.lastUnavailabilityTimestampInMs = Date.now();\n      this.unavailableWriteableLocations.push(location);\n    }\n  }\n  canUseMultipleWriteLocations(resourceType, operationType) {\n    let canUse = this.options.connectionPolicy.useMultipleWriteLocations;\n    if (resourceType) {\n      canUse = canUse && (resourceType === ResourceType.item || resourceType === ResourceType.sproc && operationType === OperationType.Execute);\n    }\n    return canUse;\n  }\n  async resolveServiceEndpoint(diagnosticNode, resourceType, operationType, startServiceEndpointIndex = 0) {\n    // If endpoint discovery is disabled, always use the user provided endpoint\n    if (!this.options.connectionPolicy.enableEndpointDiscovery) {\n      diagnosticNode.addData({\n        readFromCache: true\n      }, \"default_endpoint\");\n      diagnosticNode.recordEndpointResolution(this.defaultEndpoint);\n      return this.defaultEndpoint;\n    }\n    // If getting the database account, always use the user provided endpoint\n    if (resourceType === ResourceType.none) {\n      diagnosticNode.addData({\n        readFromCache: true\n      }, \"none_resource\");\n      diagnosticNode.recordEndpointResolution(this.defaultEndpoint);\n      return this.defaultEndpoint;\n    }\n    if (this.readableLocations.length === 0 || this.writeableLocations.length === 0) {\n      const resourceResponse = await withMetadataDiagnostics(async metadataNode => {\n        return this.readDatabaseAccount(metadataNode, {\n          urlConnection: this.defaultEndpoint\n        });\n      }, diagnosticNode, MetadataLookUpType.DatabaseAccountLookUp);\n      this.writeableLocations = resourceResponse.resource.writableLocations;\n      this.readableLocations = resourceResponse.resource.readableLocations;\n    }\n    const locations = isReadRequest(operationType) ? this.readableLocations : this.writeableLocations;\n    let location;\n    // If we have preferred locations, try each one in order and use the first available one\n    if (this.preferredLocations && this.preferredLocations.length > 0 && startServiceEndpointIndex < this.preferredLocations.length) {\n      for (let i = startServiceEndpointIndex; i < this.preferredLocations.length; i++) {\n        const preferredLocation = this.preferredLocations[i];\n        location = locations.find(loc => loc.unavailable !== true && normalizeEndpoint(loc.name) === normalizeEndpoint(preferredLocation));\n        if (location) {\n          break;\n        }\n      }\n    }\n    // If no preferred locations or one did not match, just grab the first one that is available\n    if (!location) {\n      const startIndexValid = startServiceEndpointIndex >= 0 && startServiceEndpointIndex < locations.length;\n      const locationsToSearch = startIndexValid ? locations.slice(startServiceEndpointIndex) : locations;\n      location = locationsToSearch.find(loc => {\n        return loc.unavailable !== true;\n      });\n    }\n    location = location ? location : {\n      name: \"\",\n      databaseAccountEndpoint: this.defaultEndpoint\n    };\n    diagnosticNode.recordEndpointResolution(location.databaseAccountEndpoint);\n    return location.databaseAccountEndpoint;\n  }\n  /**\n   * Refreshes the endpoint list by clearning stale unavailability and then\n   *  retrieving the writable and readable locations from the geo-replicated database account\n   *  and then updating the locations cache.\n   *  We skip the refreshing if enableEndpointDiscovery is set to False\n   */\n  async refreshEndpointList(diagnosticNode) {\n    if (!this.isRefreshing && this.enableEndpointDiscovery) {\n      this.isRefreshing = true;\n      const databaseAccount = await this.getDatabaseAccountFromAnyEndpoint(diagnosticNode);\n      if (databaseAccount) {\n        this.refreshStaleUnavailableLocations();\n        this.refreshEndpoints(databaseAccount);\n      }\n      this.isRefreshing = false;\n    }\n  }\n  refreshEndpoints(databaseAccount) {\n    for (const location of databaseAccount.writableLocations) {\n      const existingLocation = this.writeableLocations.find(loc => loc.name === location.name);\n      if (!existingLocation) {\n        this.writeableLocations.push(location);\n      }\n    }\n    for (const location of databaseAccount.readableLocations) {\n      const existingLocation = this.readableLocations.find(loc => loc.name === location.name);\n      if (!existingLocation) {\n        this.readableLocations.push(location);\n      }\n    }\n  }\n  refreshStaleUnavailableLocations() {\n    const now = Date.now();\n    this.updateLocation(now, this.unavailableReadableLocations, this.readableLocations);\n    this.unavailableReadableLocations = this.cleanUnavailableLocationList(now, this.unavailableReadableLocations);\n    this.updateLocation(now, this.unavailableWriteableLocations, this.writeableLocations);\n    this.unavailableWriteableLocations = this.cleanUnavailableLocationList(now, this.unavailableWriteableLocations);\n  }\n  /**\n   * update the locationUnavailability to undefined if the location is available again\n   * @param now - current time\n   * @param unavailableLocations - list of unavailable locations\n   * @param allLocations - list of all locations\n   */\n  updateLocation(now, unavailableLocations, allLocations) {\n    for (const location of unavailableLocations) {\n      const unavaialableLocation = allLocations.find(loc => loc.name === location.name);\n      if (unavaialableLocation && now - unavaialableLocation.lastUnavailabilityTimestampInMs > Constants.LocationUnavailableExpirationTimeInMs) {\n        unavaialableLocation.unavailable = false;\n      }\n    }\n  }\n  cleanUnavailableLocationList(now, unavailableLocations) {\n    return unavailableLocations.filter(loc => {\n      if (loc && now - loc.lastUnavailabilityTimestampInMs >= Constants.LocationUnavailableExpirationTimeInMs) {\n        return false;\n      }\n      return true;\n    });\n  }\n  /**\n   * Gets the database account first by using the default endpoint, and if that doesn't returns\n   * use the endpoints for the preferred locations in the order they are specified to get\n   * the database account.\n   */\n  async getDatabaseAccountFromAnyEndpoint(diagnosticNode) {\n    try {\n      const options = {\n        urlConnection: this.defaultEndpoint\n      };\n      const {\n        resource: databaseAccount\n      } = await this.readDatabaseAccount(diagnosticNode, options);\n      return databaseAccount;\n      // If for any reason(non - globaldb related), we are not able to get the database\n      // account from the above call to readDatabaseAccount,\n      // we would try to get this information from any of the preferred locations that the user\n      // might have specified (by creating a locational endpoint)\n      // and keeping eating the exception until we get the database account and return None at the end,\n      // if we are not able to get that info from any endpoints\n    } catch (err) {\n      // TODO: Tracing\n    }\n    if (this.preferredLocations) {\n      for (const location of this.preferredLocations) {\n        try {\n          const locationalEndpoint = GlobalEndpointManager.getLocationalEndpoint(this.defaultEndpoint, location);\n          const options = {\n            urlConnection: locationalEndpoint\n          };\n          const {\n            resource: databaseAccount\n          } = await this.readDatabaseAccount(diagnosticNode, options);\n          if (databaseAccount) {\n            return databaseAccount;\n          }\n        } catch (err) {\n          // TODO: Tracing\n        }\n      }\n    }\n  }\n  /**\n   * Gets the locational endpoint using the location name passed to it using the default endpoint.\n   *\n   * @param defaultEndpoint - The default endpoint to use for the endpoint.\n   * @param locationName    - The location name for the azure region like \"East US\".\n   */\n  static getLocationalEndpoint(defaultEndpoint, locationName) {\n    // For defaultEndpoint like 'https://contoso.documents.azure.com:443/' parse it to generate URL format\n    // This defaultEndpoint should be global endpoint(and cannot be a locational endpoint)\n    // and we agreed to document that\n    const endpointUrl = new URL(defaultEndpoint);\n    // hostname attribute in endpointUrl will return 'contoso.documents.azure.com'\n    if (endpointUrl.hostname) {\n      const hostnameParts = endpointUrl.hostname.toString().toLowerCase().split(\".\");\n      if (hostnameParts) {\n        // globalDatabaseAccountName will return 'contoso'\n        const globalDatabaseAccountName = hostnameParts[0];\n        // Prepare the locationalDatabaseAccountName as contoso-EastUS for location_name 'East US'\n        const locationalDatabaseAccountName = globalDatabaseAccountName + \"-\" + locationName.replace(\" \", \"\");\n        // Replace 'contoso' with 'contoso-EastUS' and\n        // return locationalEndpoint as https://contoso-EastUS.documents.azure.com:443/\n        const locationalEndpoint = defaultEndpoint.toLowerCase().replace(globalDatabaseAccountName, locationalDatabaseAccountName);\n        return locationalEndpoint;\n      }\n    }\n    return null;\n  }\n}\nfunction normalizeEndpoint(endpoint) {\n  return endpoint.split(\" \").join(\"\").toLowerCase();\n}","map":{"version":3,"names":["OperationType","ResourceType","isReadRequest","Constants","MetadataLookUpType","withMetadataDiagnostics","GlobalEndpointManager","constructor","options","readDatabaseAccount","writeableLocations","readableLocations","unavailableReadableLocations","unavailableWriteableLocations","defaultEndpoint","endpoint","enableEndpointDiscovery","connectionPolicy","isRefreshing","preferredLocations","preferredLocationsCount","length","getReadEndpoint","diagnosticNode","resolveServiceEndpoint","item","Read","getWriteEndpoint","Replace","getReadEndpoints","map","loc","databaseAccountEndpoint","getWriteEndpoints","markCurrentLocationUnavailableForRead","refreshEndpointList","location","find","unavailable","lastUnavailabilityTimestampInMs","Date","now","push","markCurrentLocationUnavailableForWrite","canUseMultipleWriteLocations","resourceType","operationType","canUse","useMultipleWriteLocations","sproc","Execute","startServiceEndpointIndex","addData","readFromCache","recordEndpointResolution","none","resourceResponse","metadataNode","urlConnection","DatabaseAccountLookUp","resource","writableLocations","locations","i","preferredLocation","normalizeEndpoint","name","startIndexValid","locationsToSearch","slice","databaseAccount","getDatabaseAccountFromAnyEndpoint","refreshStaleUnavailableLocations","refreshEndpoints","existingLocation","updateLocation","cleanUnavailableLocationList","unavailableLocations","allLocations","unavaialableLocation","LocationUnavailableExpirationTimeInMs","filter","err","locationalEndpoint","getLocationalEndpoint","locationName","endpointUrl","URL","hostname","hostnameParts","toString","toLowerCase","split","globalDatabaseAccountName","locationalDatabaseAccountName","replace","join"],"sources":["/Users/ajitpawar/microsoft/bap/POCs/Scenario_checker_for_maker/mcs-scenario-checker-for-maker/node_modules/@azure/cosmos/src/globalEndpointManager.ts"],"sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport { OperationType, ResourceType, isReadRequest } from \"./common\";\nimport type { CosmosClientOptions } from \"./CosmosClientOptions\";\nimport type { Location, DatabaseAccount } from \"./documents\";\nimport type { RequestOptions } from \"./index\";\nimport { Constants } from \"./common/constants\";\nimport type { ResourceResponse } from \"./request\";\nimport { MetadataLookUpType } from \"./CosmosDiagnostics\";\nimport type { DiagnosticNodeInternal } from \"./diagnostics/DiagnosticNodeInternal\";\nimport { withMetadataDiagnostics } from \"./utils/diagnostics\";\n\n/**\n * @hidden\n * This internal class implements the logic for endpoint management for geo-replicated database accounts.\n */\nexport class GlobalEndpointManager {\n  /**\n   * The endpoint used to create the client instance.\n   */\n  private defaultEndpoint: string;\n  /**\n   * Flag to enable/disable automatic redirecting of requests based on read/write operations.\n   */\n  public enableEndpointDiscovery: boolean;\n  private isRefreshing: boolean;\n  private options: CosmosClientOptions;\n  /**\n   * List of azure regions to be used as preferred locations for read requests.\n   */\n  private preferredLocations: string[];\n  private writeableLocations: Location[] = [];\n  private readableLocations: Location[] = [];\n  private unavailableReadableLocations: Location[] = [];\n  private unavailableWriteableLocations: Location[] = [];\n\n  public preferredLocationsCount: number;\n  /**\n   * @param options - The document client instance.\n   * @internal\n   */\n  constructor(\n    options: CosmosClientOptions,\n    private readDatabaseAccount: (\n      diagnosticNode: DiagnosticNodeInternal,\n      opts: RequestOptions,\n    ) => Promise<ResourceResponse<DatabaseAccount>>,\n  ) {\n    this.options = options;\n    this.defaultEndpoint = options.endpoint;\n    this.enableEndpointDiscovery = options.connectionPolicy.enableEndpointDiscovery;\n    this.isRefreshing = false;\n    this.preferredLocations = this.options.connectionPolicy.preferredLocations;\n    this.preferredLocationsCount = this.preferredLocations ? this.preferredLocations.length : 0;\n  }\n\n  /**\n   * Gets the current read endpoint from the endpoint cache.\n   */\n  public async getReadEndpoint(diagnosticNode: DiagnosticNodeInternal): Promise<string> {\n    return this.resolveServiceEndpoint(diagnosticNode, ResourceType.item, OperationType.Read);\n  }\n\n  /**\n   * Gets the current write endpoint from the endpoint cache.\n   */\n  public async getWriteEndpoint(diagnosticNode: DiagnosticNodeInternal): Promise<string> {\n    return this.resolveServiceEndpoint(diagnosticNode, ResourceType.item, OperationType.Replace);\n  }\n\n  public async getReadEndpoints(): Promise<ReadonlyArray<string>> {\n    return this.readableLocations.map((loc) => loc.databaseAccountEndpoint);\n  }\n\n  public async getWriteEndpoints(): Promise<ReadonlyArray<string>> {\n    return this.writeableLocations.map((loc) => loc.databaseAccountEndpoint);\n  }\n\n  public async markCurrentLocationUnavailableForRead(\n    diagnosticNode: DiagnosticNodeInternal,\n    endpoint: string,\n  ): Promise<void> {\n    await this.refreshEndpointList(diagnosticNode);\n    const location = this.readableLocations.find((loc) => loc.databaseAccountEndpoint === endpoint);\n    if (location) {\n      location.unavailable = true;\n      location.lastUnavailabilityTimestampInMs = Date.now();\n      this.unavailableReadableLocations.push(location);\n    }\n  }\n\n  public async markCurrentLocationUnavailableForWrite(\n    diagnosticNode: DiagnosticNodeInternal,\n    endpoint: string,\n  ): Promise<void> {\n    await this.refreshEndpointList(diagnosticNode);\n    const location = this.writeableLocations.find(\n      (loc) => loc.databaseAccountEndpoint === endpoint,\n    );\n    if (location) {\n      location.unavailable = true;\n      location.lastUnavailabilityTimestampInMs = Date.now();\n      this.unavailableWriteableLocations.push(location);\n    }\n  }\n\n  public canUseMultipleWriteLocations(\n    resourceType?: ResourceType,\n    operationType?: OperationType,\n  ): boolean {\n    let canUse = this.options.connectionPolicy.useMultipleWriteLocations;\n\n    if (resourceType) {\n      canUse =\n        canUse &&\n        (resourceType === ResourceType.item ||\n          (resourceType === ResourceType.sproc && operationType === OperationType.Execute));\n    }\n\n    return canUse;\n  }\n\n  public async resolveServiceEndpoint(\n    diagnosticNode: DiagnosticNodeInternal,\n    resourceType: ResourceType,\n    operationType: OperationType,\n    startServiceEndpointIndex: number = 0, // Represents the starting index for selecting servers.\n  ): Promise<string> {\n    // If endpoint discovery is disabled, always use the user provided endpoint\n\n    if (!this.options.connectionPolicy.enableEndpointDiscovery) {\n      diagnosticNode.addData({ readFromCache: true }, \"default_endpoint\");\n      diagnosticNode.recordEndpointResolution(this.defaultEndpoint);\n      return this.defaultEndpoint;\n    }\n\n    // If getting the database account, always use the user provided endpoint\n    if (resourceType === ResourceType.none) {\n      diagnosticNode.addData({ readFromCache: true }, \"none_resource\");\n      diagnosticNode.recordEndpointResolution(this.defaultEndpoint);\n      return this.defaultEndpoint;\n    }\n\n    if (this.readableLocations.length === 0 || this.writeableLocations.length === 0) {\n      const resourceResponse = await withMetadataDiagnostics(\n        async (metadataNode: DiagnosticNodeInternal) => {\n          return this.readDatabaseAccount(metadataNode, {\n            urlConnection: this.defaultEndpoint,\n          });\n        },\n        diagnosticNode,\n        MetadataLookUpType.DatabaseAccountLookUp,\n      );\n\n      this.writeableLocations = resourceResponse.resource.writableLocations;\n      this.readableLocations = resourceResponse.resource.readableLocations;\n    }\n\n    const locations = isReadRequest(operationType)\n      ? this.readableLocations\n      : this.writeableLocations;\n\n    let location;\n    // If we have preferred locations, try each one in order and use the first available one\n    if (\n      this.preferredLocations &&\n      this.preferredLocations.length > 0 &&\n      startServiceEndpointIndex < this.preferredLocations.length\n    ) {\n      for (let i = startServiceEndpointIndex; i < this.preferredLocations.length; i++) {\n        const preferredLocation = this.preferredLocations[i];\n        location = locations.find(\n          (loc) =>\n            loc.unavailable !== true &&\n            normalizeEndpoint(loc.name) === normalizeEndpoint(preferredLocation),\n        );\n        if (location) {\n          break;\n        }\n      }\n    }\n\n    // If no preferred locations or one did not match, just grab the first one that is available\n    if (!location) {\n      const startIndexValid =\n        startServiceEndpointIndex >= 0 && startServiceEndpointIndex < locations.length;\n      const locationsToSearch = startIndexValid\n        ? locations.slice(startServiceEndpointIndex)\n        : locations;\n      location = locationsToSearch.find((loc) => {\n        return loc.unavailable !== true;\n      });\n    }\n\n    location = location ? location : { name: \"\", databaseAccountEndpoint: this.defaultEndpoint };\n    diagnosticNode.recordEndpointResolution(location.databaseAccountEndpoint);\n    return location.databaseAccountEndpoint;\n  }\n\n  /**\n   * Refreshes the endpoint list by clearning stale unavailability and then\n   *  retrieving the writable and readable locations from the geo-replicated database account\n   *  and then updating the locations cache.\n   *  We skip the refreshing if enableEndpointDiscovery is set to False\n   */\n  public async refreshEndpointList(diagnosticNode: DiagnosticNodeInternal): Promise<void> {\n    if (!this.isRefreshing && this.enableEndpointDiscovery) {\n      this.isRefreshing = true;\n      const databaseAccount = await this.getDatabaseAccountFromAnyEndpoint(diagnosticNode);\n      if (databaseAccount) {\n        this.refreshStaleUnavailableLocations();\n        this.refreshEndpoints(databaseAccount);\n      }\n      this.isRefreshing = false;\n    }\n  }\n\n  private refreshEndpoints(databaseAccount: DatabaseAccount): void {\n    for (const location of databaseAccount.writableLocations) {\n      const existingLocation = this.writeableLocations.find((loc) => loc.name === location.name);\n      if (!existingLocation) {\n        this.writeableLocations.push(location);\n      }\n    }\n    for (const location of databaseAccount.readableLocations) {\n      const existingLocation = this.readableLocations.find((loc) => loc.name === location.name);\n      if (!existingLocation) {\n        this.readableLocations.push(location);\n      }\n    }\n  }\n\n  private refreshStaleUnavailableLocations(): void {\n    const now = Date.now();\n    this.updateLocation(now, this.unavailableReadableLocations, this.readableLocations);\n    this.unavailableReadableLocations = this.cleanUnavailableLocationList(\n      now,\n      this.unavailableReadableLocations,\n    );\n\n    this.updateLocation(now, this.unavailableWriteableLocations, this.writeableLocations);\n    this.unavailableWriteableLocations = this.cleanUnavailableLocationList(\n      now,\n      this.unavailableWriteableLocations,\n    );\n  }\n\n  /**\n   * update the locationUnavailability to undefined if the location is available again\n   * @param now - current time\n   * @param unavailableLocations - list of unavailable locations\n   * @param allLocations - list of all locations\n   */\n  private updateLocation(\n    now: number,\n    unavailableLocations: Location[],\n    allLocations: Location[],\n  ): void {\n    for (const location of unavailableLocations) {\n      const unavaialableLocation = allLocations.find((loc) => loc.name === location.name);\n      if (\n        unavaialableLocation &&\n        now - unavaialableLocation.lastUnavailabilityTimestampInMs >\n          Constants.LocationUnavailableExpirationTimeInMs\n      ) {\n        unavaialableLocation.unavailable = false;\n      }\n    }\n  }\n\n  private cleanUnavailableLocationList(now: number, unavailableLocations: Location[]): Location[] {\n    return unavailableLocations.filter((loc) => {\n      if (\n        loc &&\n        now - loc.lastUnavailabilityTimestampInMs >= Constants.LocationUnavailableExpirationTimeInMs\n      ) {\n        return false;\n      }\n      return true;\n    });\n  }\n\n  /**\n   * Gets the database account first by using the default endpoint, and if that doesn't returns\n   * use the endpoints for the preferred locations in the order they are specified to get\n   * the database account.\n   */\n  private async getDatabaseAccountFromAnyEndpoint(\n    diagnosticNode: DiagnosticNodeInternal,\n  ): Promise<DatabaseAccount> {\n    try {\n      const options = { urlConnection: this.defaultEndpoint };\n      const { resource: databaseAccount } = await this.readDatabaseAccount(diagnosticNode, options);\n      return databaseAccount;\n      // If for any reason(non - globaldb related), we are not able to get the database\n      // account from the above call to readDatabaseAccount,\n      // we would try to get this information from any of the preferred locations that the user\n      // might have specified (by creating a locational endpoint)\n      // and keeping eating the exception until we get the database account and return None at the end,\n      // if we are not able to get that info from any endpoints\n    } catch (err: any) {\n      // TODO: Tracing\n    }\n\n    if (this.preferredLocations) {\n      for (const location of this.preferredLocations) {\n        try {\n          const locationalEndpoint = GlobalEndpointManager.getLocationalEndpoint(\n            this.defaultEndpoint,\n            location,\n          );\n          const options = { urlConnection: locationalEndpoint };\n          const { resource: databaseAccount } = await this.readDatabaseAccount(\n            diagnosticNode,\n            options,\n          );\n          if (databaseAccount) {\n            return databaseAccount;\n          }\n        } catch (err: any) {\n          // TODO: Tracing\n        }\n      }\n    }\n  }\n\n  /**\n   * Gets the locational endpoint using the location name passed to it using the default endpoint.\n   *\n   * @param defaultEndpoint - The default endpoint to use for the endpoint.\n   * @param locationName    - The location name for the azure region like \"East US\".\n   */\n  private static getLocationalEndpoint(defaultEndpoint: string, locationName: string): string {\n    // For defaultEndpoint like 'https://contoso.documents.azure.com:443/' parse it to generate URL format\n    // This defaultEndpoint should be global endpoint(and cannot be a locational endpoint)\n    // and we agreed to document that\n    const endpointUrl = new URL(defaultEndpoint);\n\n    // hostname attribute in endpointUrl will return 'contoso.documents.azure.com'\n    if (endpointUrl.hostname) {\n      const hostnameParts = endpointUrl.hostname.toString().toLowerCase().split(\".\");\n      if (hostnameParts) {\n        // globalDatabaseAccountName will return 'contoso'\n        const globalDatabaseAccountName = hostnameParts[0];\n\n        // Prepare the locationalDatabaseAccountName as contoso-EastUS for location_name 'East US'\n        const locationalDatabaseAccountName =\n          globalDatabaseAccountName + \"-\" + locationName.replace(\" \", \"\");\n\n        // Replace 'contoso' with 'contoso-EastUS' and\n        // return locationalEndpoint as https://contoso-EastUS.documents.azure.com:443/\n        const locationalEndpoint = defaultEndpoint\n          .toLowerCase()\n          .replace(globalDatabaseAccountName, locationalDatabaseAccountName);\n        return locationalEndpoint;\n      }\n    }\n\n    return null;\n  }\n}\n\nfunction normalizeEndpoint(endpoint: string): string {\n  return endpoint.split(\" \").join(\"\").toLowerCase();\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}