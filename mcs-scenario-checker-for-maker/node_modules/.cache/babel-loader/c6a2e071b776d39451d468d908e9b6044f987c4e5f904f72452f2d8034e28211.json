{"ast":null,"code":"// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport { doubleToByteArrayJSBI } from \"./encoding/number\";\nimport { BytePrefix } from \"./encoding/prefix\";\nimport MurmurHash from \"./murmurHash\";\nexport function hashV2PartitionKey(partitionKey) {\n  const toHash = Buffer.concat(partitionKey.map(prefixKeyByType));\n  const hash = MurmurHash.x64.hash128(toHash);\n  const reverseBuff = reverse(Buffer.from(hash, \"hex\"));\n  reverseBuff[0] &= 0x3f;\n  return reverseBuff.toString(\"hex\").toUpperCase();\n}\nfunction prefixKeyByType(key) {\n  let bytes;\n  switch (typeof key) {\n    case \"string\":\n      {\n        bytes = Buffer.concat([Buffer.from(BytePrefix.String, \"hex\"), Buffer.from(key), Buffer.from(BytePrefix.Infinity, \"hex\")]);\n        return bytes;\n      }\n    case \"number\":\n      {\n        const numberBytes = doubleToByteArrayJSBI(key);\n        bytes = Buffer.concat([Buffer.from(BytePrefix.Number, \"hex\"), numberBytes]);\n        return bytes;\n      }\n    case \"boolean\":\n      {\n        const prefix = key ? BytePrefix.True : BytePrefix.False;\n        return Buffer.from(prefix, \"hex\");\n      }\n    case \"object\":\n      {\n        if (key === null) {\n          return Buffer.from(BytePrefix.Null, \"hex\");\n        }\n        return Buffer.from(BytePrefix.Undefined, \"hex\");\n      }\n    case \"undefined\":\n      {\n        return Buffer.from(BytePrefix.Undefined, \"hex\");\n      }\n    default:\n      throw new Error(`Unexpected type: ${typeof key}`);\n  }\n}\nexport function reverse(buff) {\n  const buffer = Buffer.allocUnsafe(buff.length);\n  for (let i = 0, j = buff.length - 1; i <= j; ++i, --j) {\n    buffer[i] = buff[j];\n    buffer[j] = buff[i];\n  }\n  return buffer;\n}","map":{"version":3,"names":["doubleToByteArrayJSBI","BytePrefix","MurmurHash","hashV2PartitionKey","partitionKey","toHash","Buffer","concat","map","prefixKeyByType","hash","x64","hash128","reverseBuff","reverse","from","toString","toUpperCase","key","bytes","String","Infinity","numberBytes","Number","prefix","True","False","Null","Undefined","Error","buff","buffer","allocUnsafe","length","i","j"],"sources":["/Users/ajitpawar/microsoft/bap/POCs/Scenario_checker_for_maker/mcs-scenario-checker-for-maker/node_modules/@azure/cosmos/src/utils/hashing/v2.ts"],"sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\nimport type { PrimitivePartitionKeyValue } from \"../../documents\";\nimport { doubleToByteArrayJSBI } from \"./encoding/number\";\nimport { BytePrefix } from \"./encoding/prefix\";\nimport MurmurHash from \"./murmurHash\";\n\nexport function hashV2PartitionKey(partitionKey: PrimitivePartitionKeyValue[]): string {\n  const toHash: Buffer = Buffer.concat(partitionKey.map(prefixKeyByType));\n  const hash = MurmurHash.x64.hash128(toHash);\n  const reverseBuff: Buffer = reverse(Buffer.from(hash, \"hex\"));\n  reverseBuff[0] &= 0x3f;\n  return reverseBuff.toString(\"hex\").toUpperCase();\n}\n\nfunction prefixKeyByType(key: PrimitivePartitionKeyValue): Buffer {\n  let bytes: Buffer;\n  switch (typeof key) {\n    case \"string\": {\n      bytes = Buffer.concat([\n        Buffer.from(BytePrefix.String, \"hex\"),\n        Buffer.from(key),\n        Buffer.from(BytePrefix.Infinity, \"hex\"),\n      ]);\n      return bytes;\n    }\n    case \"number\": {\n      const numberBytes = doubleToByteArrayJSBI(key);\n      bytes = Buffer.concat([Buffer.from(BytePrefix.Number, \"hex\"), numberBytes]);\n      return bytes;\n    }\n    case \"boolean\": {\n      const prefix = key ? BytePrefix.True : BytePrefix.False;\n      return Buffer.from(prefix, \"hex\");\n    }\n    case \"object\": {\n      if (key === null) {\n        return Buffer.from(BytePrefix.Null, \"hex\");\n      }\n      return Buffer.from(BytePrefix.Undefined, \"hex\");\n    }\n    case \"undefined\": {\n      return Buffer.from(BytePrefix.Undefined, \"hex\");\n    }\n    default:\n      throw new Error(`Unexpected type: ${typeof key}`);\n  }\n}\n\nexport function reverse(buff: Buffer): Buffer {\n  const buffer = Buffer.allocUnsafe(buff.length);\n\n  for (let i = 0, j = buff.length - 1; i <= j; ++i, --j) {\n    buffer[i] = buff[j];\n    buffer[j] = buff[i];\n  }\n  return buffer;\n}\n"],"mappings":"AAAA;AACA;AAGA,SAASA,qBAAqB,QAAQ,mBAAmB;AACzD,SAASC,UAAU,QAAQ,mBAAmB;AAC9C,OAAOC,UAAU,MAAM,cAAc;AAErC,OAAM,SAAUC,kBAAkBA,CAACC,YAA0C;EAC3E,MAAMC,MAAM,GAAWC,MAAM,CAACC,MAAM,CAACH,YAAY,CAACI,GAAG,CAACC,eAAe,CAAC,CAAC;EACvE,MAAMC,IAAI,GAAGR,UAAU,CAACS,GAAG,CAACC,OAAO,CAACP,MAAM,CAAC;EAC3C,MAAMQ,WAAW,GAAWC,OAAO,CAACR,MAAM,CAACS,IAAI,CAACL,IAAI,EAAE,KAAK,CAAC,CAAC;EAC7DG,WAAW,CAAC,CAAC,CAAC,IAAI,IAAI;EACtB,OAAOA,WAAW,CAACG,QAAQ,CAAC,KAAK,CAAC,CAACC,WAAW,EAAE;AAClD;AAEA,SAASR,eAAeA,CAACS,GAA+B;EACtD,IAAIC,KAAa;EACjB,QAAQ,OAAOD,GAAG;IAChB,KAAK,QAAQ;MAAE;QACbC,KAAK,GAAGb,MAAM,CAACC,MAAM,CAAC,CACpBD,MAAM,CAACS,IAAI,CAACd,UAAU,CAACmB,MAAM,EAAE,KAAK,CAAC,EACrCd,MAAM,CAACS,IAAI,CAACG,GAAG,CAAC,EAChBZ,MAAM,CAACS,IAAI,CAACd,UAAU,CAACoB,QAAQ,EAAE,KAAK,CAAC,CACxC,CAAC;QACF,OAAOF,KAAK;MACd;IACA,KAAK,QAAQ;MAAE;QACb,MAAMG,WAAW,GAAGtB,qBAAqB,CAACkB,GAAG,CAAC;QAC9CC,KAAK,GAAGb,MAAM,CAACC,MAAM,CAAC,CAACD,MAAM,CAACS,IAAI,CAACd,UAAU,CAACsB,MAAM,EAAE,KAAK,CAAC,EAAED,WAAW,CAAC,CAAC;QAC3E,OAAOH,KAAK;MACd;IACA,KAAK,SAAS;MAAE;QACd,MAAMK,MAAM,GAAGN,GAAG,GAAGjB,UAAU,CAACwB,IAAI,GAAGxB,UAAU,CAACyB,KAAK;QACvD,OAAOpB,MAAM,CAACS,IAAI,CAACS,MAAM,EAAE,KAAK,CAAC;MACnC;IACA,KAAK,QAAQ;MAAE;QACb,IAAIN,GAAG,KAAK,IAAI,EAAE;UAChB,OAAOZ,MAAM,CAACS,IAAI,CAACd,UAAU,CAAC0B,IAAI,EAAE,KAAK,CAAC;QAC5C;QACA,OAAOrB,MAAM,CAACS,IAAI,CAACd,UAAU,CAAC2B,SAAS,EAAE,KAAK,CAAC;MACjD;IACA,KAAK,WAAW;MAAE;QAChB,OAAOtB,MAAM,CAACS,IAAI,CAACd,UAAU,CAAC2B,SAAS,EAAE,KAAK,CAAC;MACjD;IACA;MACE,MAAM,IAAIC,KAAK,CAAC,oBAAoB,OAAOX,GAAG,EAAE,CAAC;EACrD;AACF;AAEA,OAAM,SAAUJ,OAAOA,CAACgB,IAAY;EAClC,MAAMC,MAAM,GAAGzB,MAAM,CAAC0B,WAAW,CAACF,IAAI,CAACG,MAAM,CAAC;EAE9C,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEC,CAAC,GAAGL,IAAI,CAACG,MAAM,GAAG,CAAC,EAAEC,CAAC,IAAIC,CAAC,EAAE,EAAED,CAAC,EAAE,EAAEC,CAAC,EAAE;IACrDJ,MAAM,CAACG,CAAC,CAAC,GAAGJ,IAAI,CAACK,CAAC,CAAC;IACnBJ,MAAM,CAACI,CAAC,CAAC,GAAGL,IAAI,CAACI,CAAC,CAAC;EACrB;EACA,OAAOH,MAAM;AACf","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}