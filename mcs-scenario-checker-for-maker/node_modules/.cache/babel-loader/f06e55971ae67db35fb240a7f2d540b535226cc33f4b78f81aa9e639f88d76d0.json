{"ast":null,"code":"// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport PriorityQueue from \"priorityqueuejs\";\nimport semaphore from \"semaphore\";\nimport { createClientLogger } from \"@azure/logger\";\nimport { StatusCodes, SubStatusCodes } from \"../common/statusCodes\";\nimport { QueryRange } from \"../routing/QueryRange\";\nimport { SmartRoutingMapProvider } from \"../routing/smartRoutingMapProvider\";\nimport { DocumentProducer } from \"./documentProducer\";\nimport { getInitialHeader, mergeHeaders } from \"./headerUtils\";\nimport { DiagnosticNodeInternal, DiagnosticNodeType } from \"../diagnostics/DiagnosticNodeInternal\";\nimport { addDignosticChild } from \"../utils/diagnostics\";\nimport { MetadataLookUpType } from \"../CosmosDiagnostics\";\nimport { CosmosDbDiagnosticLevel } from \"../diagnostics/CosmosDbDiagnosticLevel\";\n/** @hidden */\nconst logger = createClientLogger(\"parallelQueryExecutionContextBase\");\n/** @hidden */\nexport var ParallelQueryExecutionContextBaseStates;\n(function (ParallelQueryExecutionContextBaseStates) {\n  ParallelQueryExecutionContextBaseStates[\"started\"] = \"started\";\n  ParallelQueryExecutionContextBaseStates[\"inProgress\"] = \"inProgress\";\n  ParallelQueryExecutionContextBaseStates[\"ended\"] = \"ended\";\n})(ParallelQueryExecutionContextBaseStates || (ParallelQueryExecutionContextBaseStates = {}));\n/** @hidden */\nexport class ParallelQueryExecutionContextBase {\n  /**\n   * Provides the ParallelQueryExecutionContextBase.\n   * This is the base class that ParallelQueryExecutionContext and OrderByQueryExecutionContext will derive from.\n   *\n   * When handling a parallelized query, it instantiates one instance of\n   * DocumentProcuder per target partition key range and aggregates the result of each.\n   *\n   * @param clientContext - The service endpoint to use to create the client.\n   * @param collectionLink - The Collection Link\n   * @param options - Represents the feed options.\n   * @param partitionedQueryExecutionInfo - PartitionedQueryExecutionInfo\n   * @hidden\n   */\n  constructor(clientContext, collectionLink, query, options, partitionedQueryExecutionInfo, correlatedActivityId) {\n    this.clientContext = clientContext;\n    this.collectionLink = collectionLink;\n    this.query = query;\n    this.options = options;\n    this.partitionedQueryExecutionInfo = partitionedQueryExecutionInfo;\n    this.correlatedActivityId = correlatedActivityId;\n    this.clientContext = clientContext;\n    this.collectionLink = collectionLink;\n    this.query = query;\n    this.options = options;\n    this.partitionedQueryExecutionInfo = partitionedQueryExecutionInfo;\n    this.correlatedActivityId = correlatedActivityId;\n    this.diagnosticNodeWrapper = {\n      consumed: false,\n      diagnosticNode: new DiagnosticNodeInternal(clientContext.diagnosticLevel, DiagnosticNodeType.PARALLEL_QUERY_NODE, null)\n    };\n    this.diagnosticNodeWrapper.diagnosticNode.addData({\n      stateful: true\n    });\n    this.err = undefined;\n    this.state = ParallelQueryExecutionContextBase.STATES.started;\n    this.routingProvider = new SmartRoutingMapProvider(this.clientContext);\n    this.sortOrders = this.partitionedQueryExecutionInfo.queryInfo.orderBy;\n    this.requestContinuation = options ? options.continuationToken || options.continuation : null;\n    // response headers of undergoing operation\n    this.respHeaders = getInitialHeader();\n    // Make priority queue for documentProducers\n    // The comparator is supplied by the derived class\n    this.orderByPQ = new PriorityQueue((a, b) => this.documentProducerComparator(b, a));\n    // Creating the documentProducers\n    this.sem = semaphore(1);\n    // Creating callback for semaphore\n    // TODO: Code smell\n    const createDocumentProducersAndFillUpPriorityQueueFunc = async () => {\n      // ensure the lock is released after finishing up\n      try {\n        const targetPartitionRanges = await this._onTargetPartitionRanges();\n        this.waitingForInternalExecutionContexts = targetPartitionRanges.length;\n        const maxDegreeOfParallelism = options.maxDegreeOfParallelism === undefined || options.maxDegreeOfParallelism < 1 ? targetPartitionRanges.length : Math.min(options.maxDegreeOfParallelism, targetPartitionRanges.length);\n        logger.info(\"Query starting against \" + targetPartitionRanges.length + \" ranges with parallelism of \" + maxDegreeOfParallelism);\n        const parallelismSem = semaphore(maxDegreeOfParallelism);\n        let filteredPartitionKeyRanges = [];\n        // The document producers generated from filteredPartitionKeyRanges\n        const targetPartitionQueryExecutionContextList = [];\n        if (this.requestContinuation) {\n          throw new Error(\"Continuation tokens are not yet supported for cross partition queries\");\n        } else {\n          filteredPartitionKeyRanges = targetPartitionRanges;\n        }\n        // Create one documentProducer for each partitionTargetRange\n        filteredPartitionKeyRanges.forEach(partitionTargetRange => {\n          // TODO: any partitionTargetRange\n          // no async callback\n          targetPartitionQueryExecutionContextList.push(this._createTargetPartitionQueryExecutionContext(partitionTargetRange));\n        });\n        // Fill up our priority queue with documentProducers\n        targetPartitionQueryExecutionContextList.forEach(documentProducer => {\n          // has async callback\n          const throttledFunc = async () => {\n            try {\n              const {\n                result: document,\n                headers\n              } = await documentProducer.current(this.getDiagnosticNode());\n              this._mergeWithActiveResponseHeaders(headers);\n              if (document === undefined) {\n                // no results on this one\n                return;\n              }\n              // if there are matching results in the target ex range add it to the priority queue\n              try {\n                this.orderByPQ.enq(documentProducer);\n              } catch (e) {\n                this.err = e;\n              }\n            } catch (err) {\n              this._mergeWithActiveResponseHeaders(err.headers);\n              this.err = err;\n            } finally {\n              parallelismSem.leave();\n              this._decrementInitiationLock();\n            }\n          };\n          parallelismSem.take(throttledFunc);\n        });\n      } catch (err) {\n        this.err = err;\n        // release the lock\n        this.sem.leave();\n        return;\n      }\n    };\n    this.sem.take(createDocumentProducersAndFillUpPriorityQueueFunc);\n  }\n  _decrementInitiationLock() {\n    // decrements waitingForInternalExecutionContexts\n    // if waitingForInternalExecutionContexts reaches 0 releases the semaphore and changes the state\n    this.waitingForInternalExecutionContexts = this.waitingForInternalExecutionContexts - 1;\n    if (this.waitingForInternalExecutionContexts === 0) {\n      this.sem.leave();\n      if (this.orderByPQ.size() === 0) {\n        this.state = ParallelQueryExecutionContextBase.STATES.inProgress;\n      }\n    }\n  }\n  _mergeWithActiveResponseHeaders(headers) {\n    mergeHeaders(this.respHeaders, headers);\n  }\n  _getAndResetActiveResponseHeaders() {\n    const ret = this.respHeaders;\n    this.respHeaders = getInitialHeader();\n    return ret;\n  }\n  getDiagnosticNode() {\n    return this.diagnosticNodeWrapper.diagnosticNode;\n  }\n  async _onTargetPartitionRanges() {\n    // invokes the callback when the target partition ranges are ready\n    const parsedRanges = this.partitionedQueryExecutionInfo.queryRanges;\n    const queryRanges = parsedRanges.map(item => QueryRange.parseFromDict(item));\n    return this.routingProvider.getOverlappingRanges(this.collectionLink, queryRanges, this.getDiagnosticNode());\n  }\n  /**\n   * Gets the replacement ranges for a partitionkeyrange that has been split\n   */\n  async _getReplacementPartitionKeyRanges(documentProducer) {\n    const partitionKeyRange = documentProducer.targetPartitionKeyRange;\n    // Download the new routing map\n    this.routingProvider = new SmartRoutingMapProvider(this.clientContext);\n    // Get the queryRange that relates to this partitionKeyRange\n    const queryRange = QueryRange.parsePartitionKeyRange(partitionKeyRange);\n    return this.routingProvider.getOverlappingRanges(this.collectionLink, [queryRange], this.getDiagnosticNode());\n  }\n  // TODO: P0 Code smell - can barely tell what this is doing\n  /**\n   * Removes the current document producer from the priqueue,\n   * replaces that document producer with child document producers,\n   * then reexecutes the originFunction with the corrrected executionContext\n   */\n  async _repairExecutionContext(diagnosticNode, originFunction) {\n    // TODO: any\n    // Get the replacement ranges\n    // Removing the invalid documentProducer from the orderByPQ\n    const parentDocumentProducer = this.orderByPQ.deq();\n    try {\n      const replacementPartitionKeyRanges = await this._getReplacementPartitionKeyRanges(parentDocumentProducer);\n      const replacementDocumentProducers = [];\n      // Create the replacement documentProducers\n      replacementPartitionKeyRanges.forEach(partitionKeyRange => {\n        // Create replacment document producers with the parent's continuationToken\n        const replacementDocumentProducer = this._createTargetPartitionQueryExecutionContext(partitionKeyRange, parentDocumentProducer.continuationToken);\n        replacementDocumentProducers.push(replacementDocumentProducer);\n      });\n      // We need to check if the documentProducers even has anything left to fetch from before enqueing them\n      const checkAndEnqueueDocumentProducer = async (documentProducerToCheck, checkNextDocumentProducerCallback) => {\n        try {\n          const {\n            result: afterItem\n          } = await documentProducerToCheck.current(diagnosticNode);\n          if (afterItem === undefined) {\n            // no more results left in this document producer, so we don't enqueue it\n          } else {\n            // Safe to put document producer back in the queue\n            this.orderByPQ.enq(documentProducerToCheck);\n          }\n          await checkNextDocumentProducerCallback();\n        } catch (err) {\n          this.err = err;\n          return;\n        }\n      };\n      const checkAndEnqueueDocumentProducers = async rdp => {\n        if (rdp.length > 0) {\n          // We still have a replacementDocumentProducer to check\n          const replacementDocumentProducer = rdp.shift();\n          await checkAndEnqueueDocumentProducer(replacementDocumentProducer, async () => {\n            await checkAndEnqueueDocumentProducers(rdp);\n          });\n        } else {\n          // reexecutes the originFunction with the corrrected executionContext\n          return originFunction();\n        }\n      };\n      // Invoke the recursive function to get the ball rolling\n      await checkAndEnqueueDocumentProducers(replacementDocumentProducers);\n    } catch (err) {\n      this.err = err;\n      throw err;\n    }\n  }\n  static _needPartitionKeyRangeCacheRefresh(error) {\n    // TODO: any error\n    return error.code === StatusCodes.Gone && \"substatus\" in error && error[\"substatus\"] === SubStatusCodes.PartitionKeyRangeGone;\n  }\n  /**\n   * Checks to see if the executionContext needs to be repaired.\n   * if so it repairs the execution context and executes the ifCallback,\n   * else it continues with the current execution context and executes the elseCallback\n   */\n  async _repairExecutionContextIfNeeded(diagnosticNode, ifCallback, elseCallback) {\n    const documentProducer = this.orderByPQ.peek();\n    // Check if split happened\n    try {\n      await documentProducer.current(diagnosticNode);\n      elseCallback();\n    } catch (err) {\n      if (ParallelQueryExecutionContextBase._needPartitionKeyRangeCacheRefresh(err)) {\n        // Split has happened so we need to repair execution context before continueing\n        return addDignosticChild(childNode => this._repairExecutionContext(childNode, ifCallback), diagnosticNode, DiagnosticNodeType.QUERY_REPAIR_NODE);\n      } else {\n        // Something actually bad happened ...\n        this.err = err;\n        throw err;\n      }\n    }\n  }\n  /**\n   * Fetches the next element in the ParallelQueryExecutionContextBase.\n   */\n  async nextItem(diagnosticNode) {\n    if (this.err) {\n      // if there is a prior error return error\n      throw this.err;\n    }\n    return new Promise((resolve, reject) => {\n      this.sem.take(() => {\n        if (!this.diagnosticNodeWrapper.consumed) {\n          diagnosticNode.addChildNode(this.diagnosticNodeWrapper.diagnosticNode, CosmosDbDiagnosticLevel.debug, MetadataLookUpType.QueryPlanLookUp);\n          this.diagnosticNodeWrapper.diagnosticNode = undefined;\n          this.diagnosticNodeWrapper.consumed = true;\n        } else {\n          this.diagnosticNodeWrapper.diagnosticNode = diagnosticNode;\n        }\n        // NOTE: lock must be released before invoking quitting\n        if (this.err) {\n          // release the lock before invoking callback\n          this.sem.leave();\n          // if there is a prior error return error\n          this.err.headers = this._getAndResetActiveResponseHeaders();\n          reject(this.err);\n          return;\n        }\n        if (this.orderByPQ.size() === 0) {\n          // there is no more results\n          this.state = ParallelQueryExecutionContextBase.STATES.ended;\n          // release the lock before invoking callback\n          this.sem.leave();\n          return resolve({\n            result: undefined,\n            headers: this._getAndResetActiveResponseHeaders()\n          });\n        }\n        const ifCallback = () => {\n          // Release the semaphore to avoid deadlock\n          this.sem.leave();\n          // Reexcute the function\n          return resolve(this.nextItem(diagnosticNode));\n        };\n        const elseCallback = async () => {\n          let documentProducer;\n          try {\n            documentProducer = this.orderByPQ.deq();\n          } catch (e) {\n            // if comparing elements of the priority queue throws exception\n            // set that error and return error\n            this.err = e;\n            // release the lock before invoking callback\n            this.sem.leave();\n            this.err.headers = this._getAndResetActiveResponseHeaders();\n            reject(this.err);\n            return;\n          }\n          let item;\n          let headers;\n          try {\n            const response = await documentProducer.nextItem(diagnosticNode);\n            item = response.result;\n            headers = response.headers;\n            this._mergeWithActiveResponseHeaders(headers);\n            if (item === undefined) {\n              // this should never happen\n              // because the documentProducer already has buffered an item\n              // assert item !== undefined\n              this.err = new Error(`Extracted DocumentProducer from the priority queue \\\n                                            doesn't have any buffered item!`);\n              // release the lock before invoking callback\n              this.sem.leave();\n              return resolve({\n                result: undefined,\n                headers: this._getAndResetActiveResponseHeaders()\n              });\n            }\n          } catch (err) {\n            this.err = new Error(`Extracted DocumentProducer from the priority queue fails to get the \\\n                                    buffered item. Due to ${JSON.stringify(err)}`);\n            this.err.headers = this._getAndResetActiveResponseHeaders();\n            // release the lock before invoking callback\n            this.sem.leave();\n            reject(this.err);\n            return;\n          }\n          // we need to put back the document producer to the queue if it has more elements.\n          // the lock will be released after we know document producer must be put back in the queue or not\n          try {\n            const {\n              result: afterItem,\n              headers: otherHeaders\n            } = await documentProducer.current(diagnosticNode);\n            this._mergeWithActiveResponseHeaders(otherHeaders);\n            if (afterItem === undefined) {\n              // no more results is left in this document producer\n            } else {\n              try {\n                const headItem = documentProducer.fetchResults[0];\n                if (typeof headItem === \"undefined\") {\n                  throw new Error(\"Extracted DocumentProducer from PQ is invalid state with no result!\");\n                }\n                this.orderByPQ.enq(documentProducer);\n              } catch (e) {\n                // if comparing elements in priority queue throws exception\n                // set error\n                this.err = e;\n              }\n            }\n          } catch (err) {\n            if (ParallelQueryExecutionContextBase._needPartitionKeyRangeCacheRefresh(err)) {\n              // We want the document producer enqueued\n              // So that later parts of the code can repair the execution context\n              this.orderByPQ.enq(documentProducer);\n            } else {\n              // Something actually bad happened\n              this.err = err;\n              reject(this.err);\n            }\n          } finally {\n            // release the lock before returning\n            this.sem.leave();\n          }\n          // invoke the callback on the item\n          return resolve({\n            result: item,\n            headers: this._getAndResetActiveResponseHeaders()\n          });\n        };\n        this._repairExecutionContextIfNeeded(diagnosticNode, ifCallback, elseCallback).catch(reject);\n      });\n    });\n  }\n  /**\n   * Determine if there are still remaining resources to processs based on the value of the continuation\n   * token or the elements remaining on the current batch in the QueryIterator.\n   * @returns true if there is other elements to process in the ParallelQueryExecutionContextBase.\n   */\n  hasMoreResults() {\n    return !(this.state === ParallelQueryExecutionContextBase.STATES.ended || this.err !== undefined);\n  }\n  /**\n   * Creates document producers\n   */\n  _createTargetPartitionQueryExecutionContext(partitionKeyTargetRange, continuationToken) {\n    // TODO: any\n    // creates target partition range Query Execution Context\n    let rewrittenQuery = this.partitionedQueryExecutionInfo.queryInfo.rewrittenQuery;\n    let sqlQuerySpec;\n    const query = this.query;\n    if (typeof query === \"string\") {\n      sqlQuerySpec = {\n        query\n      };\n    } else {\n      sqlQuerySpec = query;\n    }\n    const formatPlaceHolder = \"{documentdb-formattableorderbyquery-filter}\";\n    if (rewrittenQuery) {\n      sqlQuerySpec = JSON.parse(JSON.stringify(sqlQuerySpec));\n      // We hardcode the formattable filter to true for now\n      rewrittenQuery = rewrittenQuery.replace(formatPlaceHolder, \"true\");\n      sqlQuerySpec[\"query\"] = rewrittenQuery;\n    }\n    const options = Object.assign({}, this.options);\n    options.continuationToken = continuationToken;\n    return new DocumentProducer(this.clientContext, this.collectionLink, sqlQuerySpec, partitionKeyTargetRange, options, this.correlatedActivityId);\n  }\n}\nParallelQueryExecutionContextBase.STATES = ParallelQueryExecutionContextBaseStates;","map":{"version":3,"names":["PriorityQueue","semaphore","createClientLogger","StatusCodes","SubStatusCodes","QueryRange","SmartRoutingMapProvider","DocumentProducer","getInitialHeader","mergeHeaders","DiagnosticNodeInternal","DiagnosticNodeType","addDignosticChild","MetadataLookUpType","CosmosDbDiagnosticLevel","logger","ParallelQueryExecutionContextBaseStates","ParallelQueryExecutionContextBase","constructor","clientContext","collectionLink","query","options","partitionedQueryExecutionInfo","correlatedActivityId","diagnosticNodeWrapper","consumed","diagnosticNode","diagnosticLevel","PARALLEL_QUERY_NODE","addData","stateful","err","undefined","state","STATES","started","routingProvider","sortOrders","queryInfo","orderBy","requestContinuation","continuationToken","continuation","respHeaders","orderByPQ","a","b","documentProducerComparator","sem","createDocumentProducersAndFillUpPriorityQueueFunc","targetPartitionRanges","_onTargetPartitionRanges","waitingForInternalExecutionContexts","length","maxDegreeOfParallelism","Math","min","info","parallelismSem","filteredPartitionKeyRanges","targetPartitionQueryExecutionContextList","Error","forEach","partitionTargetRange","push","_createTargetPartitionQueryExecutionContext","documentProducer","throttledFunc","result","document","headers","current","getDiagnosticNode","_mergeWithActiveResponseHeaders","enq","e","leave","_decrementInitiationLock","take","size","inProgress","_getAndResetActiveResponseHeaders","ret","parsedRanges","queryRanges","map","item","parseFromDict","getOverlappingRanges","_getReplacementPartitionKeyRanges","partitionKeyRange","targetPartitionKeyRange","queryRange","parsePartitionKeyRange","_repairExecutionContext","originFunction","parentDocumentProducer","deq","replacementPartitionKeyRanges","replacementDocumentProducers","replacementDocumentProducer","checkAndEnqueueDocumentProducer","documentProducerToCheck","checkNextDocumentProducerCallback","afterItem","checkAndEnqueueDocumentProducers","rdp","shift","_needPartitionKeyRangeCacheRefresh","error","code","Gone","PartitionKeyRangeGone","_repairExecutionContextIfNeeded","ifCallback","elseCallback","peek","childNode","QUERY_REPAIR_NODE","nextItem","Promise","resolve","reject","addChildNode","debug","QueryPlanLookUp","ended","response","JSON","stringify","otherHeaders","headItem","fetchResults","catch","hasMoreResults","partitionKeyTargetRange","rewrittenQuery","sqlQuerySpec","formatPlaceHolder","parse","replace","Object","assign"],"sources":["/Users/ajitpawar/microsoft/bap/POCs/Scenario_checker_for_maker/mcs-scenario-checker-for-maker/node_modules/@azure/cosmos/src/queryExecutionContext/parallelQueryExecutionContextBase.ts"],"sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport PriorityQueue from \"priorityqueuejs\";\nimport semaphore from \"semaphore\";\nimport type { ClientContext } from \"../ClientContext\";\nimport type { AzureLogger } from \"@azure/logger\";\nimport { createClientLogger } from \"@azure/logger\";\nimport { StatusCodes, SubStatusCodes } from \"../common/statusCodes\";\nimport type { FeedOptions, Response } from \"../request\";\nimport type { PartitionedQueryExecutionInfo } from \"../request/ErrorResponse\";\nimport { QueryRange } from \"../routing/QueryRange\";\nimport { SmartRoutingMapProvider } from \"../routing/smartRoutingMapProvider\";\nimport type { CosmosHeaders } from \"./CosmosHeaders\";\nimport { DocumentProducer } from \"./documentProducer\";\nimport type { ExecutionContext } from \"./ExecutionContext\";\nimport { getInitialHeader, mergeHeaders } from \"./headerUtils\";\nimport type { SqlQuerySpec } from \"./SqlQuerySpec\";\nimport { DiagnosticNodeInternal, DiagnosticNodeType } from \"../diagnostics/DiagnosticNodeInternal\";\nimport { addDignosticChild } from \"../utils/diagnostics\";\nimport { MetadataLookUpType } from \"../CosmosDiagnostics\";\nimport { CosmosDbDiagnosticLevel } from \"../diagnostics/CosmosDbDiagnosticLevel\";\n\n/** @hidden */\nconst logger: AzureLogger = createClientLogger(\"parallelQueryExecutionContextBase\");\n\n/** @hidden */\nexport enum ParallelQueryExecutionContextBaseStates {\n  started = \"started\",\n  inProgress = \"inProgress\",\n  ended = \"ended\",\n}\n\n/** @hidden */\nexport abstract class ParallelQueryExecutionContextBase implements ExecutionContext {\n  private err: any;\n  private state: any;\n  private static STATES = ParallelQueryExecutionContextBaseStates;\n  private routingProvider: SmartRoutingMapProvider;\n  protected sortOrders: any;\n  private requestContinuation: any;\n  private respHeaders: CosmosHeaders;\n  private orderByPQ: PriorityQueue<DocumentProducer>;\n  private sem: any;\n  private waitingForInternalExecutionContexts: number;\n  private diagnosticNodeWrapper: {\n    consumed: boolean;\n    diagnosticNode: DiagnosticNodeInternal;\n  };\n  /**\n   * Provides the ParallelQueryExecutionContextBase.\n   * This is the base class that ParallelQueryExecutionContext and OrderByQueryExecutionContext will derive from.\n   *\n   * When handling a parallelized query, it instantiates one instance of\n   * DocumentProcuder per target partition key range and aggregates the result of each.\n   *\n   * @param clientContext - The service endpoint to use to create the client.\n   * @param collectionLink - The Collection Link\n   * @param options - Represents the feed options.\n   * @param partitionedQueryExecutionInfo - PartitionedQueryExecutionInfo\n   * @hidden\n   */\n  constructor(\n    private clientContext: ClientContext,\n    private collectionLink: string,\n    private query: string | SqlQuerySpec,\n    private options: FeedOptions,\n    private partitionedQueryExecutionInfo: PartitionedQueryExecutionInfo,\n    private correlatedActivityId: string,\n  ) {\n    this.clientContext = clientContext;\n    this.collectionLink = collectionLink;\n    this.query = query;\n    this.options = options;\n    this.partitionedQueryExecutionInfo = partitionedQueryExecutionInfo;\n    this.correlatedActivityId = correlatedActivityId;\n    this.diagnosticNodeWrapper = {\n      consumed: false,\n      diagnosticNode: new DiagnosticNodeInternal(\n        clientContext.diagnosticLevel,\n        DiagnosticNodeType.PARALLEL_QUERY_NODE,\n        null,\n      ),\n    };\n    this.diagnosticNodeWrapper.diagnosticNode.addData({ stateful: true });\n    this.err = undefined;\n    this.state = ParallelQueryExecutionContextBase.STATES.started;\n    this.routingProvider = new SmartRoutingMapProvider(this.clientContext);\n    this.sortOrders = this.partitionedQueryExecutionInfo.queryInfo.orderBy;\n\n    this.requestContinuation = options ? options.continuationToken || options.continuation : null;\n    // response headers of undergoing operation\n    this.respHeaders = getInitialHeader();\n\n    // Make priority queue for documentProducers\n    // The comparator is supplied by the derived class\n    this.orderByPQ = new PriorityQueue<DocumentProducer>(\n      (a: DocumentProducer, b: DocumentProducer) => this.documentProducerComparator(b, a),\n    );\n    // Creating the documentProducers\n    this.sem = semaphore(1);\n    // Creating callback for semaphore\n    // TODO: Code smell\n    const createDocumentProducersAndFillUpPriorityQueueFunc = async (): Promise<void> => {\n      // ensure the lock is released after finishing up\n      try {\n        const targetPartitionRanges = await this._onTargetPartitionRanges();\n        this.waitingForInternalExecutionContexts = targetPartitionRanges.length;\n\n        const maxDegreeOfParallelism =\n          options.maxDegreeOfParallelism === undefined || options.maxDegreeOfParallelism < 1\n            ? targetPartitionRanges.length\n            : Math.min(options.maxDegreeOfParallelism, targetPartitionRanges.length);\n\n        logger.info(\n          \"Query starting against \" +\n            targetPartitionRanges.length +\n            \" ranges with parallelism of \" +\n            maxDegreeOfParallelism,\n        );\n\n        const parallelismSem = semaphore(maxDegreeOfParallelism);\n        let filteredPartitionKeyRanges = [];\n        // The document producers generated from filteredPartitionKeyRanges\n        const targetPartitionQueryExecutionContextList: DocumentProducer[] = [];\n\n        if (this.requestContinuation) {\n          throw new Error(\"Continuation tokens are not yet supported for cross partition queries\");\n        } else {\n          filteredPartitionKeyRanges = targetPartitionRanges;\n        }\n\n        // Create one documentProducer for each partitionTargetRange\n        filteredPartitionKeyRanges.forEach((partitionTargetRange: any) => {\n          // TODO: any partitionTargetRange\n          // no async callback\n          targetPartitionQueryExecutionContextList.push(\n            this._createTargetPartitionQueryExecutionContext(partitionTargetRange),\n          );\n        });\n\n        // Fill up our priority queue with documentProducers\n        targetPartitionQueryExecutionContextList.forEach((documentProducer): void => {\n          // has async callback\n          const throttledFunc = async (): Promise<void> => {\n            try {\n              const { result: document, headers } = await documentProducer.current(\n                this.getDiagnosticNode(),\n              );\n              this._mergeWithActiveResponseHeaders(headers);\n              if (document === undefined) {\n                // no results on this one\n                return;\n              }\n              // if there are matching results in the target ex range add it to the priority queue\n              try {\n                this.orderByPQ.enq(documentProducer);\n              } catch (e: any) {\n                this.err = e;\n              }\n            } catch (err: any) {\n              this._mergeWithActiveResponseHeaders(err.headers);\n              this.err = err;\n            } finally {\n              parallelismSem.leave();\n              this._decrementInitiationLock();\n            }\n          };\n          parallelismSem.take(throttledFunc);\n        });\n      } catch (err: any) {\n        this.err = err;\n        // release the lock\n        this.sem.leave();\n        return;\n      }\n    };\n    this.sem.take(createDocumentProducersAndFillUpPriorityQueueFunc);\n  }\n\n  protected abstract documentProducerComparator(\n    dp1: DocumentProducer,\n    dp2: DocumentProducer,\n  ): number;\n\n  private _decrementInitiationLock(): void {\n    // decrements waitingForInternalExecutionContexts\n    // if waitingForInternalExecutionContexts reaches 0 releases the semaphore and changes the state\n    this.waitingForInternalExecutionContexts = this.waitingForInternalExecutionContexts - 1;\n    if (this.waitingForInternalExecutionContexts === 0) {\n      this.sem.leave();\n      if (this.orderByPQ.size() === 0) {\n        this.state = ParallelQueryExecutionContextBase.STATES.inProgress;\n      }\n    }\n  }\n\n  private _mergeWithActiveResponseHeaders(headers: CosmosHeaders): void {\n    mergeHeaders(this.respHeaders, headers);\n  }\n\n  private _getAndResetActiveResponseHeaders(): CosmosHeaders {\n    const ret = this.respHeaders;\n    this.respHeaders = getInitialHeader();\n    return ret;\n  }\n\n  private getDiagnosticNode(): DiagnosticNodeInternal {\n    return this.diagnosticNodeWrapper.diagnosticNode;\n  }\n\n  private async _onTargetPartitionRanges(): Promise<any[]> {\n    // invokes the callback when the target partition ranges are ready\n    const parsedRanges = this.partitionedQueryExecutionInfo.queryRanges;\n    const queryRanges = parsedRanges.map((item) => QueryRange.parseFromDict(item));\n    return this.routingProvider.getOverlappingRanges(\n      this.collectionLink,\n      queryRanges,\n      this.getDiagnosticNode(),\n    );\n  }\n\n  /**\n   * Gets the replacement ranges for a partitionkeyrange that has been split\n   */\n  private async _getReplacementPartitionKeyRanges(\n    documentProducer: DocumentProducer,\n  ): Promise<any[]> {\n    const partitionKeyRange = documentProducer.targetPartitionKeyRange;\n    // Download the new routing map\n    this.routingProvider = new SmartRoutingMapProvider(this.clientContext);\n    // Get the queryRange that relates to this partitionKeyRange\n    const queryRange = QueryRange.parsePartitionKeyRange(partitionKeyRange);\n    return this.routingProvider.getOverlappingRanges(\n      this.collectionLink,\n      [queryRange],\n      this.getDiagnosticNode(),\n    );\n  }\n\n  // TODO: P0 Code smell - can barely tell what this is doing\n  /**\n   * Removes the current document producer from the priqueue,\n   * replaces that document producer with child document producers,\n   * then reexecutes the originFunction with the corrrected executionContext\n   */\n  private async _repairExecutionContext(\n    diagnosticNode: DiagnosticNodeInternal,\n    originFunction: any,\n  ): Promise<void> {\n    // TODO: any\n    // Get the replacement ranges\n    // Removing the invalid documentProducer from the orderByPQ\n    const parentDocumentProducer = this.orderByPQ.deq();\n    try {\n      const replacementPartitionKeyRanges: any[] =\n        await this._getReplacementPartitionKeyRanges(parentDocumentProducer);\n      const replacementDocumentProducers: DocumentProducer[] = [];\n      // Create the replacement documentProducers\n      replacementPartitionKeyRanges.forEach((partitionKeyRange) => {\n        // Create replacment document producers with the parent's continuationToken\n        const replacementDocumentProducer = this._createTargetPartitionQueryExecutionContext(\n          partitionKeyRange,\n          parentDocumentProducer.continuationToken,\n        );\n        replacementDocumentProducers.push(replacementDocumentProducer);\n      });\n      // We need to check if the documentProducers even has anything left to fetch from before enqueing them\n      const checkAndEnqueueDocumentProducer = async (\n        documentProducerToCheck: DocumentProducer,\n        checkNextDocumentProducerCallback: any,\n      ): Promise<void> => {\n        try {\n          const { result: afterItem } = await documentProducerToCheck.current(diagnosticNode);\n          if (afterItem === undefined) {\n            // no more results left in this document producer, so we don't enqueue it\n          } else {\n            // Safe to put document producer back in the queue\n            this.orderByPQ.enq(documentProducerToCheck);\n          }\n\n          await checkNextDocumentProducerCallback();\n        } catch (err: any) {\n          this.err = err;\n          return;\n        }\n      };\n      const checkAndEnqueueDocumentProducers = async (rdp: DocumentProducer[]): Promise<any> => {\n        if (rdp.length > 0) {\n          // We still have a replacementDocumentProducer to check\n          const replacementDocumentProducer = rdp.shift();\n          await checkAndEnqueueDocumentProducer(replacementDocumentProducer, async () => {\n            await checkAndEnqueueDocumentProducers(rdp);\n          });\n        } else {\n          // reexecutes the originFunction with the corrrected executionContext\n          return originFunction();\n        }\n      };\n      // Invoke the recursive function to get the ball rolling\n      await checkAndEnqueueDocumentProducers(replacementDocumentProducers);\n    } catch (err: any) {\n      this.err = err;\n      throw err;\n    }\n  }\n\n  private static _needPartitionKeyRangeCacheRefresh(error: any): boolean {\n    // TODO: any error\n    return (\n      error.code === StatusCodes.Gone &&\n      \"substatus\" in error &&\n      error[\"substatus\"] === SubStatusCodes.PartitionKeyRangeGone\n    );\n  }\n\n  /**\n   * Checks to see if the executionContext needs to be repaired.\n   * if so it repairs the execution context and executes the ifCallback,\n   * else it continues with the current execution context and executes the elseCallback\n   */\n  private async _repairExecutionContextIfNeeded(\n    diagnosticNode: DiagnosticNodeInternal,\n    ifCallback: any,\n    elseCallback: any,\n  ): Promise<void> {\n    const documentProducer = this.orderByPQ.peek();\n    // Check if split happened\n    try {\n      await documentProducer.current(diagnosticNode);\n      elseCallback();\n    } catch (err: any) {\n      if (ParallelQueryExecutionContextBase._needPartitionKeyRangeCacheRefresh(err)) {\n        // Split has happened so we need to repair execution context before continueing\n        return addDignosticChild(\n          (childNode) => this._repairExecutionContext(childNode, ifCallback),\n          diagnosticNode,\n          DiagnosticNodeType.QUERY_REPAIR_NODE,\n        );\n      } else {\n        // Something actually bad happened ...\n        this.err = err;\n        throw err;\n      }\n    }\n  }\n\n  /**\n   * Fetches the next element in the ParallelQueryExecutionContextBase.\n   */\n  public async nextItem(diagnosticNode: DiagnosticNodeInternal): Promise<Response<any>> {\n    if (this.err) {\n      // if there is a prior error return error\n      throw this.err;\n    }\n    return new Promise<Response<any>>((resolve, reject) => {\n      this.sem.take(() => {\n        if (!this.diagnosticNodeWrapper.consumed) {\n          diagnosticNode.addChildNode(\n            this.diagnosticNodeWrapper.diagnosticNode,\n            CosmosDbDiagnosticLevel.debug,\n            MetadataLookUpType.QueryPlanLookUp,\n          );\n          this.diagnosticNodeWrapper.diagnosticNode = undefined;\n          this.diagnosticNodeWrapper.consumed = true;\n        } else {\n          this.diagnosticNodeWrapper.diagnosticNode = diagnosticNode;\n        }\n\n        // NOTE: lock must be released before invoking quitting\n        if (this.err) {\n          // release the lock before invoking callback\n          this.sem.leave();\n          // if there is a prior error return error\n          this.err.headers = this._getAndResetActiveResponseHeaders();\n          reject(this.err);\n          return;\n        }\n\n        if (this.orderByPQ.size() === 0) {\n          // there is no more results\n          this.state = ParallelQueryExecutionContextBase.STATES.ended;\n          // release the lock before invoking callback\n          this.sem.leave();\n          return resolve({\n            result: undefined,\n            headers: this._getAndResetActiveResponseHeaders(),\n          });\n        }\n\n        const ifCallback = (): void => {\n          // Release the semaphore to avoid deadlock\n          this.sem.leave();\n          // Reexcute the function\n          return resolve(this.nextItem(diagnosticNode));\n        };\n        const elseCallback = async (): Promise<void> => {\n          let documentProducer: DocumentProducer;\n          try {\n            documentProducer = this.orderByPQ.deq();\n          } catch (e: any) {\n            // if comparing elements of the priority queue throws exception\n            // set that error and return error\n            this.err = e;\n            // release the lock before invoking callback\n            this.sem.leave();\n            this.err.headers = this._getAndResetActiveResponseHeaders();\n            reject(this.err);\n            return;\n          }\n\n          let item: any;\n          let headers: CosmosHeaders;\n          try {\n            const response = await documentProducer.nextItem(diagnosticNode);\n            item = response.result;\n            headers = response.headers;\n            this._mergeWithActiveResponseHeaders(headers);\n            if (item === undefined) {\n              // this should never happen\n              // because the documentProducer already has buffered an item\n              // assert item !== undefined\n              this.err = new Error(\n                `Extracted DocumentProducer from the priority queue \\\n                                            doesn't have any buffered item!`,\n              );\n              // release the lock before invoking callback\n              this.sem.leave();\n              return resolve({\n                result: undefined,\n                headers: this._getAndResetActiveResponseHeaders(),\n              });\n            }\n          } catch (err: any) {\n            this.err = new Error(\n              `Extracted DocumentProducer from the priority queue fails to get the \\\n                                    buffered item. Due to ${JSON.stringify(err)}`,\n            );\n            this.err.headers = this._getAndResetActiveResponseHeaders();\n            // release the lock before invoking callback\n            this.sem.leave();\n            reject(this.err);\n            return;\n          }\n\n          // we need to put back the document producer to the queue if it has more elements.\n          // the lock will be released after we know document producer must be put back in the queue or not\n          try {\n            const { result: afterItem, headers: otherHeaders } =\n              await documentProducer.current(diagnosticNode);\n            this._mergeWithActiveResponseHeaders(otherHeaders);\n            if (afterItem === undefined) {\n              // no more results is left in this document producer\n            } else {\n              try {\n                const headItem = documentProducer.fetchResults[0];\n                if (typeof headItem === \"undefined\") {\n                  throw new Error(\n                    \"Extracted DocumentProducer from PQ is invalid state with no result!\",\n                  );\n                }\n                this.orderByPQ.enq(documentProducer);\n              } catch (e: any) {\n                // if comparing elements in priority queue throws exception\n                // set error\n                this.err = e;\n              }\n            }\n          } catch (err: any) {\n            if (ParallelQueryExecutionContextBase._needPartitionKeyRangeCacheRefresh(err)) {\n              // We want the document producer enqueued\n              // So that later parts of the code can repair the execution context\n              this.orderByPQ.enq(documentProducer);\n            } else {\n              // Something actually bad happened\n              this.err = err;\n              reject(this.err);\n            }\n          } finally {\n            // release the lock before returning\n            this.sem.leave();\n          }\n          // invoke the callback on the item\n          return resolve({\n            result: item,\n            headers: this._getAndResetActiveResponseHeaders(),\n          });\n        };\n        this._repairExecutionContextIfNeeded(diagnosticNode, ifCallback, elseCallback).catch(\n          reject,\n        );\n      });\n    });\n  }\n\n  /**\n   * Determine if there are still remaining resources to processs based on the value of the continuation\n   * token or the elements remaining on the current batch in the QueryIterator.\n   * @returns true if there is other elements to process in the ParallelQueryExecutionContextBase.\n   */\n  public hasMoreResults(): boolean {\n    return !(\n      this.state === ParallelQueryExecutionContextBase.STATES.ended || this.err !== undefined\n    );\n  }\n\n  /**\n   * Creates document producers\n   */\n  private _createTargetPartitionQueryExecutionContext(\n    partitionKeyTargetRange: any,\n    continuationToken?: any,\n  ): DocumentProducer {\n    // TODO: any\n    // creates target partition range Query Execution Context\n    let rewrittenQuery = this.partitionedQueryExecutionInfo.queryInfo.rewrittenQuery;\n    let sqlQuerySpec: SqlQuerySpec;\n    const query = this.query;\n    if (typeof query === \"string\") {\n      sqlQuerySpec = { query };\n    } else {\n      sqlQuerySpec = query;\n    }\n\n    const formatPlaceHolder = \"{documentdb-formattableorderbyquery-filter}\";\n    if (rewrittenQuery) {\n      sqlQuerySpec = JSON.parse(JSON.stringify(sqlQuerySpec));\n      // We hardcode the formattable filter to true for now\n      rewrittenQuery = rewrittenQuery.replace(formatPlaceHolder, \"true\");\n      sqlQuerySpec[\"query\"] = rewrittenQuery;\n    }\n\n    const options = { ...this.options };\n    options.continuationToken = continuationToken;\n\n    return new DocumentProducer(\n      this.clientContext,\n      this.collectionLink,\n      sqlQuerySpec,\n      partitionKeyTargetRange,\n      options,\n      this.correlatedActivityId,\n    );\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}