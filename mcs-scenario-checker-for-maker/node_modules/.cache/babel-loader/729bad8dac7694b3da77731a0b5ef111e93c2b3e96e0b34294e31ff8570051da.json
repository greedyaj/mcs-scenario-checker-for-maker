{"ast":null,"code":"/**\n * Used to specify which type of events to execute this plug in on.\n *\n * @hidden\n */\nexport var PluginOn;\n(function (PluginOn) {\n  /**\n   * Will be executed per network request\n   */\n  PluginOn[\"request\"] = \"request\";\n  /**\n   * Will be executed per API operation\n   */\n  PluginOn[\"operation\"] = \"operation\";\n})(PluginOn || (PluginOn = {}));\n/**\n * @internal\n */\nexport async function executePlugins(diagnosticNode, requestContext, next, on) {\n  if (!requestContext.plugins) {\n    return next(requestContext, diagnosticNode, undefined);\n  }\n  let level = 0;\n  const _ = inner => {\n    if (++level >= inner.plugins.length) {\n      return next(requestContext, diagnosticNode, undefined);\n    } else if (inner.plugins[level].on !== on) {\n      return _(requestContext);\n    } else {\n      return inner.plugins[level].plugin(inner, diagnosticNode, _);\n    }\n  };\n  if (requestContext.plugins[level].on !== on) {\n    return _(requestContext);\n  } else {\n    return requestContext.plugins[level].plugin(requestContext, diagnosticNode, _);\n  }\n}","map":{"version":3,"names":["PluginOn","executePlugins","diagnosticNode","requestContext","next","on","plugins","undefined","level","_","inner","length","plugin"],"sources":["/Users/ajitpawar/microsoft/bap/POCs/Scenario_checker_for_maker/mcs-scenario-checker-for-maker/node_modules/@azure/cosmos/src/plugins/Plugin.ts"],"sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport type { DiagnosticNodeInternal } from \"../diagnostics/DiagnosticNodeInternal\";\nimport type { RequestContext } from \"../request/RequestContext\";\nimport type { Response } from \"../request/Response\";\n\n/**\n * Used to specify which type of events to execute this plug in on.\n *\n * @hidden\n */\nexport enum PluginOn {\n  /**\n   * Will be executed per network request\n   */\n  request = \"request\",\n  /**\n   * Will be executed per API operation\n   */\n  operation = \"operation\",\n}\n\n/**\n * Specifies which event to run for the specified plugin\n *\n * @hidden\n */\nexport interface PluginConfig {\n  /**\n   * The event to run the plugin on\n   */\n  on: keyof typeof PluginOn;\n  /**\n   * The plugin to run\n   */\n  plugin: Plugin<any>;\n}\n\n/**\n * Plugins allow you to customize the behavior of the SDk with additional logging, retry, or additional functionality.\n *\n * A plugin is a function which returns a `Promise<Response<T>>`, and is passed a RequestContext and Next object.\n *\n * Next is a function which takes in requestContext returns a promise. You must await/then that promise which will contain the response from further plugins,\n * allowing you to log those results or handle errors.\n *\n * RequestContext is an object which controls what operation is happening, against which endpoint, and more. Modifying this and passing it along via next is how\n * you modify future SDK behavior.\n *\n * @hidden\n */\nexport type Plugin<T> = (\n  context: RequestContext,\n  diagnosticNode: DiagnosticNodeInternal,\n  next: Next<T>,\n) => Promise<Response<T>>;\n\n/**\n * Next is a function which takes in requestContext returns a promise. You must await/then that promise which will contain the response from further plugins,\n * allowing you to log those results or handle errors.\n * @hidden\n */\nexport type Next<T> = (context: RequestContext) => Promise<Response<T>>;\n\n/**\n * @internal\n */\nexport async function executePlugins(\n  diagnosticNode: DiagnosticNodeInternal,\n  requestContext: RequestContext,\n  next: Plugin<any>,\n  on: PluginOn,\n): Promise<Response<any>> {\n  if (!requestContext.plugins) {\n    return next(requestContext, diagnosticNode, undefined);\n  }\n  let level = 0;\n  const _: Next<any> = (inner: RequestContext): Promise<Response<any>> => {\n    if (++level >= inner.plugins.length) {\n      return next(requestContext, diagnosticNode, undefined);\n    } else if (inner.plugins[level].on !== on) {\n      return _(requestContext);\n    } else {\n      return inner.plugins[level].plugin(inner, diagnosticNode, _);\n    }\n  };\n  if (requestContext.plugins[level].on !== on) {\n    return _(requestContext);\n  } else {\n    return requestContext.plugins[level].plugin(requestContext, diagnosticNode, _);\n  }\n}\n"],"mappings":"AAMA;;;;;AAKA,WAAYA,QASX;AATD,WAAYA,QAAQ;EAClB;;;EAGAA,QAAA,uBAAmB;EACnB;;;EAGAA,QAAA,2BAAuB;AACzB,CAAC,EATWA,QAAQ,KAARA,QAAQ;AAqDpB;;;AAGA,OAAO,eAAeC,cAAcA,CAClCC,cAAsC,EACtCC,cAA8B,EAC9BC,IAAiB,EACjBC,EAAY;EAEZ,IAAI,CAACF,cAAc,CAACG,OAAO,EAAE;IAC3B,OAAOF,IAAI,CAACD,cAAc,EAAED,cAAc,EAAEK,SAAS,CAAC;EACxD;EACA,IAAIC,KAAK,GAAG,CAAC;EACb,MAAMC,CAAC,GAAeC,KAAqB,IAA4B;IACrE,IAAI,EAAEF,KAAK,IAAIE,KAAK,CAACJ,OAAO,CAACK,MAAM,EAAE;MACnC,OAAOP,IAAI,CAACD,cAAc,EAAED,cAAc,EAAEK,SAAS,CAAC;IACxD,CAAC,MAAM,IAAIG,KAAK,CAACJ,OAAO,CAACE,KAAK,CAAC,CAACH,EAAE,KAAKA,EAAE,EAAE;MACzC,OAAOI,CAAC,CAACN,cAAc,CAAC;IAC1B,CAAC,MAAM;MACL,OAAOO,KAAK,CAACJ,OAAO,CAACE,KAAK,CAAC,CAACI,MAAM,CAACF,KAAK,EAAER,cAAc,EAAEO,CAAC,CAAC;IAC9D;EACF,CAAC;EACD,IAAIN,cAAc,CAACG,OAAO,CAACE,KAAK,CAAC,CAACH,EAAE,KAAKA,EAAE,EAAE;IAC3C,OAAOI,CAAC,CAACN,cAAc,CAAC;EAC1B,CAAC,MAAM;IACL,OAAOA,cAAc,CAACG,OAAO,CAACE,KAAK,CAAC,CAACI,MAAM,CAACT,cAAc,EAAED,cAAc,EAAEO,CAAC,CAAC;EAChF;AACF","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}