{"ast":null,"code":"// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport { generateHeaders } from \"./utils/headers\";\nimport { Constants, getResourceIdFromPath, ResourceType, trimSlashFromLeftAndRight } from \"./common\";\n/**\n * @hidden\n */\nexport async function setAuthorizationHeader(clientOptions, verb, path, resourceId, resourceType, headers) {\n  if (clientOptions.permissionFeed) {\n    clientOptions.resourceTokens = {};\n    for (const permission of clientOptions.permissionFeed) {\n      const id = getResourceIdFromPath(permission.resource);\n      if (!id) {\n        throw new Error(`authorization error: ${id} \\\n                          is an invalid resourceId in permissionFeed`);\n      }\n      clientOptions.resourceTokens[id] = permission._token; // TODO: any\n    }\n  }\n  if (clientOptions.key) {\n    await setAuthorizationTokenHeaderUsingMasterKey(verb, resourceId, resourceType, headers, clientOptions.key);\n  } else if (clientOptions.resourceTokens) {\n    headers[Constants.HttpHeaders.Authorization] = encodeURIComponent(getAuthorizationTokenUsingResourceTokens(clientOptions.resourceTokens, path, resourceId));\n  } else if (clientOptions.tokenProvider) {\n    headers[Constants.HttpHeaders.Authorization] = encodeURIComponent(await clientOptions.tokenProvider({\n      verb,\n      path,\n      resourceId,\n      resourceType,\n      headers\n    }));\n  }\n}\n/**\n * The default function for setting header token using the masterKey\n * @hidden\n */\nexport async function setAuthorizationTokenHeaderUsingMasterKey(verb, resourceId, resourceType, headers, masterKey) {\n  // TODO This should live in cosmos-sign\n  if (resourceType === ResourceType.offer) {\n    resourceId = resourceId && resourceId.toLowerCase();\n  }\n  headers = Object.assign(headers, await generateHeaders(masterKey, verb, resourceType, resourceId));\n}\n/**\n * @hidden\n */\n// TODO: Resource tokens\nexport function getAuthorizationTokenUsingResourceTokens(resourceTokens, path, resourceId) {\n  if (resourceTokens && Object.keys(resourceTokens).length > 0) {\n    // For database account access(through getDatabaseAccount API), path and resourceId are \"\",\n    // so in this case we return the first token to be used for creating the auth header as the\n    // service will accept any token in this case\n    if (!path && !resourceId) {\n      return resourceTokens[Object.keys(resourceTokens)[0]];\n    }\n    // If we have exact resource token for the path use it\n    if (resourceId && resourceTokens[resourceId]) {\n      return resourceTokens[resourceId];\n    }\n    // minimum valid path /dbs\n    if (!path || path.length < 4) {\n      // TODO: This should throw an error\n      return null;\n    }\n    path = trimSlashFromLeftAndRight(path);\n    const pathSegments = path && path.split(\"/\") || [];\n    // Item path\n    if (pathSegments.length === 6) {\n      // Look for a container token matching the item path\n      const containerPath = pathSegments.slice(0, 4).map(decodeURIComponent).join(\"/\");\n      if (resourceTokens[containerPath]) {\n        return resourceTokens[containerPath];\n      }\n    }\n    // TODO remove in v4: This is legacy behavior that lets someone use a resource token pointing ONLY at an ID\n    // It was used when _rid was exposed by the SDK, but now that we are using user provided ids it is not needed\n    // However removing it now would be a breaking change\n    // if it's an incomplete path like /dbs/db1/colls/, start from the parent resource\n    let index = pathSegments.length % 2 === 0 ? pathSegments.length - 1 : pathSegments.length - 2;\n    for (; index > 0; index -= 2) {\n      const id = decodeURI(pathSegments[index]);\n      if (resourceTokens[id]) {\n        return resourceTokens[id];\n      }\n    }\n  }\n  // TODO: This should throw an error\n  return null;\n}","map":{"version":3,"names":["generateHeaders","Constants","getResourceIdFromPath","ResourceType","trimSlashFromLeftAndRight","setAuthorizationHeader","clientOptions","verb","path","resourceId","resourceType","headers","permissionFeed","resourceTokens","permission","id","resource","Error","_token","key","setAuthorizationTokenHeaderUsingMasterKey","HttpHeaders","Authorization","encodeURIComponent","getAuthorizationTokenUsingResourceTokens","tokenProvider","masterKey","offer","toLowerCase","Object","assign","keys","length","pathSegments","split","containerPath","slice","map","decodeURIComponent","join","index","decodeURI"],"sources":["/Users/ajitpawar/microsoft/bap/POCs/Scenario_checker_for_maker/mcs-scenario-checker-for-maker/node_modules/@azure/cosmos/src/auth.ts"],"sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport { generateHeaders } from \"./utils/headers\";\nimport type { HTTPMethod } from \"./common\";\nimport {\n  Constants,\n  getResourceIdFromPath,\n  ResourceType,\n  trimSlashFromLeftAndRight,\n} from \"./common\";\nimport type { CosmosClientOptions } from \"./CosmosClientOptions\";\nimport type { CosmosHeaders } from \"./queryExecutionContext\";\n\n/** @hidden */\nexport interface RequestInfo {\n  verb: HTTPMethod;\n  path: string;\n  resourceId: string;\n  resourceType: ResourceType;\n  headers: CosmosHeaders;\n}\n\nexport type TokenProvider = (requestInfo: RequestInfo) => Promise<string>;\n\n/**\n * @hidden\n */\nexport async function setAuthorizationHeader(\n  clientOptions: CosmosClientOptions,\n  verb: HTTPMethod,\n  path: string,\n  resourceId: string,\n  resourceType: ResourceType,\n  headers: CosmosHeaders,\n): Promise<void> {\n  if (clientOptions.permissionFeed) {\n    clientOptions.resourceTokens = {};\n    for (const permission of clientOptions.permissionFeed) {\n      const id = getResourceIdFromPath(permission.resource);\n      if (!id) {\n        throw new Error(`authorization error: ${id} \\\n                          is an invalid resourceId in permissionFeed`);\n      }\n\n      clientOptions.resourceTokens[id] = (permission as any)._token; // TODO: any\n    }\n  }\n\n  if (clientOptions.key) {\n    await setAuthorizationTokenHeaderUsingMasterKey(\n      verb,\n      resourceId,\n      resourceType,\n      headers,\n      clientOptions.key,\n    );\n  } else if (clientOptions.resourceTokens) {\n    headers[Constants.HttpHeaders.Authorization] = encodeURIComponent(\n      getAuthorizationTokenUsingResourceTokens(clientOptions.resourceTokens, path, resourceId),\n    );\n  } else if (clientOptions.tokenProvider) {\n    headers[Constants.HttpHeaders.Authorization] = encodeURIComponent(\n      await clientOptions.tokenProvider({ verb, path, resourceId, resourceType, headers }),\n    );\n  }\n}\n\n/**\n * The default function for setting header token using the masterKey\n * @hidden\n */\nexport async function setAuthorizationTokenHeaderUsingMasterKey(\n  verb: HTTPMethod,\n  resourceId: string,\n  resourceType: ResourceType,\n  headers: CosmosHeaders,\n  masterKey: string,\n): Promise<void> {\n  // TODO This should live in cosmos-sign\n  if (resourceType === ResourceType.offer) {\n    resourceId = resourceId && resourceId.toLowerCase();\n  }\n  headers = Object.assign(\n    headers,\n    await generateHeaders(masterKey, verb, resourceType, resourceId),\n  );\n}\n\n/**\n * @hidden\n */\n// TODO: Resource tokens\nexport function getAuthorizationTokenUsingResourceTokens(\n  resourceTokens: { [resourceId: string]: string },\n  path: string,\n  resourceId: string,\n): string {\n  if (resourceTokens && Object.keys(resourceTokens).length > 0) {\n    // For database account access(through getDatabaseAccount API), path and resourceId are \"\",\n    // so in this case we return the first token to be used for creating the auth header as the\n    // service will accept any token in this case\n    if (!path && !resourceId) {\n      return resourceTokens[Object.keys(resourceTokens)[0]];\n    }\n\n    // If we have exact resource token for the path use it\n    if (resourceId && resourceTokens[resourceId]) {\n      return resourceTokens[resourceId];\n    }\n\n    // minimum valid path /dbs\n    if (!path || path.length < 4) {\n      // TODO: This should throw an error\n      return null;\n    }\n\n    path = trimSlashFromLeftAndRight(path);\n    const pathSegments = (path && path.split(\"/\")) || [];\n\n    // Item path\n    if (pathSegments.length === 6) {\n      // Look for a container token matching the item path\n      const containerPath = pathSegments.slice(0, 4).map(decodeURIComponent).join(\"/\");\n      if (resourceTokens[containerPath]) {\n        return resourceTokens[containerPath];\n      }\n    }\n\n    // TODO remove in v4: This is legacy behavior that lets someone use a resource token pointing ONLY at an ID\n    // It was used when _rid was exposed by the SDK, but now that we are using user provided ids it is not needed\n    // However removing it now would be a breaking change\n    // if it's an incomplete path like /dbs/db1/colls/, start from the parent resource\n    let index = pathSegments.length % 2 === 0 ? pathSegments.length - 1 : pathSegments.length - 2;\n    for (; index > 0; index -= 2) {\n      const id = decodeURI(pathSegments[index]);\n      if (resourceTokens[id]) {\n        return resourceTokens[id];\n      }\n    }\n  }\n\n  // TODO: This should throw an error\n  return null;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}