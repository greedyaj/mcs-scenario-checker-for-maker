{"ast":null,"code":"// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport { MetadataLookUpType } from \"../CosmosDiagnostics\";\nimport { getIdFromLink } from \"../common/helper\";\nimport { withMetadataDiagnostics } from \"../utils/diagnostics\";\nimport { createCompleteRoutingMap } from \"./CollectionRoutingMapFactory\";\n/** @hidden */\nexport class PartitionKeyRangeCache {\n  constructor(clientContext) {\n    this.clientContext = clientContext;\n    this.collectionRoutingMapByCollectionId = {};\n  }\n  /**\n   * Finds or Instantiates the requested Collection Routing Map\n   * @param collectionLink - Requested collectionLink\n   * @hidden\n   */\n  async onCollectionRoutingMap(collectionLink, diagnosticNode, forceRefresh = false) {\n    const collectionId = getIdFromLink(collectionLink);\n    if (this.collectionRoutingMapByCollectionId[collectionId] === undefined || forceRefresh) {\n      this.collectionRoutingMapByCollectionId[collectionId] = this.requestCollectionRoutingMap(collectionLink, diagnosticNode);\n    }\n    return this.collectionRoutingMapByCollectionId[collectionId];\n  }\n  /**\n   * Given the query ranges and a collection, invokes the callback on the list of overlapping partition key ranges\n   * @hidden\n   */\n  async getOverlappingRanges(collectionLink, queryRange, diagnosticNode, forceRefresh = false) {\n    const crm = await this.onCollectionRoutingMap(collectionLink, diagnosticNode, forceRefresh);\n    return crm.getOverlappingRanges(queryRange);\n  }\n  async requestCollectionRoutingMap(collectionLink, diagnosticNode) {\n    const {\n      resources\n    } = await withMetadataDiagnostics(async metadataDiagnostics => {\n      return this.clientContext.queryPartitionKeyRanges(collectionLink).fetchAllInternal(metadataDiagnostics);\n    }, diagnosticNode, MetadataLookUpType.PartitionKeyRangeLookUp);\n    return createCompleteRoutingMap(resources.map(r => [r, true]));\n  }\n}","map":{"version":3,"names":["MetadataLookUpType","getIdFromLink","withMetadataDiagnostics","createCompleteRoutingMap","PartitionKeyRangeCache","constructor","clientContext","collectionRoutingMapByCollectionId","onCollectionRoutingMap","collectionLink","diagnosticNode","forceRefresh","collectionId","undefined","requestCollectionRoutingMap","getOverlappingRanges","queryRange","crm","resources","metadataDiagnostics","queryPartitionKeyRanges","fetchAllInternal","PartitionKeyRangeLookUp","map","r"],"sources":["/Users/ajitpawar/microsoft/bap/POCs/Scenario_checker_for_maker/mcs-scenario-checker-for-maker/node_modules/@azure/cosmos/src/routing/partitionKeyRangeCache.ts"],"sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport { MetadataLookUpType } from \"../CosmosDiagnostics\";\nimport type { PartitionKeyRange } from \"../client/Container/PartitionKeyRange\";\nimport type { ClientContext } from \"../ClientContext\";\nimport { getIdFromLink } from \"../common/helper\";\nimport type { DiagnosticNodeInternal } from \"../diagnostics/DiagnosticNodeInternal\";\nimport { withMetadataDiagnostics } from \"../utils/diagnostics\";\nimport { createCompleteRoutingMap } from \"./CollectionRoutingMapFactory\";\nimport type { InMemoryCollectionRoutingMap } from \"./inMemoryCollectionRoutingMap\";\nimport type { QueryRange } from \"./QueryRange\";\n\n/** @hidden */\nexport class PartitionKeyRangeCache {\n  private collectionRoutingMapByCollectionId: {\n    [key: string]: Promise<InMemoryCollectionRoutingMap>;\n  };\n\n  constructor(private clientContext: ClientContext) {\n    this.collectionRoutingMapByCollectionId = {};\n  }\n  /**\n   * Finds or Instantiates the requested Collection Routing Map\n   * @param collectionLink - Requested collectionLink\n   * @hidden\n   */\n  public async onCollectionRoutingMap(\n    collectionLink: string,\n    diagnosticNode: DiagnosticNodeInternal,\n    forceRefresh: boolean = false,\n  ): Promise<InMemoryCollectionRoutingMap> {\n    const collectionId = getIdFromLink(collectionLink);\n    if (this.collectionRoutingMapByCollectionId[collectionId] === undefined || forceRefresh) {\n      this.collectionRoutingMapByCollectionId[collectionId] = this.requestCollectionRoutingMap(\n        collectionLink,\n        diagnosticNode,\n      );\n    }\n    return this.collectionRoutingMapByCollectionId[collectionId];\n  }\n\n  /**\n   * Given the query ranges and a collection, invokes the callback on the list of overlapping partition key ranges\n   * @hidden\n   */\n  public async getOverlappingRanges(\n    collectionLink: string,\n    queryRange: QueryRange,\n    diagnosticNode: DiagnosticNodeInternal,\n    forceRefresh: boolean = false,\n  ): Promise<PartitionKeyRange[]> {\n    const crm = await this.onCollectionRoutingMap(collectionLink, diagnosticNode, forceRefresh);\n    return crm.getOverlappingRanges(queryRange);\n  }\n\n  private async requestCollectionRoutingMap(\n    collectionLink: string,\n    diagnosticNode: DiagnosticNodeInternal,\n  ): Promise<InMemoryCollectionRoutingMap> {\n    const { resources } = await withMetadataDiagnostics(\n      async (metadataDiagnostics: DiagnosticNodeInternal) => {\n        return this.clientContext\n          .queryPartitionKeyRanges(collectionLink)\n          .fetchAllInternal(metadataDiagnostics);\n      },\n      diagnosticNode,\n      MetadataLookUpType.PartitionKeyRangeLookUp,\n    );\n    return createCompleteRoutingMap(resources.map((r) => [r, true]));\n  }\n}\n"],"mappings":"AAAA;AACA;AACA,SAASA,kBAAkB,QAAQ,sBAAsB;AAGzD,SAASC,aAAa,QAAQ,kBAAkB;AAEhD,SAASC,uBAAuB,QAAQ,sBAAsB;AAC9D,SAASC,wBAAwB,QAAQ,+BAA+B;AAIxE;AACA,OAAM,MAAOC,sBAAsB;EAKjCC,YAAoBC,aAA4B;IAA5B,KAAAA,aAAa,GAAbA,aAAa;IAC/B,IAAI,CAACC,kCAAkC,GAAG,EAAE;EAC9C;EACA;;;;;EAKO,MAAMC,sBAAsBA,CACjCC,cAAsB,EACtBC,cAAsC,EACtCC,YAAA,GAAwB,KAAK;IAE7B,MAAMC,YAAY,GAAGX,aAAa,CAACQ,cAAc,CAAC;IAClD,IAAI,IAAI,CAACF,kCAAkC,CAACK,YAAY,CAAC,KAAKC,SAAS,IAAIF,YAAY,EAAE;MACvF,IAAI,CAACJ,kCAAkC,CAACK,YAAY,CAAC,GAAG,IAAI,CAACE,2BAA2B,CACtFL,cAAc,EACdC,cAAc,CACf;IACH;IACA,OAAO,IAAI,CAACH,kCAAkC,CAACK,YAAY,CAAC;EAC9D;EAEA;;;;EAIO,MAAMG,oBAAoBA,CAC/BN,cAAsB,EACtBO,UAAsB,EACtBN,cAAsC,EACtCC,YAAA,GAAwB,KAAK;IAE7B,MAAMM,GAAG,GAAG,MAAM,IAAI,CAACT,sBAAsB,CAACC,cAAc,EAAEC,cAAc,EAAEC,YAAY,CAAC;IAC3F,OAAOM,GAAG,CAACF,oBAAoB,CAACC,UAAU,CAAC;EAC7C;EAEQ,MAAMF,2BAA2BA,CACvCL,cAAsB,EACtBC,cAAsC;IAEtC,MAAM;MAAEQ;IAAS,CAAE,GAAG,MAAMhB,uBAAuB,CACjD,MAAOiB,mBAA2C,IAAI;MACpD,OAAO,IAAI,CAACb,aAAa,CACtBc,uBAAuB,CAACX,cAAc,CAAC,CACvCY,gBAAgB,CAACF,mBAAmB,CAAC;IAC1C,CAAC,EACDT,cAAc,EACdV,kBAAkB,CAACsB,uBAAuB,CAC3C;IACD,OAAOnB,wBAAwB,CAACe,SAAS,CAACK,GAAG,CAAEC,CAAC,IAAK,CAACA,CAAC,EAAE,IAAI,CAAC,CAAC,CAAC;EAClE","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}