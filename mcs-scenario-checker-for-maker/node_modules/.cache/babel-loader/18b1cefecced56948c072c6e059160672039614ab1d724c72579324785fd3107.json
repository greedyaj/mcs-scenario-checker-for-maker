{"ast":null,"code":"import { hashObject } from \"../../utils/hashObject\";\nimport { createAggregator } from \"../Aggregators\";\nimport { getInitialHeader, mergeHeaders } from \"../headerUtils\";\nimport { emptyGroup, extractAggregateResult } from \"./emptyGroup\";\n/** @hidden */\nexport class GroupByValueEndpointComponent {\n  constructor(executionContext, queryInfo) {\n    this.executionContext = executionContext;\n    this.queryInfo = queryInfo;\n    this.aggregators = new Map();\n    this.aggregateResultArray = [];\n    this.completed = false;\n    // VALUE queries will only every have a single grouping\n    this.aggregateType = this.queryInfo.aggregates[0];\n  }\n  async nextItem(diagnosticNode) {\n    // Start returning results if we have processed a full results set\n    if (this.aggregateResultArray.length > 0) {\n      return {\n        result: this.aggregateResultArray.pop(),\n        headers: getInitialHeader()\n      };\n    }\n    if (this.completed) {\n      return {\n        result: undefined,\n        headers: getInitialHeader()\n      };\n    }\n    const aggregateHeaders = getInitialHeader();\n    while (this.executionContext.hasMoreResults()) {\n      // Grab the next result\n      const {\n        result,\n        headers\n      } = await this.executionContext.nextItem(diagnosticNode);\n      mergeHeaders(aggregateHeaders, headers);\n      // If it exists, process it via aggregators\n      if (result) {\n        let grouping = emptyGroup;\n        let payload = result;\n        if (result.groupByItems) {\n          // If the query contains a GROUP BY clause, it will have a payload property and groupByItems\n          payload = result.payload;\n          grouping = await hashObject(result.groupByItems);\n        }\n        const aggregator = this.aggregators.get(grouping);\n        if (!aggregator) {\n          // This is the first time we have seen a grouping so create a new aggregator\n          this.aggregators.set(grouping, createAggregator(this.aggregateType));\n        }\n        if (this.aggregateType) {\n          const aggregateResult = extractAggregateResult(payload[0]);\n          // if aggregate result is null, we need to short circuit aggregation and return undefined\n          if (aggregateResult === null) {\n            this.completed = true;\n          }\n          this.aggregators.get(grouping).aggregate(aggregateResult);\n        } else {\n          // Queries with no aggregates pass the payload directly to the aggregator\n          // Example: SELECT VALUE c.team FROM c GROUP BY c.team\n          this.aggregators.get(grouping).aggregate(payload);\n        }\n      }\n    }\n    // We bail early since we got an undefined result back `[{}]`\n    if (this.completed) {\n      return {\n        result: undefined,\n        headers: aggregateHeaders\n      };\n    }\n    // If no results are left in the underlying execution context, convert our aggregate results to an array\n    for (const aggregator of this.aggregators.values()) {\n      this.aggregateResultArray.push(aggregator.getResult());\n    }\n    this.completed = true;\n    return {\n      result: this.aggregateResultArray.pop(),\n      headers: aggregateHeaders\n    };\n  }\n  hasMoreResults() {\n    return this.executionContext.hasMoreResults() || this.aggregateResultArray.length > 0;\n  }\n}","map":{"version":3,"names":["hashObject","createAggregator","getInitialHeader","mergeHeaders","emptyGroup","extractAggregateResult","GroupByValueEndpointComponent","constructor","executionContext","queryInfo","aggregators","Map","aggregateResultArray","completed","aggregateType","aggregates","nextItem","diagnosticNode","length","result","pop","headers","undefined","aggregateHeaders","hasMoreResults","grouping","payload","groupByItems","aggregator","get","set","aggregateResult","aggregate","values","push","getResult"],"sources":["/Users/ajitpawar/microsoft/bap/POCs/Scenario_checker_for_maker/mcs-scenario-checker-for-maker/node_modules/@azure/cosmos/src/queryExecutionContext/EndpointComponent/GroupByValueEndpointComponent.ts"],"sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport type { Response } from \"../../request\";\nimport type { ExecutionContext } from \"../ExecutionContext\";\nimport type { CosmosHeaders } from \"../CosmosHeaders\";\nimport type { AggregateType, QueryInfo } from \"../../request/ErrorResponse\";\nimport { hashObject } from \"../../utils/hashObject\";\nimport type { Aggregator } from \"../Aggregators\";\nimport { createAggregator } from \"../Aggregators\";\nimport { getInitialHeader, mergeHeaders } from \"../headerUtils\";\nimport { emptyGroup, extractAggregateResult } from \"./emptyGroup\";\nimport type { DiagnosticNodeInternal } from \"../../diagnostics/DiagnosticNodeInternal\";\n\ninterface GroupByResponse {\n  result: GroupByResult;\n  headers: CosmosHeaders;\n}\n\ninterface GroupByResult {\n  groupByItems: any[];\n  payload: any;\n}\n\n/** @hidden */\nexport class GroupByValueEndpointComponent implements ExecutionContext {\n  private readonly aggregators: Map<string, Aggregator> = new Map();\n  private readonly aggregateResultArray: any[] = [];\n  private aggregateType: AggregateType;\n  private completed: boolean = false;\n\n  constructor(\n    private executionContext: ExecutionContext,\n    private queryInfo: QueryInfo,\n  ) {\n    // VALUE queries will only every have a single grouping\n    this.aggregateType = this.queryInfo.aggregates[0];\n  }\n\n  public async nextItem(diagnosticNode: DiagnosticNodeInternal): Promise<Response<any>> {\n    // Start returning results if we have processed a full results set\n    if (this.aggregateResultArray.length > 0) {\n      return {\n        result: this.aggregateResultArray.pop(),\n        headers: getInitialHeader(),\n      };\n    }\n\n    if (this.completed) {\n      return {\n        result: undefined,\n        headers: getInitialHeader(),\n      };\n    }\n\n    const aggregateHeaders = getInitialHeader();\n\n    while (this.executionContext.hasMoreResults()) {\n      // Grab the next result\n      const { result, headers } = (await this.executionContext.nextItem(\n        diagnosticNode,\n      )) as GroupByResponse;\n      mergeHeaders(aggregateHeaders, headers);\n\n      // If it exists, process it via aggregators\n      if (result) {\n        let grouping: string = emptyGroup;\n        let payload: any = result;\n        if (result.groupByItems) {\n          // If the query contains a GROUP BY clause, it will have a payload property and groupByItems\n          payload = result.payload;\n          grouping = await hashObject(result.groupByItems);\n        }\n\n        const aggregator = this.aggregators.get(grouping);\n        if (!aggregator) {\n          // This is the first time we have seen a grouping so create a new aggregator\n          this.aggregators.set(grouping, createAggregator(this.aggregateType));\n        }\n\n        if (this.aggregateType) {\n          const aggregateResult = extractAggregateResult(payload[0]);\n          // if aggregate result is null, we need to short circuit aggregation and return undefined\n          if (aggregateResult === null) {\n            this.completed = true;\n          }\n          this.aggregators.get(grouping).aggregate(aggregateResult);\n        } else {\n          // Queries with no aggregates pass the payload directly to the aggregator\n          // Example: SELECT VALUE c.team FROM c GROUP BY c.team\n          this.aggregators.get(grouping).aggregate(payload);\n        }\n      }\n    }\n\n    // We bail early since we got an undefined result back `[{}]`\n    if (this.completed) {\n      return {\n        result: undefined,\n        headers: aggregateHeaders,\n      };\n    }\n    // If no results are left in the underlying execution context, convert our aggregate results to an array\n    for (const aggregator of this.aggregators.values()) {\n      this.aggregateResultArray.push(aggregator.getResult());\n    }\n    this.completed = true;\n    return {\n      result: this.aggregateResultArray.pop(),\n      headers: aggregateHeaders,\n    };\n  }\n\n  public hasMoreResults(): boolean {\n    return this.executionContext.hasMoreResults() || this.aggregateResultArray.length > 0;\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}