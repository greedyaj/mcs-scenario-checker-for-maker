{"ast":null,"code":"import { getInitialHeader } from \"../headerUtils\";\nimport { hashObject } from \"../../utils/hashObject\";\nimport { FixedSizePriorityQueue } from \"../../utils/fixedSizePriorityQueue\";\nimport { NonStreamingOrderByMap } from \"../../utils/nonStreamingOrderByMap\";\nimport { OrderByComparator } from \"../orderByComparator\";\n/**\n * @hidden\n * Represents an endpoint in handling an non-streaming order by distinct query.\n */\nexport class NonStreamingOrderByDistinctEndpointComponent {\n  constructor(executionContext, queryInfo, priorityQueueBufferSize, emitRawOrderByPayload = false) {\n    this.executionContext = executionContext;\n    this.queryInfo = queryInfo;\n    this.priorityQueueBufferSize = priorityQueueBufferSize;\n    this.emitRawOrderByPayload = emitRawOrderByPayload;\n    /**\n     * Flag to determine if all results are fetched from backend and results can be returned.\n     */\n    this.isCompleted = false;\n    this.sortOrders = this.queryInfo.orderBy;\n    const comparator = new OrderByComparator(this.sortOrders);\n    this.aggregateMap = new NonStreamingOrderByMap((a, b) => {\n      return comparator.compareItems(a, b);\n    });\n    this.nonStreamingOrderByPQ = new FixedSizePriorityQueue((a, b) => {\n      return comparator.compareItems(b, a);\n    }, this.priorityQueueBufferSize);\n  }\n  async nextItem(diagnosticNode) {\n    let resHeaders = getInitialHeader();\n    // if size is 0, just return undefined to signal to more results. Valid if query is TOP 0 or LIMIT 0\n    if (this.priorityQueueBufferSize <= 0) {\n      return {\n        result: undefined,\n        headers: resHeaders\n      };\n    }\n    // If there are more results in backend, keep filling map.\n    if (this.executionContext.hasMoreResults()) {\n      // Grab the next result\n      const {\n        result,\n        headers\n      } = await this.executionContext.nextItem(diagnosticNode);\n      resHeaders = headers;\n      if (result) {\n        // make hash of result object and update the map if required.\n        const key = await hashObject(result === null || result === void 0 ? void 0 : result.payload);\n        this.aggregateMap.set(key, result);\n      }\n      // return {} to signal that there are more results to fetch.\n      if (this.executionContext.hasMoreResults()) {\n        return {\n          result: {},\n          headers: resHeaders\n        };\n      }\n    }\n    // If all results are fetched from backend, prepare final results\n    if (!this.executionContext.hasMoreResults() && !this.isCompleted) {\n      this.isCompleted = true;\n      await this.buildFinalResultArray();\n    }\n    // Return results from final array.\n    if (this.finalResultArray.length > 0) {\n      return {\n        result: this.finalResultArray.shift(),\n        headers: resHeaders\n      };\n    }\n    // Signal that there are no more results.\n    return {\n      result: undefined,\n      headers: resHeaders\n    };\n  }\n  /**\n   * Build final sorted result array from which responses will be served.\n   */\n  async buildFinalResultArray() {\n    var _a;\n    // Fetch all distinct values from the map and store in priority queue.\n    const allValues = this.aggregateMap.getAllValuesAndReset();\n    for (const value of allValues) {\n      this.nonStreamingOrderByPQ.enqueue(value);\n    }\n    // Compute the final result array size based on offset and limit.\n    const offSet = this.queryInfo.offset ? this.queryInfo.offset : 0;\n    const queueSize = this.nonStreamingOrderByPQ.size();\n    const finalArraySize = queueSize - offSet;\n    if (finalArraySize <= 0) {\n      this.finalResultArray = [];\n    } else {\n      this.finalResultArray = new Array(finalArraySize);\n      // Only keep the final result array size number of items in the final result array and discard the rest.\n      for (let count = finalArraySize - 1; count >= 0; count--) {\n        if (this.emitRawOrderByPayload) {\n          this.finalResultArray[count] = this.nonStreamingOrderByPQ.dequeue();\n        } else {\n          this.finalResultArray[count] = (_a = this.nonStreamingOrderByPQ.dequeue()) === null || _a === void 0 ? void 0 : _a.payload;\n        }\n      }\n    }\n  }\n  hasMoreResults() {\n    if (this.priorityQueueBufferSize === 0) return false;\n    return this.executionContext.hasMoreResults() || this.finalResultArray.length > 0;\n  }\n}","map":{"version":3,"names":["getInitialHeader","hashObject","FixedSizePriorityQueue","NonStreamingOrderByMap","OrderByComparator","NonStreamingOrderByDistinctEndpointComponent","constructor","executionContext","queryInfo","priorityQueueBufferSize","emitRawOrderByPayload","isCompleted","sortOrders","orderBy","comparator","aggregateMap","a","b","compareItems","nonStreamingOrderByPQ","nextItem","diagnosticNode","resHeaders","result","undefined","headers","hasMoreResults","key","payload","set","buildFinalResultArray","finalResultArray","length","shift","allValues","getAllValuesAndReset","value","enqueue","offSet","offset","queueSize","size","finalArraySize","Array","count","dequeue","_a"],"sources":["/Users/ajitpawar/microsoft/bap/POCs/Scenario_checker_for_maker/mcs-scenario-checker-for-maker/node_modules/@azure/cosmos/src/queryExecutionContext/EndpointComponent/NonStreamingOrderByDistinctEndpointComponent.ts"],"sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport type { QueryInfo, Response } from \"../../request\";\nimport type { ExecutionContext } from \"../ExecutionContext\";\nimport { getInitialHeader } from \"../headerUtils\";\nimport type { DiagnosticNodeInternal } from \"../../diagnostics/DiagnosticNodeInternal\";\nimport { hashObject } from \"../../utils/hashObject\";\nimport type { NonStreamingOrderByResult } from \"../nonStreamingOrderByResult\";\nimport type { NonStreamingOrderByResponse } from \"../nonStreamingOrderByResponse\";\nimport { FixedSizePriorityQueue } from \"../../utils/fixedSizePriorityQueue\";\nimport { NonStreamingOrderByMap } from \"../../utils/nonStreamingOrderByMap\";\nimport { OrderByComparator } from \"../orderByComparator\";\n\n/**\n * @hidden\n * Represents an endpoint in handling an non-streaming order by distinct query.\n */\nexport class NonStreamingOrderByDistinctEndpointComponent implements ExecutionContext {\n  /**\n   * A Map that holds the distinct values of the items before storing in priority queue.\n   */\n  private aggregateMap: NonStreamingOrderByMap<NonStreamingOrderByResult>;\n  /**\n   * A priority queue to compute the final sorted results.\n   */\n  private nonStreamingOrderByPQ: FixedSizePriorityQueue<NonStreamingOrderByResult>;\n  /**\n   * Array to store the final sorted results.\n   */\n  private finalResultArray: NonStreamingOrderByResult[];\n\n  private sortOrders: string[];\n  /**\n   * Flag to determine if all results are fetched from backend and results can be returned.\n   */\n  private isCompleted: boolean = false;\n\n  constructor(\n    private executionContext: ExecutionContext,\n    private queryInfo: QueryInfo,\n    private priorityQueueBufferSize: number,\n    private emitRawOrderByPayload: boolean = false,\n  ) {\n    this.sortOrders = this.queryInfo.orderBy;\n    const comparator = new OrderByComparator(this.sortOrders);\n    this.aggregateMap = new NonStreamingOrderByMap<NonStreamingOrderByResult>(\n      (a: NonStreamingOrderByResult, b: NonStreamingOrderByResult) => {\n        return comparator.compareItems(a, b);\n      },\n    );\n    this.nonStreamingOrderByPQ = new FixedSizePriorityQueue<NonStreamingOrderByResult>(\n      (a: NonStreamingOrderByResult, b: NonStreamingOrderByResult) => {\n        return comparator.compareItems(b, a);\n      },\n      this.priorityQueueBufferSize,\n    );\n  }\n\n  public async nextItem(diagnosticNode: DiagnosticNodeInternal): Promise<Response<any>> {\n    let resHeaders = getInitialHeader();\n    // if size is 0, just return undefined to signal to more results. Valid if query is TOP 0 or LIMIT 0\n    if (this.priorityQueueBufferSize <= 0) {\n      return {\n        result: undefined,\n        headers: resHeaders,\n      };\n    }\n\n    // If there are more results in backend, keep filling map.\n    if (this.executionContext.hasMoreResults()) {\n      // Grab the next result\n      const { result, headers } = (await this.executionContext.nextItem(\n        diagnosticNode,\n      )) as NonStreamingOrderByResponse;\n      resHeaders = headers;\n      if (result) {\n        // make hash of result object and update the map if required.\n        const key = await hashObject(result?.payload);\n        this.aggregateMap.set(key, result);\n      }\n\n      // return {} to signal that there are more results to fetch.\n      if (this.executionContext.hasMoreResults()) {\n        return {\n          result: {},\n          headers: resHeaders,\n        };\n      }\n    }\n\n    // If all results are fetched from backend, prepare final results\n    if (!this.executionContext.hasMoreResults() && !this.isCompleted) {\n      this.isCompleted = true;\n      await this.buildFinalResultArray();\n    }\n\n    // Return results from final array.\n    if (this.finalResultArray.length > 0) {\n      return {\n        result: this.finalResultArray.shift(),\n        headers: resHeaders,\n      };\n    }\n    // Signal that there are no more results.\n    return {\n      result: undefined,\n      headers: resHeaders,\n    };\n  }\n\n  /**\n   * Build final sorted result array from which responses will be served.\n   */\n  private async buildFinalResultArray(): Promise<void> {\n    // Fetch all distinct values from the map and store in priority queue.\n    const allValues = this.aggregateMap.getAllValuesAndReset();\n    for (const value of allValues) {\n      this.nonStreamingOrderByPQ.enqueue(value);\n    }\n\n    // Compute the final result array size based on offset and limit.\n    const offSet = this.queryInfo.offset ? this.queryInfo.offset : 0;\n    const queueSize = this.nonStreamingOrderByPQ.size();\n    const finalArraySize = queueSize - offSet;\n\n    if (finalArraySize <= 0) {\n      this.finalResultArray = [];\n    } else {\n      this.finalResultArray = new Array(finalArraySize);\n      // Only keep the final result array size number of items in the final result array and discard the rest.\n      for (let count = finalArraySize - 1; count >= 0; count--) {\n        if (this.emitRawOrderByPayload) {\n          this.finalResultArray[count] = this.nonStreamingOrderByPQ.dequeue();\n        } else {\n          this.finalResultArray[count] = this.nonStreamingOrderByPQ.dequeue()?.payload;\n        }\n      }\n    }\n  }\n\n  public hasMoreResults(): boolean {\n    if (this.priorityQueueBufferSize === 0) return false;\n    return this.executionContext.hasMoreResults() || this.finalResultArray.length > 0;\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}