{"ast":null,"code":"import { createClientLogger } from \"@azure/logger\";\nimport { parsePath } from \"./common\";\nimport { convertToInternalPartitionKey, NonePartitionKeyLiteral, NullPartitionKeyLiteral } from \"./documents\";\nimport { DEFAULT_PARTITION_KEY_PATH } from \"./common/partitionKeys\";\nimport { readPartitionKeyDefinition } from \"./client/ClientUtils\";\nconst logger = createClientLogger(\"extractPartitionKey\");\n/**\n * Function to extract PartitionKey based on {@link PartitionKeyDefinition}\n * from an object.\n * Retuns\n * 1. PartitionKeyInternal[] if extraction is successful.\n * 2. undefined if either {@link partitionKeyDefinition} is not well formed\n * or an unsupported partitionkey type is encountered.\n * @hidden\n */\nexport function extractPartitionKeys(document, partitionKeyDefinition) {\n  if (partitionKeyDefinition && partitionKeyDefinition.paths && partitionKeyDefinition.paths.length > 0) {\n    if (partitionKeyDefinition.systemKey === true) {\n      return [];\n    }\n    if (partitionKeyDefinition.paths.length === 1 && partitionKeyDefinition.paths[0] === DEFAULT_PARTITION_KEY_PATH) {\n      return [extractPartitionKey(DEFAULT_PARTITION_KEY_PATH, document)];\n    }\n    const partitionKeys = [];\n    partitionKeyDefinition.paths.forEach(path => {\n      const obj = extractPartitionKey(path, document);\n      if (obj === undefined) {\n        logger.warning(\"Unsupported PartitionKey found.\");\n        return undefined;\n      }\n      partitionKeys.push(obj);\n    });\n    return partitionKeys;\n  }\n  logger.error(\"Unexpected Partition Key Definition Found.\");\n  return undefined;\n}\nfunction extractPartitionKey(path, obj) {\n  const pathParts = parsePath(path);\n  for (const part of pathParts) {\n    if (typeof obj === \"object\" && obj !== null && part in obj) {\n      obj = obj[part];\n    } else {\n      obj = undefined;\n      break;\n    }\n  }\n  if (typeof obj === \"string\" || typeof obj === \"number\" || typeof obj === \"boolean\") {\n    return obj;\n  } else if (obj === NullPartitionKeyLiteral) {\n    return NullPartitionKeyLiteral;\n  } else if (obj === undefined || JSON.stringify(obj) === JSON.stringify(NonePartitionKeyLiteral)) {\n    return NonePartitionKeyLiteral;\n  }\n  return undefined;\n}\n/**\n * @hidden\n */\nexport function undefinedPartitionKey(partitionKeyDefinition) {\n  if (partitionKeyDefinition === null || partitionKeyDefinition === void 0 ? void 0 : partitionKeyDefinition.systemKey) {\n    return [];\n  } else {\n    return partitionKeyDefinition === null || partitionKeyDefinition === void 0 ? void 0 : partitionKeyDefinition.paths.map(() => NonePartitionKeyLiteral);\n  }\n}\n/**\n * @hidden\n */\nexport async function setPartitionKeyIfUndefined(diagnosticNode, container, partitionKey) {\n  if (partitionKey === undefined) {\n    const partitionKeyDefinition = await readPartitionKeyDefinition(diagnosticNode, container);\n    partitionKey = undefinedPartitionKey(partitionKeyDefinition);\n  }\n  return convertToInternalPartitionKey(partitionKey);\n}","map":{"version":3,"names":["createClientLogger","parsePath","convertToInternalPartitionKey","NonePartitionKeyLiteral","NullPartitionKeyLiteral","DEFAULT_PARTITION_KEY_PATH","readPartitionKeyDefinition","logger","extractPartitionKeys","document","partitionKeyDefinition","paths","length","systemKey","extractPartitionKey","partitionKeys","forEach","path","obj","undefined","warning","push","error","pathParts","part","JSON","stringify","undefinedPartitionKey","map","setPartitionKeyIfUndefined","diagnosticNode","container","partitionKey"],"sources":["/Users/ajitpawar/microsoft/bap/POCs/Scenario_checker_for_maker/mcs-scenario-checker-for-maker/node_modules/@azure/cosmos/src/extractPartitionKey.ts"],"sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport type { AzureLogger } from \"@azure/logger\";\nimport { createClientLogger } from \"@azure/logger\";\nimport { parsePath } from \"./common\";\nimport type {\n  PartitionKey,\n  PartitionKeyDefinition,\n  PartitionKeyInternal,\n  PrimitivePartitionKeyValue,\n} from \"./documents\";\nimport {\n  convertToInternalPartitionKey,\n  NonePartitionKeyLiteral,\n  NullPartitionKeyLiteral,\n} from \"./documents\";\nimport { DEFAULT_PARTITION_KEY_PATH } from \"./common/partitionKeys\";\nimport type { Container } from \"./client\";\nimport { readPartitionKeyDefinition } from \"./client/ClientUtils\";\nimport type { DiagnosticNodeInternal } from \"./diagnostics/DiagnosticNodeInternal\";\n\nconst logger: AzureLogger = createClientLogger(\"extractPartitionKey\");\n\n/**\n * Function to extract PartitionKey based on {@link PartitionKeyDefinition}\n * from an object.\n * Retuns\n * 1. PartitionKeyInternal[] if extraction is successful.\n * 2. undefined if either {@link partitionKeyDefinition} is not well formed\n * or an unsupported partitionkey type is encountered.\n * @hidden\n */\nexport function extractPartitionKeys(\n  document: unknown,\n  partitionKeyDefinition?: PartitionKeyDefinition,\n): PartitionKeyInternal | undefined {\n  if (\n    partitionKeyDefinition &&\n    partitionKeyDefinition.paths &&\n    partitionKeyDefinition.paths.length > 0\n  ) {\n    if (partitionKeyDefinition.systemKey === true) {\n      return [];\n    }\n\n    if (\n      partitionKeyDefinition.paths.length === 1 &&\n      partitionKeyDefinition.paths[0] === DEFAULT_PARTITION_KEY_PATH\n    ) {\n      return [extractPartitionKey(DEFAULT_PARTITION_KEY_PATH, document)];\n    }\n\n    const partitionKeys: PrimitivePartitionKeyValue[] = [];\n    partitionKeyDefinition.paths.forEach((path: string) => {\n      const obj = extractPartitionKey(path, document);\n      if (obj === undefined) {\n        logger.warning(\"Unsupported PartitionKey found.\");\n        return undefined;\n      }\n      partitionKeys.push(obj);\n    });\n    return partitionKeys;\n  }\n  logger.error(\"Unexpected Partition Key Definition Found.\");\n  return undefined;\n}\n\nfunction extractPartitionKey(path: string, obj: unknown): any {\n  const pathParts: string[] = parsePath(path);\n  for (const part of pathParts) {\n    if (typeof obj === \"object\" && obj !== null && part in obj) {\n      obj = (obj as Record<string, unknown>)[part];\n    } else {\n      obj = undefined;\n      break;\n    }\n  }\n  if (typeof obj === \"string\" || typeof obj === \"number\" || typeof obj === \"boolean\") {\n    return obj;\n  } else if (obj === NullPartitionKeyLiteral) {\n    return NullPartitionKeyLiteral;\n  } else if (obj === undefined || JSON.stringify(obj) === JSON.stringify(NonePartitionKeyLiteral)) {\n    return NonePartitionKeyLiteral;\n  }\n  return undefined;\n}\n\n/**\n * @hidden\n */\nexport function undefinedPartitionKey(\n  partitionKeyDefinition: PartitionKeyDefinition,\n): PartitionKeyInternal {\n  if (partitionKeyDefinition?.systemKey) {\n    return [];\n  } else {\n    return partitionKeyDefinition?.paths.map(() => NonePartitionKeyLiteral);\n  }\n}\n\n/**\n * @hidden\n */\nexport async function setPartitionKeyIfUndefined(\n  diagnosticNode: DiagnosticNodeInternal,\n  container: Container,\n  partitionKey: PartitionKey,\n): Promise<PartitionKeyInternal> {\n  if (partitionKey === undefined) {\n    const partitionKeyDefinition = await readPartitionKeyDefinition(diagnosticNode, container);\n    partitionKey = undefinedPartitionKey(partitionKeyDefinition);\n  }\n  return convertToInternalPartitionKey(partitionKey);\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}