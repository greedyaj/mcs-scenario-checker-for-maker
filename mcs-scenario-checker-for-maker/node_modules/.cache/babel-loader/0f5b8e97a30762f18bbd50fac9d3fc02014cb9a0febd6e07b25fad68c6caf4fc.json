{"ast":null,"code":"import { isReadRequest } from \"../common\";\n/**\n * This class implements the retry policy for session consistent reads.\n * @hidden\n */\nexport class SessionRetryPolicy {\n  /**\n   * @param globalEndpointManager - The GlobalEndpointManager instance.\n   */\n  constructor(globalEndpointManager, resourceType, operationType, connectionPolicy) {\n    this.globalEndpointManager = globalEndpointManager;\n    this.resourceType = resourceType;\n    this.operationType = operationType;\n    this.connectionPolicy = connectionPolicy;\n    /** Current retry attempt count. */\n    this.currentRetryAttemptCount = 0;\n    /** Retry interval in milliseconds. */\n    this.retryAfterInMs = 0;\n  }\n  /**\n   * Determines whether the request should be retried or not.\n   * @param err - Error returned by the request.\n   * @param callback - The callback function which takes bool argument which specifies whether the request\n   * will be retried or not.\n   */\n  async shouldRetry(err, diagnosticNode, retryContext) {\n    if (!err) {\n      return false;\n    }\n    if (!retryContext) {\n      return false;\n    }\n    if (!this.connectionPolicy.enableEndpointDiscovery) {\n      return false;\n    }\n    if (this.globalEndpointManager.canUseMultipleWriteLocations(this.resourceType, this.operationType)) {\n      // If we can write to multiple locations, we should against every write endpoint until we succeed\n      const endpoints = isReadRequest(this.operationType) ? await this.globalEndpointManager.getReadEndpoints() : await this.globalEndpointManager.getWriteEndpoints();\n      if (this.currentRetryAttemptCount > endpoints.length) {\n        return false;\n      } else {\n        this.currentRetryAttemptCount++;\n        retryContext.retryCount++;\n        retryContext.retryRequestOnPreferredLocations = this.currentRetryAttemptCount > 1;\n        retryContext.clearSessionTokenNotAvailable = this.currentRetryAttemptCount === endpoints.length;\n        diagnosticNode.addData({\n          successfulRetryPolicy: \"session\"\n        });\n        return true;\n      }\n    } else {\n      if (this.currentRetryAttemptCount > 1) {\n        return false;\n      } else {\n        this.currentRetryAttemptCount++;\n        retryContext.retryCount++;\n        retryContext.retryRequestOnPreferredLocations = false; // Forces all operations to primary write endpoint\n        retryContext.clearSessionTokenNotAvailable = true;\n        diagnosticNode.addData({\n          successfulRetryPolicy: \"session\"\n        });\n        return true;\n      }\n    }\n  }\n}","map":{"version":3,"names":["isReadRequest","SessionRetryPolicy","constructor","globalEndpointManager","resourceType","operationType","connectionPolicy","currentRetryAttemptCount","retryAfterInMs","shouldRetry","err","diagnosticNode","retryContext","enableEndpointDiscovery","canUseMultipleWriteLocations","endpoints","getReadEndpoints","getWriteEndpoints","length","retryCount","retryRequestOnPreferredLocations","clearSessionTokenNotAvailable","addData","successfulRetryPolicy"],"sources":["/Users/ajitpawar/microsoft/bap/POCs/Scenario_checker_for_maker/mcs-scenario-checker-for-maker/node_modules/@azure/cosmos/src/retry/sessionRetryPolicy.ts"],"sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport type { DiagnosticNodeInternal } from \"../diagnostics/DiagnosticNodeInternal\";\nimport type { OperationType, ResourceType } from \"../common\";\nimport { isReadRequest } from \"../common\";\nimport type { ConnectionPolicy } from \"../documents\";\nimport type { GlobalEndpointManager } from \"../globalEndpointManager\";\nimport type { ErrorResponse } from \"../request\";\nimport type { RetryContext } from \"./RetryContext\";\nimport type { RetryPolicy } from \"./RetryPolicy\";\n\n/**\n * This class implements the retry policy for session consistent reads.\n * @hidden\n */\nexport class SessionRetryPolicy implements RetryPolicy {\n  /** Current retry attempt count. */\n  public currentRetryAttemptCount = 0;\n  /** Retry interval in milliseconds. */\n  public retryAfterInMs = 0;\n\n  /**\n   * @param globalEndpointManager - The GlobalEndpointManager instance.\n   */\n  constructor(\n    private globalEndpointManager: GlobalEndpointManager,\n    private resourceType: ResourceType,\n    private operationType: OperationType,\n    private connectionPolicy: ConnectionPolicy,\n  ) {}\n\n  /**\n   * Determines whether the request should be retried or not.\n   * @param err - Error returned by the request.\n   * @param callback - The callback function which takes bool argument which specifies whether the request\n   * will be retried or not.\n   */\n  public async shouldRetry(\n    err: ErrorResponse,\n    diagnosticNode: DiagnosticNodeInternal,\n    retryContext?: RetryContext,\n  ): Promise<boolean> {\n    if (!err) {\n      return false;\n    }\n\n    if (!retryContext) {\n      return false;\n    }\n\n    if (!this.connectionPolicy.enableEndpointDiscovery) {\n      return false;\n    }\n\n    if (\n      this.globalEndpointManager.canUseMultipleWriteLocations(this.resourceType, this.operationType)\n    ) {\n      // If we can write to multiple locations, we should against every write endpoint until we succeed\n      const endpoints = isReadRequest(this.operationType)\n        ? await this.globalEndpointManager.getReadEndpoints()\n        : await this.globalEndpointManager.getWriteEndpoints();\n      if (this.currentRetryAttemptCount > endpoints.length) {\n        return false;\n      } else {\n        this.currentRetryAttemptCount++;\n        retryContext.retryCount++;\n        retryContext.retryRequestOnPreferredLocations = this.currentRetryAttemptCount > 1;\n        retryContext.clearSessionTokenNotAvailable =\n          this.currentRetryAttemptCount === endpoints.length;\n        diagnosticNode.addData({ successfulRetryPolicy: \"session\" });\n        return true;\n      }\n    } else {\n      if (this.currentRetryAttemptCount > 1) {\n        return false;\n      } else {\n        this.currentRetryAttemptCount++;\n        retryContext.retryCount++;\n        retryContext.retryRequestOnPreferredLocations = false; // Forces all operations to primary write endpoint\n        retryContext.clearSessionTokenNotAvailable = true;\n        diagnosticNode.addData({ successfulRetryPolicy: \"session\" });\n        return true;\n      }\n    }\n  }\n}\n"],"mappings":"AAIA,SAASA,aAAa,QAAQ,WAAW;AAOzC;;;;AAIA,OAAM,MAAOC,kBAAkB;EAM7B;;;EAGAC,YACUC,qBAA4C,EAC5CC,YAA0B,EAC1BC,aAA4B,EAC5BC,gBAAkC;IAHlC,KAAAH,qBAAqB,GAArBA,qBAAqB;IACrB,KAAAC,YAAY,GAAZA,YAAY;IACZ,KAAAC,aAAa,GAAbA,aAAa;IACb,KAAAC,gBAAgB,GAAhBA,gBAAgB;IAZ1B;IACO,KAAAC,wBAAwB,GAAG,CAAC;IACnC;IACO,KAAAC,cAAc,GAAG,CAAC;EAUtB;EAEH;;;;;;EAMO,MAAMC,WAAWA,CACtBC,GAAkB,EAClBC,cAAsC,EACtCC,YAA2B;IAE3B,IAAI,CAACF,GAAG,EAAE;MACR,OAAO,KAAK;IACd;IAEA,IAAI,CAACE,YAAY,EAAE;MACjB,OAAO,KAAK;IACd;IAEA,IAAI,CAAC,IAAI,CAACN,gBAAgB,CAACO,uBAAuB,EAAE;MAClD,OAAO,KAAK;IACd;IAEA,IACE,IAAI,CAACV,qBAAqB,CAACW,4BAA4B,CAAC,IAAI,CAACV,YAAY,EAAE,IAAI,CAACC,aAAa,CAAC,EAC9F;MACA;MACA,MAAMU,SAAS,GAAGf,aAAa,CAAC,IAAI,CAACK,aAAa,CAAC,GAC/C,MAAM,IAAI,CAACF,qBAAqB,CAACa,gBAAgB,EAAE,GACnD,MAAM,IAAI,CAACb,qBAAqB,CAACc,iBAAiB,EAAE;MACxD,IAAI,IAAI,CAACV,wBAAwB,GAAGQ,SAAS,CAACG,MAAM,EAAE;QACpD,OAAO,KAAK;MACd,CAAC,MAAM;QACL,IAAI,CAACX,wBAAwB,EAAE;QAC/BK,YAAY,CAACO,UAAU,EAAE;QACzBP,YAAY,CAACQ,gCAAgC,GAAG,IAAI,CAACb,wBAAwB,GAAG,CAAC;QACjFK,YAAY,CAACS,6BAA6B,GACxC,IAAI,CAACd,wBAAwB,KAAKQ,SAAS,CAACG,MAAM;QACpDP,cAAc,CAACW,OAAO,CAAC;UAAEC,qBAAqB,EAAE;QAAS,CAAE,CAAC;QAC5D,OAAO,IAAI;MACb;IACF,CAAC,MAAM;MACL,IAAI,IAAI,CAAChB,wBAAwB,GAAG,CAAC,EAAE;QACrC,OAAO,KAAK;MACd,CAAC,MAAM;QACL,IAAI,CAACA,wBAAwB,EAAE;QAC/BK,YAAY,CAACO,UAAU,EAAE;QACzBP,YAAY,CAACQ,gCAAgC,GAAG,KAAK,CAAC,CAAC;QACvDR,YAAY,CAACS,6BAA6B,GAAG,IAAI;QACjDV,cAAc,CAACW,OAAO,CAAC;UAAEC,qBAAqB,EAAE;QAAS,CAAE,CAAC;QAC5D,OAAO,IAAI;MACb;IACF;EACF","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}