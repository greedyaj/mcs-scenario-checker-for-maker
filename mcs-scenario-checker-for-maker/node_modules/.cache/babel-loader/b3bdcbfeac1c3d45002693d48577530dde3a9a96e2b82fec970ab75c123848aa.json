{"ast":null,"code":"import { Constants } from \"../common\";\nimport { QueryRange } from \"./QueryRange\";\n/** @hidden */\nexport class InMemoryCollectionRoutingMap {\n  /**\n   * Represents a InMemoryCollectionRoutingMap Object,\n   * Stores partition key ranges in an efficient way with some additional information and provides\n   * convenience methods for working with set of ranges.\n   */\n  constructor(orderedPartitionKeyRanges, orderedPartitionInfo) {\n    this.orderedPartitionKeyRanges = orderedPartitionKeyRanges;\n    this.orderedRanges = orderedPartitionKeyRanges.map(pkr => {\n      return new QueryRange(pkr[Constants.PartitionKeyRange.MinInclusive], pkr[Constants.PartitionKeyRange.MaxExclusive], true, false);\n    });\n    this.orderedPartitionInfo = orderedPartitionInfo;\n  }\n  getOrderedParitionKeyRanges() {\n    return this.orderedPartitionKeyRanges;\n  }\n  getOverlappingRanges(providedQueryRanges) {\n    // TODO This code has all kinds of smells. Multiple iterations and sorts just to grab overlapping ranges\n    // stfaul attempted to bring it down to one for-loop and failed\n    const pqr = Array.isArray(providedQueryRanges) ? providedQueryRanges : [providedQueryRanges];\n    const minToPartitionRange = {}; // TODO: any\n    // this for loop doesn't invoke any async callback\n    for (const queryRange of pqr) {\n      if (queryRange.isEmpty()) {\n        continue;\n      }\n      if (queryRange.isFullRange()) {\n        return this.orderedPartitionKeyRanges;\n      }\n      const minIndex = this.orderedRanges.findIndex(range => {\n        if (queryRange.min > range.min && queryRange.min < range.max) {\n          return true;\n        }\n        if (queryRange.min === range.min) {\n          return true;\n        }\n        if (queryRange.min === range.max) {\n          return true;\n        }\n      });\n      if (minIndex < 0) {\n        throw new Error(\"error in collection routing map, queried value is less than the start range.\");\n      }\n      // Start at the end and work backwards\n      let maxIndex;\n      for (let i = this.orderedRanges.length - 1; i >= 0; i--) {\n        const range = this.orderedRanges[i];\n        if (queryRange.max > range.min && queryRange.max < range.max) {\n          maxIndex = i;\n          break;\n        }\n        if (queryRange.max === range.min) {\n          maxIndex = i;\n          break;\n        }\n        if (queryRange.max === range.max) {\n          maxIndex = i;\n          break;\n        }\n      }\n      if (maxIndex > this.orderedRanges.length) {\n        throw new Error(\"error in collection routing map, queried value is greater than the end range.\");\n      }\n      for (let j = minIndex; j < maxIndex + 1; j++) {\n        if (queryRange.overlaps(this.orderedRanges[j])) {\n          minToPartitionRange[this.orderedPartitionKeyRanges[j][Constants.PartitionKeyRange.MinInclusive]] = this.orderedPartitionKeyRanges[j];\n        }\n      }\n    }\n    const overlappingPartitionKeyRanges = Object.keys(minToPartitionRange).map(k => minToPartitionRange[k]);\n    return overlappingPartitionKeyRanges.sort((a, b) => {\n      return a[Constants.PartitionKeyRange.MinInclusive].localeCompare(b[Constants.PartitionKeyRange.MinInclusive]);\n    });\n  }\n}","map":{"version":3,"names":["Constants","QueryRange","InMemoryCollectionRoutingMap","constructor","orderedPartitionKeyRanges","orderedPartitionInfo","orderedRanges","map","pkr","PartitionKeyRange","MinInclusive","MaxExclusive","getOrderedParitionKeyRanges","getOverlappingRanges","providedQueryRanges","pqr","Array","isArray","minToPartitionRange","queryRange","isEmpty","isFullRange","minIndex","findIndex","range","min","max","Error","maxIndex","i","length","j","overlaps","overlappingPartitionKeyRanges","Object","keys","k","sort","a","b","localeCompare"],"sources":["/Users/ajitpawar/microsoft/bap/POCs/Scenario_checker_for_maker/mcs-scenario-checker-for-maker/node_modules/@azure/cosmos/src/routing/inMemoryCollectionRoutingMap.ts"],"sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport type { PartitionKeyRange } from \"../client\";\nimport { Constants } from \"../common\";\nimport { QueryRange } from \"./QueryRange\";\n\n/** @hidden */\nexport class InMemoryCollectionRoutingMap {\n  private orderedPartitionKeyRanges: PartitionKeyRange[];\n  private orderedRanges: QueryRange[];\n  // TODO: chrande made this public, even though it is implementation detail for a test\n  public orderedPartitionInfo: unknown;\n\n  /**\n   * Represents a InMemoryCollectionRoutingMap Object,\n   * Stores partition key ranges in an efficient way with some additional information and provides\n   * convenience methods for working with set of ranges.\n   */\n  constructor(orderedPartitionKeyRanges: PartitionKeyRange[], orderedPartitionInfo: unknown) {\n    this.orderedPartitionKeyRanges = orderedPartitionKeyRanges;\n    this.orderedRanges = orderedPartitionKeyRanges.map((pkr) => {\n      return new QueryRange(\n        pkr[Constants.PartitionKeyRange.MinInclusive],\n        pkr[Constants.PartitionKeyRange.MaxExclusive],\n        true,\n        false,\n      );\n    });\n    this.orderedPartitionInfo = orderedPartitionInfo;\n  }\n  public getOrderedParitionKeyRanges(): PartitionKeyRange[] {\n    return this.orderedPartitionKeyRanges;\n  }\n\n  public getOverlappingRanges(providedQueryRanges: QueryRange | QueryRange[]): PartitionKeyRange[] {\n    // TODO This code has all kinds of smells. Multiple iterations and sorts just to grab overlapping ranges\n    // stfaul attempted to bring it down to one for-loop and failed\n    const pqr: QueryRange[] = Array.isArray(providedQueryRanges)\n      ? providedQueryRanges\n      : [providedQueryRanges];\n    const minToPartitionRange: any = {}; // TODO: any\n\n    // this for loop doesn't invoke any async callback\n    for (const queryRange of pqr) {\n      if (queryRange.isEmpty()) {\n        continue;\n      }\n\n      if (queryRange.isFullRange()) {\n        return this.orderedPartitionKeyRanges;\n      }\n\n      const minIndex = this.orderedRanges.findIndex((range) => {\n        if (queryRange.min > range.min && queryRange.min < range.max) {\n          return true;\n        }\n        if (queryRange.min === range.min) {\n          return true;\n        }\n        if (queryRange.min === range.max) {\n          return true;\n        }\n      });\n\n      if (minIndex < 0) {\n        throw new Error(\n          \"error in collection routing map, queried value is less than the start range.\",\n        );\n      }\n\n      // Start at the end and work backwards\n      let maxIndex: number;\n      for (let i = this.orderedRanges.length - 1; i >= 0; i--) {\n        const range = this.orderedRanges[i];\n        if (queryRange.max > range.min && queryRange.max < range.max) {\n          maxIndex = i;\n          break;\n        }\n        if (queryRange.max === range.min) {\n          maxIndex = i;\n          break;\n        }\n        if (queryRange.max === range.max) {\n          maxIndex = i;\n          break;\n        }\n      }\n\n      if (maxIndex > this.orderedRanges.length) {\n        throw new Error(\n          \"error in collection routing map, queried value is greater than the end range.\",\n        );\n      }\n\n      for (let j = minIndex; j < maxIndex + 1; j++) {\n        if (queryRange.overlaps(this.orderedRanges[j])) {\n          minToPartitionRange[\n            this.orderedPartitionKeyRanges[j][Constants.PartitionKeyRange.MinInclusive]\n          ] = this.orderedPartitionKeyRanges[j];\n        }\n      }\n    }\n\n    const overlappingPartitionKeyRanges = Object.keys(minToPartitionRange).map(\n      (k) => minToPartitionRange[k],\n    );\n\n    return overlappingPartitionKeyRanges.sort((a, b) => {\n      return a[Constants.PartitionKeyRange.MinInclusive].localeCompare(\n        b[Constants.PartitionKeyRange.MinInclusive],\n      );\n    });\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}