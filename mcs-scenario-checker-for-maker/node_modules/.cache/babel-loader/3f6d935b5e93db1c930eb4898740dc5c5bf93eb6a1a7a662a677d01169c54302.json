{"ast":null,"code":"// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport atob from \"../utils/atob\";\nimport { Constants, getContainerLink, OperationType, trimSlashes } from \"../common\";\nimport { VectorSessionToken } from \"./VectorSessionToken\";\n/** @hidden */\nexport class SessionContainer {\n  constructor(collectionNameToCollectionResourceId = new Map(), collectionResourceIdToSessionTokens = new Map()) {\n    this.collectionNameToCollectionResourceId = collectionNameToCollectionResourceId;\n    this.collectionResourceIdToSessionTokens = collectionResourceIdToSessionTokens;\n  }\n  get(request) {\n    if (!request) {\n      throw new Error(\"request cannot be null\");\n    }\n    const collectionName = getContainerLink(trimSlashes(request.resourceAddress));\n    const rangeIdToTokenMap = this.getPartitionKeyRangeIdToTokenMap(collectionName);\n    return SessionContainer.getCombinedSessionTokenString(rangeIdToTokenMap);\n  }\n  remove(request) {\n    let collectionResourceId;\n    const resourceAddress = trimSlashes(request.resourceAddress);\n    const collectionName = getContainerLink(resourceAddress);\n    if (collectionName) {\n      collectionResourceId = this.collectionNameToCollectionResourceId.get(collectionName);\n      this.collectionNameToCollectionResourceId.delete(collectionName);\n    }\n    if (collectionResourceId !== undefined) {\n      this.collectionResourceIdToSessionTokens.delete(collectionResourceId);\n    }\n  }\n  set(request, resHeaders) {\n    // TODO: we check the master logic a few different places. Might not need it.\n    if (!resHeaders || SessionContainer.isReadingFromMaster(request.resourceType, request.operationType)) {\n      return;\n    }\n    const sessionTokenString = resHeaders[Constants.HttpHeaders.SessionToken];\n    if (!sessionTokenString) {\n      return;\n    }\n    const containerName = this.getContainerName(request, resHeaders);\n    const ownerId = !request.isNameBased ? request.resourceId : resHeaders[Constants.HttpHeaders.OwnerId] || request.resourceId;\n    if (!ownerId) {\n      return;\n    }\n    if (containerName && this.validateOwnerID(ownerId)) {\n      if (!this.collectionResourceIdToSessionTokens.has(ownerId)) {\n        this.collectionResourceIdToSessionTokens.set(ownerId, new Map());\n      }\n      if (!this.collectionNameToCollectionResourceId.has(containerName)) {\n        this.collectionNameToCollectionResourceId.set(containerName, ownerId);\n      }\n      const containerSessionContainer = this.collectionResourceIdToSessionTokens.get(ownerId);\n      SessionContainer.compareAndSetToken(sessionTokenString, containerSessionContainer);\n    }\n  }\n  validateOwnerID(ownerId) {\n    // If ownerId contains exactly 8 bytes it represents a unique database+collection identifier. Otherwise it represents another resource\n    // The first 4 bytes are the database. The last 4 bytes are the collection.\n    // Cosmos rids potentially contain \"-\" which is an invalid character in the browser atob implementation\n    // See https://en.wikipedia.org/wiki/Base64#Filenames\n    return atob(ownerId.replace(/-/g, \"/\")).length === 8;\n  }\n  getPartitionKeyRangeIdToTokenMap(collectionName) {\n    let rangeIdToTokenMap = null;\n    if (collectionName && this.collectionNameToCollectionResourceId.has(collectionName)) {\n      rangeIdToTokenMap = this.collectionResourceIdToSessionTokens.get(this.collectionNameToCollectionResourceId.get(collectionName));\n    }\n    return rangeIdToTokenMap;\n  }\n  static getCombinedSessionTokenString(tokens) {\n    if (!tokens || tokens.size === 0) {\n      return SessionContainer.EMPTY_SESSION_TOKEN;\n    }\n    let result = \"\";\n    for (const [range, token] of tokens.entries()) {\n      result += range + SessionContainer.SESSION_TOKEN_PARTITION_SPLITTER + token.toString() + SessionContainer.SESSION_TOKEN_SEPARATOR;\n    }\n    return result.slice(0, -1);\n  }\n  static compareAndSetToken(newTokenString, containerSessionTokens) {\n    if (!newTokenString) {\n      return;\n    }\n    const partitionsParts = newTokenString.split(SessionContainer.SESSION_TOKEN_SEPARATOR);\n    for (const partitionPart of partitionsParts) {\n      const newTokenParts = partitionPart.split(SessionContainer.SESSION_TOKEN_PARTITION_SPLITTER);\n      if (newTokenParts.length !== 2) {\n        return;\n      }\n      const range = newTokenParts[0];\n      const newToken = VectorSessionToken.create(newTokenParts[1]);\n      const tokenForRange = !containerSessionTokens.get(range) ? newToken : containerSessionTokens.get(range).merge(newToken);\n      containerSessionTokens.set(range, tokenForRange);\n    }\n  }\n  // TODO: have a assert if the type doesn't mastch known types\n  static isReadingFromMaster(resourceType, operationType) {\n    if (resourceType === Constants.Path.OffersPathSegment || resourceType === Constants.Path.DatabasesPathSegment || resourceType === Constants.Path.UsersPathSegment || resourceType === Constants.Path.PermissionsPathSegment || resourceType === Constants.Path.TopologyPathSegment || resourceType === Constants.Path.DatabaseAccountPathSegment || resourceType === Constants.Path.PartitionKeyRangesPathSegment || resourceType === Constants.Path.CollectionsPathSegment && operationType === OperationType.Query) {\n      return true;\n    }\n    return false;\n  }\n  getContainerName(request, headers) {\n    let ownerFullName = headers[Constants.HttpHeaders.OwnerFullName];\n    if (!ownerFullName) {\n      ownerFullName = trimSlashes(request.resourceAddress);\n    }\n    return getContainerLink(ownerFullName);\n  }\n}\nSessionContainer.EMPTY_SESSION_TOKEN = \"\";\nSessionContainer.SESSION_TOKEN_SEPARATOR = \",\";\nSessionContainer.SESSION_TOKEN_PARTITION_SPLITTER = \":\";","map":{"version":3,"names":["atob","Constants","getContainerLink","OperationType","trimSlashes","VectorSessionToken","SessionContainer","constructor","collectionNameToCollectionResourceId","Map","collectionResourceIdToSessionTokens","get","request","Error","collectionName","resourceAddress","rangeIdToTokenMap","getPartitionKeyRangeIdToTokenMap","getCombinedSessionTokenString","remove","collectionResourceId","delete","undefined","set","resHeaders","isReadingFromMaster","resourceType","operationType","sessionTokenString","HttpHeaders","SessionToken","containerName","getContainerName","ownerId","isNameBased","resourceId","OwnerId","validateOwnerID","has","containerSessionContainer","compareAndSetToken","replace","length","tokens","size","EMPTY_SESSION_TOKEN","result","range","token","entries","SESSION_TOKEN_PARTITION_SPLITTER","toString","SESSION_TOKEN_SEPARATOR","slice","newTokenString","containerSessionTokens","partitionsParts","split","partitionPart","newTokenParts","newToken","create","tokenForRange","merge","Path","OffersPathSegment","DatabasesPathSegment","UsersPathSegment","PermissionsPathSegment","TopologyPathSegment","DatabaseAccountPathSegment","PartitionKeyRangesPathSegment","CollectionsPathSegment","Query","headers","ownerFullName","OwnerFullName"],"sources":["/Users/ajitpawar/microsoft/bap/POCs/Scenario_checker_for_maker/mcs-scenario-checker-for-maker/node_modules/@azure/cosmos/src/session/sessionContainer.ts"],"sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport atob from \"../utils/atob\";\nimport type { ResourceType } from \"../common\";\nimport { Constants, getContainerLink, OperationType, trimSlashes } from \"../common\";\nimport type { CosmosHeaders } from \"../queryExecutionContext\";\nimport type { SessionContext } from \"./SessionContext\";\nimport { VectorSessionToken } from \"./VectorSessionToken\";\n\n/** @hidden */\nexport class SessionContainer {\n  private static readonly EMPTY_SESSION_TOKEN = \"\";\n  private static readonly SESSION_TOKEN_SEPARATOR = \",\";\n  private static readonly SESSION_TOKEN_PARTITION_SPLITTER = \":\";\n  constructor(\n    private collectionNameToCollectionResourceId = new Map<string, string>(),\n    private collectionResourceIdToSessionTokens = new Map<\n      string,\n      Map<string, VectorSessionToken>\n    >(),\n  ) {}\n\n  public get(request: SessionContext): string {\n    if (!request) {\n      throw new Error(\"request cannot be null\");\n    }\n    const collectionName = getContainerLink(trimSlashes(request.resourceAddress));\n    const rangeIdToTokenMap = this.getPartitionKeyRangeIdToTokenMap(collectionName);\n    return SessionContainer.getCombinedSessionTokenString(rangeIdToTokenMap);\n  }\n\n  public remove(request: SessionContext): void {\n    let collectionResourceId: string;\n    const resourceAddress = trimSlashes(request.resourceAddress);\n    const collectionName = getContainerLink(resourceAddress);\n    if (collectionName) {\n      collectionResourceId = this.collectionNameToCollectionResourceId.get(collectionName);\n      this.collectionNameToCollectionResourceId.delete(collectionName);\n    }\n    if (collectionResourceId !== undefined) {\n      this.collectionResourceIdToSessionTokens.delete(collectionResourceId);\n    }\n  }\n\n  public set(request: SessionContext, resHeaders: CosmosHeaders): void {\n    // TODO: we check the master logic a few different places. Might not need it.\n    if (\n      !resHeaders ||\n      SessionContainer.isReadingFromMaster(request.resourceType, request.operationType)\n    ) {\n      return;\n    }\n\n    const sessionTokenString = resHeaders[Constants.HttpHeaders.SessionToken];\n    if (!sessionTokenString) {\n      return;\n    }\n\n    const containerName = this.getContainerName(request, resHeaders);\n\n    const ownerId = !request.isNameBased\n      ? request.resourceId\n      : resHeaders[Constants.HttpHeaders.OwnerId] || request.resourceId;\n\n    if (!ownerId) {\n      return;\n    }\n\n    if (containerName && this.validateOwnerID(ownerId)) {\n      if (!this.collectionResourceIdToSessionTokens.has(ownerId)) {\n        this.collectionResourceIdToSessionTokens.set(ownerId, new Map());\n      }\n\n      if (!this.collectionNameToCollectionResourceId.has(containerName)) {\n        this.collectionNameToCollectionResourceId.set(containerName, ownerId);\n      }\n\n      const containerSessionContainer = this.collectionResourceIdToSessionTokens.get(ownerId);\n      SessionContainer.compareAndSetToken(sessionTokenString, containerSessionContainer);\n    }\n  }\n\n  private validateOwnerID(ownerId: string): boolean {\n    // If ownerId contains exactly 8 bytes it represents a unique database+collection identifier. Otherwise it represents another resource\n    // The first 4 bytes are the database. The last 4 bytes are the collection.\n    // Cosmos rids potentially contain \"-\" which is an invalid character in the browser atob implementation\n    // See https://en.wikipedia.org/wiki/Base64#Filenames\n    return atob(ownerId.replace(/-/g, \"/\")).length === 8;\n  }\n\n  private getPartitionKeyRangeIdToTokenMap(\n    collectionName: string,\n  ): Map<string, VectorSessionToken> {\n    let rangeIdToTokenMap: Map<string, VectorSessionToken> = null;\n    if (collectionName && this.collectionNameToCollectionResourceId.has(collectionName)) {\n      rangeIdToTokenMap = this.collectionResourceIdToSessionTokens.get(\n        this.collectionNameToCollectionResourceId.get(collectionName),\n      );\n    }\n\n    return rangeIdToTokenMap;\n  }\n\n  private static getCombinedSessionTokenString(tokens: Map<string, VectorSessionToken>): string {\n    if (!tokens || tokens.size === 0) {\n      return SessionContainer.EMPTY_SESSION_TOKEN;\n    }\n\n    let result = \"\";\n    for (const [range, token] of tokens.entries()) {\n      result +=\n        range +\n        SessionContainer.SESSION_TOKEN_PARTITION_SPLITTER +\n        token.toString() +\n        SessionContainer.SESSION_TOKEN_SEPARATOR;\n    }\n    return result.slice(0, -1);\n  }\n\n  private static compareAndSetToken(\n    newTokenString: string,\n    containerSessionTokens: Map<string, VectorSessionToken>,\n  ): void {\n    if (!newTokenString) {\n      return;\n    }\n\n    const partitionsParts = newTokenString.split(SessionContainer.SESSION_TOKEN_SEPARATOR);\n    for (const partitionPart of partitionsParts) {\n      const newTokenParts = partitionPart.split(SessionContainer.SESSION_TOKEN_PARTITION_SPLITTER);\n      if (newTokenParts.length !== 2) {\n        return;\n      }\n\n      const range = newTokenParts[0];\n      const newToken = VectorSessionToken.create(newTokenParts[1]);\n      const tokenForRange = !containerSessionTokens.get(range)\n        ? newToken\n        : containerSessionTokens.get(range).merge(newToken);\n      containerSessionTokens.set(range, tokenForRange);\n    }\n  }\n\n  // TODO: have a assert if the type doesn't mastch known types\n  private static isReadingFromMaster(\n    resourceType: ResourceType,\n    operationType: OperationType,\n  ): boolean {\n    if (\n      resourceType === Constants.Path.OffersPathSegment ||\n      resourceType === Constants.Path.DatabasesPathSegment ||\n      resourceType === Constants.Path.UsersPathSegment ||\n      resourceType === Constants.Path.PermissionsPathSegment ||\n      resourceType === Constants.Path.TopologyPathSegment ||\n      resourceType === Constants.Path.DatabaseAccountPathSegment ||\n      resourceType === Constants.Path.PartitionKeyRangesPathSegment ||\n      (resourceType === Constants.Path.CollectionsPathSegment &&\n        operationType === OperationType.Query)\n    ) {\n      return true;\n    }\n\n    return false;\n  }\n\n  private getContainerName(request: SessionContext, headers: CosmosHeaders): string {\n    let ownerFullName = headers[Constants.HttpHeaders.OwnerFullName];\n    if (!ownerFullName) {\n      ownerFullName = trimSlashes(request.resourceAddress);\n    }\n\n    return getContainerLink(ownerFullName as string);\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}