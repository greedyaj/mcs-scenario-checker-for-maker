{"ast":null,"code":"// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport { extractPartitionKeys, undefinedPartitionKey } from \"../extractPartitionKey\";\nimport { NonePartitionKeyLiteral, convertToInternalPartitionKey } from \"../documents\";\nimport { assertNotUndefined } from \"./typeChecks\";\nimport { bodyFromData } from \"../request/request\";\nimport { Constants } from \"../common/constants\";\nimport { randomUUID } from \"@azure/core-util\";\nexport function isKeyInRange(min, max, key) {\n  const isAfterMinInclusive = key.localeCompare(min) >= 0;\n  const isBeforeMax = key.localeCompare(max) < 0;\n  return isAfterMinInclusive && isBeforeMax;\n}\nexport const BulkOperationType = {\n  Create: \"Create\",\n  Upsert: \"Upsert\",\n  Read: \"Read\",\n  Delete: \"Delete\",\n  Replace: \"Replace\",\n  Patch: \"Patch\"\n};\nexport function hasResource(operation) {\n  return operation.operationType !== \"Patch\" && operation.resourceBody !== undefined;\n}\n/**\n * Maps OperationInput to Operation by\n * - generating Ids if needed.\n * - choosing partitionKey which can be used to choose which batch this\n * operation should be part of. The order is -\n *   1. If the operationInput itself has partitionKey field set it is used.\n *   2. Other wise for create/replace/upsert it is extracted from resource body.\n *   3. For read/delete/patch type operations undefined partitionKey is used.\n * - Here one nuance is that, the partitionKey field inside Operation needs to\n *  be serialized as a JSON string.\n * @param operationInput - OperationInput\n * @param definition - PartitionKeyDefinition\n * @param options - RequestOptions\n * @returns\n */\nexport function prepareOperations(operationInput, definition, options = {}) {\n  populateIdsIfNeeded(operationInput, options);\n  let partitionKey;\n  if (Object.prototype.hasOwnProperty.call(operationInput, \"partitionKey\")) {\n    if (operationInput.partitionKey === undefined) {\n      partitionKey = definition.paths.map(() => NonePartitionKeyLiteral);\n    } else {\n      partitionKey = convertToInternalPartitionKey(operationInput.partitionKey);\n    }\n  } else {\n    switch (operationInput.operationType) {\n      case BulkOperationType.Create:\n      case BulkOperationType.Replace:\n      case BulkOperationType.Upsert:\n        partitionKey = assertNotUndefined(extractPartitionKeys(operationInput.resourceBody, definition), \"Unexpected undefined Partition Key Found.\");\n        break;\n      case BulkOperationType.Read:\n      case BulkOperationType.Delete:\n      case BulkOperationType.Patch:\n        partitionKey = undefinedPartitionKey(definition);\n        break;\n    }\n  }\n  return {\n    operation: Object.assign(Object.assign({}, operationInput), {\n      partitionKey: JSON.stringify(partitionKey)\n    }),\n    partitionKey\n  };\n}\n/**\n * For operations requiring Id genrate random uuids.\n * @param operationInput - OperationInput to be checked.\n * @param options - RequestOptions\n */\nfunction populateIdsIfNeeded(operationInput, options) {\n  if (operationInput.operationType === BulkOperationType.Create || operationInput.operationType === BulkOperationType.Upsert) {\n    if ((operationInput.resourceBody.id === undefined || operationInput.resourceBody.id === \"\") && !options.disableAutomaticIdGeneration) {\n      operationInput.resourceBody.id = randomUUID();\n    }\n  }\n}\n/**\n * Splits a batch into array of batches based on cumulative size of its operations by making sure\n * cumulative size of an individual batch is not larger than {@link Constants.DefaultMaxBulkRequestBodySizeInBytes}.\n * If a single operation itself is larger than {@link Constants.DefaultMaxBulkRequestBodySizeInBytes}, that\n * operation would be moved into a batch containing only that operation.\n * @param originalBatch - A batch of operations needed to be checked.\n * @returns\n * @hidden\n */\nexport function splitBatchBasedOnBodySize(originalBatch) {\n  if ((originalBatch === null || originalBatch === void 0 ? void 0 : originalBatch.operations) === undefined || originalBatch.operations.length < 1) return [];\n  let currentBatchSize = calculateObjectSizeInBytes(originalBatch.operations[0]);\n  let currentBatch = Object.assign(Object.assign({}, originalBatch), {\n    operations: [originalBatch.operations[0]],\n    indexes: [originalBatch.indexes[0]]\n  });\n  const processedBatches = [];\n  processedBatches.push(currentBatch);\n  for (let index = 1; index < originalBatch.operations.length; index++) {\n    const operation = originalBatch.operations[index];\n    const currentOpSize = calculateObjectSizeInBytes(operation);\n    if (currentBatchSize + currentOpSize > Constants.DefaultMaxBulkRequestBodySizeInBytes) {\n      currentBatch = Object.assign(Object.assign({}, originalBatch), {\n        operations: [],\n        indexes: []\n      });\n      processedBatches.push(currentBatch);\n      currentBatchSize = 0;\n    }\n    currentBatch.operations.push(operation);\n    currentBatch.indexes.push(originalBatch.indexes[index]);\n    currentBatchSize += currentOpSize;\n  }\n  return processedBatches;\n}\n/**\n * Calculates size of an JSON object in bytes with utf-8 encoding.\n * @hidden\n */\nexport function calculateObjectSizeInBytes(obj) {\n  return new TextEncoder().encode(bodyFromData(obj)).length;\n}\nexport function decorateBatchOperation(operation, options = {}) {\n  if (operation.operationType === BulkOperationType.Create || operation.operationType === BulkOperationType.Upsert) {\n    if ((operation.resourceBody.id === undefined || operation.resourceBody.id === \"\") && !options.disableAutomaticIdGeneration) {\n      operation.resourceBody.id = randomUUID();\n    }\n  }\n  return operation;\n}","map":{"version":3,"names":["extractPartitionKeys","undefinedPartitionKey","NonePartitionKeyLiteral","convertToInternalPartitionKey","assertNotUndefined","bodyFromData","Constants","randomUUID","isKeyInRange","min","max","key","isAfterMinInclusive","localeCompare","isBeforeMax","BulkOperationType","Create","Upsert","Read","Delete","Replace","Patch","hasResource","operation","operationType","resourceBody","undefined","prepareOperations","operationInput","definition","options","populateIdsIfNeeded","partitionKey","Object","prototype","hasOwnProperty","call","paths","map","assign","JSON","stringify","id","disableAutomaticIdGeneration","splitBatchBasedOnBodySize","originalBatch","operations","length","currentBatchSize","calculateObjectSizeInBytes","currentBatch","indexes","processedBatches","push","index","currentOpSize","DefaultMaxBulkRequestBodySizeInBytes","obj","TextEncoder","encode","decorateBatchOperation"],"sources":["/Users/ajitpawar/microsoft/bap/POCs/Scenario_checker_for_maker/mcs-scenario-checker-for-maker/node_modules/@azure/cosmos/src/utils/batch.ts"],"sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\nimport type { JSONObject } from \"../queryExecutionContext\";\nimport { extractPartitionKeys, undefinedPartitionKey } from \"../extractPartitionKey\";\nimport type { CosmosDiagnostics, RequestOptions } from \"..\";\nimport type {\n  PartitionKey,\n  PartitionKeyDefinition,\n  PrimitivePartitionKeyValue,\n} from \"../documents\";\nimport { NonePartitionKeyLiteral, convertToInternalPartitionKey } from \"../documents\";\nimport type { PatchRequestBody } from \"./patch\";\nimport { assertNotUndefined } from \"./typeChecks\";\nimport { bodyFromData } from \"../request/request\";\nimport { Constants } from \"../common/constants\";\nimport { randomUUID } from \"@azure/core-util\";\n\nexport type Operation =\n  | CreateOperation\n  | UpsertOperation\n  | ReadOperation\n  | DeleteOperation\n  | ReplaceOperation\n  | BulkPatchOperation;\n\nexport interface Batch {\n  min: string;\n  max: string;\n  rangeId: string;\n  indexes: number[];\n  operations: Operation[];\n}\n\nexport type BulkOperationResponse = OperationResponse[] & { diagnostics: CosmosDiagnostics };\n\nexport interface OperationResponse {\n  statusCode: number;\n  requestCharge: number;\n  eTag?: string;\n  resourceBody?: JSONObject;\n}\n\n/**\n * Options object used to modify bulk execution.\n * continueOnError (Default value: false) - Continues bulk execution when an operation fails ** NOTE THIS WILL DEFAULT TO TRUE IN the 4.0 RELEASE\n */\nexport interface BulkOptions {\n  continueOnError?: boolean;\n}\n\nexport function isKeyInRange(min: string, max: string, key: string): boolean {\n  const isAfterMinInclusive = key.localeCompare(min) >= 0;\n  const isBeforeMax = key.localeCompare(max) < 0;\n  return isAfterMinInclusive && isBeforeMax;\n}\n\nexport interface OperationBase {\n  partitionKey?: string;\n  ifMatch?: string;\n  ifNoneMatch?: string;\n}\n\nexport const BulkOperationType = {\n  Create: \"Create\",\n  Upsert: \"Upsert\",\n  Read: \"Read\",\n  Delete: \"Delete\",\n  Replace: \"Replace\",\n  Patch: \"Patch\",\n} as const;\n\nexport type OperationInput =\n  | CreateOperationInput\n  | UpsertOperationInput\n  | ReadOperationInput\n  | DeleteOperationInput\n  | ReplaceOperationInput\n  | PatchOperationInput;\n\nexport interface CreateOperationInput {\n  partitionKey?: PartitionKey;\n  ifMatch?: string;\n  ifNoneMatch?: string;\n  operationType: typeof BulkOperationType.Create;\n  resourceBody: JSONObject;\n}\n\nexport interface UpsertOperationInput {\n  partitionKey?: PartitionKey;\n  ifMatch?: string;\n  ifNoneMatch?: string;\n  operationType: typeof BulkOperationType.Upsert;\n  resourceBody: JSONObject;\n}\n\nexport interface ReadOperationInput {\n  partitionKey?: PartitionKey;\n  operationType: typeof BulkOperationType.Read;\n  id: string;\n}\n\nexport interface DeleteOperationInput {\n  partitionKey?: PartitionKey;\n  operationType: typeof BulkOperationType.Delete;\n  id: string;\n}\n\nexport interface ReplaceOperationInput {\n  partitionKey?: PartitionKey;\n  ifMatch?: string;\n  ifNoneMatch?: string;\n  operationType: typeof BulkOperationType.Replace;\n  resourceBody: JSONObject;\n  id: string;\n}\n\nexport interface PatchOperationInput {\n  partitionKey?: PartitionKey;\n  ifMatch?: string;\n  ifNoneMatch?: string;\n  operationType: typeof BulkOperationType.Patch;\n  resourceBody: PatchRequestBody;\n  id: string;\n}\n\nexport type OperationWithItem = OperationBase & {\n  resourceBody: JSONObject;\n};\n\nexport type CreateOperation = OperationWithItem & {\n  operationType: typeof BulkOperationType.Create;\n};\n\nexport type UpsertOperation = OperationWithItem & {\n  operationType: typeof BulkOperationType.Upsert;\n};\n\nexport type ReadOperation = OperationBase & {\n  operationType: typeof BulkOperationType.Read;\n  id: string;\n};\n\nexport type DeleteOperation = OperationBase & {\n  operationType: typeof BulkOperationType.Delete;\n  id: string;\n};\n\nexport type ReplaceOperation = OperationWithItem & {\n  operationType: typeof BulkOperationType.Replace;\n  id: string;\n};\n\nexport type BulkPatchOperation = OperationBase & {\n  operationType: typeof BulkOperationType.Patch;\n  id: string;\n};\n\nexport function hasResource(\n  operation: Operation,\n): operation is CreateOperation | UpsertOperation | ReplaceOperation {\n  return (\n    operation.operationType !== \"Patch\" &&\n    (operation as OperationWithItem).resourceBody !== undefined\n  );\n}\n/**\n * Maps OperationInput to Operation by\n * - generating Ids if needed.\n * - choosing partitionKey which can be used to choose which batch this\n * operation should be part of. The order is -\n *   1. If the operationInput itself has partitionKey field set it is used.\n *   2. Other wise for create/replace/upsert it is extracted from resource body.\n *   3. For read/delete/patch type operations undefined partitionKey is used.\n * - Here one nuance is that, the partitionKey field inside Operation needs to\n *  be serialized as a JSON string.\n * @param operationInput - OperationInput\n * @param definition - PartitionKeyDefinition\n * @param options - RequestOptions\n * @returns\n */\nexport function prepareOperations(\n  operationInput: OperationInput,\n  definition: PartitionKeyDefinition,\n  options: RequestOptions = {},\n): {\n  operation: Operation;\n  partitionKey: PrimitivePartitionKeyValue[];\n} {\n  populateIdsIfNeeded(operationInput, options);\n\n  let partitionKey: PrimitivePartitionKeyValue[];\n  if (Object.prototype.hasOwnProperty.call(operationInput, \"partitionKey\")) {\n    if (operationInput.partitionKey === undefined) {\n      partitionKey = definition.paths.map(() => NonePartitionKeyLiteral);\n    } else {\n      partitionKey = convertToInternalPartitionKey(operationInput.partitionKey);\n    }\n  } else {\n    switch (operationInput.operationType) {\n      case BulkOperationType.Create:\n      case BulkOperationType.Replace:\n      case BulkOperationType.Upsert:\n        partitionKey = assertNotUndefined(\n          extractPartitionKeys(operationInput.resourceBody, definition),\n          \"Unexpected undefined Partition Key Found.\",\n        );\n        break;\n      case BulkOperationType.Read:\n      case BulkOperationType.Delete:\n      case BulkOperationType.Patch:\n        partitionKey = undefinedPartitionKey(definition);\n        break;\n    }\n  }\n  return {\n    operation: { ...operationInput, partitionKey: JSON.stringify(partitionKey) } as Operation,\n    partitionKey,\n  };\n}\n\n/**\n * For operations requiring Id genrate random uuids.\n * @param operationInput - OperationInput to be checked.\n * @param options - RequestOptions\n */\nfunction populateIdsIfNeeded(operationInput: OperationInput, options: RequestOptions) {\n  if (\n    operationInput.operationType === BulkOperationType.Create ||\n    operationInput.operationType === BulkOperationType.Upsert\n  ) {\n    if (\n      (operationInput.resourceBody.id === undefined || operationInput.resourceBody.id === \"\") &&\n      !options.disableAutomaticIdGeneration\n    ) {\n      operationInput.resourceBody.id = randomUUID();\n    }\n  }\n}\n\n/**\n * Splits a batch into array of batches based on cumulative size of its operations by making sure\n * cumulative size of an individual batch is not larger than {@link Constants.DefaultMaxBulkRequestBodySizeInBytes}.\n * If a single operation itself is larger than {@link Constants.DefaultMaxBulkRequestBodySizeInBytes}, that\n * operation would be moved into a batch containing only that operation.\n * @param originalBatch - A batch of operations needed to be checked.\n * @returns\n * @hidden\n */\nexport function splitBatchBasedOnBodySize(originalBatch: Batch): Batch[] {\n  if (originalBatch?.operations === undefined || originalBatch.operations.length < 1) return [];\n  let currentBatchSize = calculateObjectSizeInBytes(originalBatch.operations[0]);\n  let currentBatch: Batch = {\n    ...originalBatch,\n    operations: [originalBatch.operations[0]],\n    indexes: [originalBatch.indexes[0]],\n  };\n  const processedBatches: Batch[] = [];\n  processedBatches.push(currentBatch);\n\n  for (let index = 1; index < originalBatch.operations.length; index++) {\n    const operation = originalBatch.operations[index];\n    const currentOpSize = calculateObjectSizeInBytes(operation);\n    if (currentBatchSize + currentOpSize > Constants.DefaultMaxBulkRequestBodySizeInBytes) {\n      currentBatch = {\n        ...originalBatch,\n        operations: [],\n        indexes: [],\n      };\n      processedBatches.push(currentBatch);\n      currentBatchSize = 0;\n    }\n    currentBatch.operations.push(operation);\n    currentBatch.indexes.push(originalBatch.indexes[index]);\n    currentBatchSize += currentOpSize;\n  }\n  return processedBatches;\n}\n\n/**\n * Calculates size of an JSON object in bytes with utf-8 encoding.\n * @hidden\n */\nexport function calculateObjectSizeInBytes(obj: unknown): number {\n  return new TextEncoder().encode(bodyFromData(obj as any)).length;\n}\n\nexport function decorateBatchOperation(\n  operation: OperationInput,\n  options: RequestOptions = {},\n): Operation {\n  if (\n    operation.operationType === BulkOperationType.Create ||\n    operation.operationType === BulkOperationType.Upsert\n  ) {\n    if (\n      (operation.resourceBody.id === undefined || operation.resourceBody.id === \"\") &&\n      !options.disableAutomaticIdGeneration\n    ) {\n      operation.resourceBody.id = randomUUID();\n    }\n  }\n  return operation as Operation;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}