{"ast":null,"code":"// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport { Database, Databases } from \"./client/Database\";\nimport { Offer, Offers } from \"./client/Offer\";\nimport { ClientContext } from \"./ClientContext\";\nimport { parseConnectionString } from \"./common\";\nimport { Constants } from \"./common/constants\";\nimport { getUserAgent } from \"./common/platform\";\nimport { determineDiagnosticLevel, getDiagnosticLevelFromEnvironment } from \"./diagnostics\";\nimport { DiagnosticNodeType } from \"./diagnostics/DiagnosticNodeInternal\";\nimport { defaultConnectionPolicy } from \"./documents\";\nimport { GlobalEndpointManager } from \"./globalEndpointManager\";\nimport { ResourceResponse } from \"./request\";\nimport { checkURL } from \"./utils/checkURL\";\nimport { getEmptyCosmosDiagnostics, withDiagnostics } from \"./utils/diagnostics\";\n/**\n * Provides a client-side logical representation of the Azure Cosmos DB database account.\n * This client is used to configure and execute requests in the Azure Cosmos DB database service.\n * @example Instantiate a client and create a new database\n * ```typescript\n * const client = new CosmosClient({endpoint: \"<URL HERE>\", key: \"<KEY HERE>\"});\n * await client.databases.create({id: \"<database name here>\"});\n * ```\n * @example Instantiate a client with custom Connection Policy\n * ```typescript\n * const client = new CosmosClient({\n *    endpoint: \"<URL HERE>\",\n *    key: \"<KEY HERE>\",\n *    connectionPolicy: {\n *     requestTimeout: 10000,\n *    },\n * });\n * ```\n */\nexport class CosmosClient {\n  constructor(optionsOrConnectionString) {\n    var _a, _b;\n    if (typeof optionsOrConnectionString === \"string\") {\n      optionsOrConnectionString = parseConnectionString(optionsOrConnectionString);\n    }\n    const endpoint = checkURL(optionsOrConnectionString.endpoint);\n    if (!endpoint) {\n      throw new Error(\"Invalid endpoint specified\");\n    }\n    const clientConfig = this.initializeClientConfigDiagnostic(optionsOrConnectionString);\n    optionsOrConnectionString.connectionPolicy = Object.assign({}, defaultConnectionPolicy, optionsOrConnectionString.connectionPolicy);\n    optionsOrConnectionString.defaultHeaders = optionsOrConnectionString.defaultHeaders || {};\n    optionsOrConnectionString.defaultHeaders[Constants.HttpHeaders.CacheControl] = \"no-cache\";\n    optionsOrConnectionString.defaultHeaders[Constants.HttpHeaders.Version] = Constants.CurrentVersion;\n    if (optionsOrConnectionString.consistencyLevel !== undefined) {\n      optionsOrConnectionString.defaultHeaders[Constants.HttpHeaders.ConsistencyLevel] = optionsOrConnectionString.consistencyLevel;\n    }\n    optionsOrConnectionString.defaultHeaders[Constants.HttpHeaders.UserAgent] = getUserAgent(optionsOrConnectionString.userAgentSuffix);\n    const globalEndpointManager = new GlobalEndpointManager(optionsOrConnectionString, async (diagnosticNode, opts) => this.getDatabaseAccountInternal(diagnosticNode, opts));\n    this.clientContext = new ClientContext(optionsOrConnectionString, globalEndpointManager, clientConfig, determineDiagnosticLevel(optionsOrConnectionString.diagnosticLevel, getDiagnosticLevelFromEnvironment()));\n    if (((_a = optionsOrConnectionString.connectionPolicy) === null || _a === void 0 ? void 0 : _a.enableEndpointDiscovery) && ((_b = optionsOrConnectionString.connectionPolicy) === null || _b === void 0 ? void 0 : _b.enableBackgroundEndpointRefreshing)) {\n      this.backgroundRefreshEndpointList(globalEndpointManager, optionsOrConnectionString.connectionPolicy.endpointRefreshRateInMs || defaultConnectionPolicy.endpointRefreshRateInMs);\n    }\n    this.databases = new Databases(this, this.clientContext);\n    this.offers = new Offers(this, this.clientContext);\n  }\n  initializeClientConfigDiagnostic(optionsOrConnectionString) {\n    return {\n      endpoint: optionsOrConnectionString.endpoint,\n      resourceTokensConfigured: optionsOrConnectionString.resourceTokens !== undefined,\n      tokenProviderConfigured: optionsOrConnectionString.tokenProvider !== undefined,\n      aadCredentialsConfigured: optionsOrConnectionString.aadCredentials !== undefined,\n      connectionPolicyConfigured: optionsOrConnectionString.connectionPolicy !== undefined,\n      consistencyLevel: optionsOrConnectionString.consistencyLevel,\n      defaultHeaders: optionsOrConnectionString.defaultHeaders,\n      agentConfigured: optionsOrConnectionString.agent !== undefined,\n      userAgentSuffix: optionsOrConnectionString.userAgentSuffix,\n      diagnosticLevel: optionsOrConnectionString.diagnosticLevel,\n      pluginsConfigured: optionsOrConnectionString.plugins !== undefined,\n      sDKVersion: Constants.SDKVersion\n    };\n  }\n  /**\n   * Get information about the current {@link DatabaseAccount} (including which regions are supported, etc.)\n   */\n  async getDatabaseAccount(options) {\n    return withDiagnostics(async diagnosticNode => {\n      return this.getDatabaseAccountInternal(diagnosticNode, options);\n    }, this.clientContext);\n  }\n  /**\n   * @hidden\n   */\n  async getDatabaseAccountInternal(diagnosticNode, options) {\n    const response = await this.clientContext.getDatabaseAccount(diagnosticNode, options);\n    return new ResourceResponse(response.result, response.headers, response.code, getEmptyCosmosDiagnostics(), response.substatus);\n  }\n  /**\n   * Gets the currently used write endpoint url. Useful for troubleshooting purposes.\n   *\n   * The url may contain a region suffix (e.g. \"-eastus\") if we're using location specific endpoints.\n   */\n  async getWriteEndpoint() {\n    return withDiagnostics(async diagnosticNode => {\n      return this.clientContext.getWriteEndpoint(diagnosticNode);\n    }, this.clientContext);\n  }\n  /**\n   * Gets the currently used read endpoint. Useful for troubleshooting purposes.\n   *\n   * The url may contain a region suffix (e.g. \"-eastus\") if we're using location specific endpoints.\n   */\n  async getReadEndpoint() {\n    return withDiagnostics(async diagnosticNode => {\n      return this.clientContext.getReadEndpoint(diagnosticNode);\n    }, this.clientContext);\n  }\n  /**\n   * Gets the known write endpoints. Useful for troubleshooting purposes.\n   *\n   * The urls may contain a region suffix (e.g. \"-eastus\") if we're using location specific endpoints.\n   */\n  getWriteEndpoints() {\n    return this.clientContext.getWriteEndpoints();\n  }\n  /**\n   * Gets the currently used read endpoint. Useful for troubleshooting purposes.\n   *\n   * The url may contain a region suffix (e.g. \"-eastus\") if we're using location specific endpoints.\n   */\n  getReadEndpoints() {\n    return this.clientContext.getReadEndpoints();\n  }\n  /**\n   * Used for reading, updating, or deleting a existing database by id or accessing containers belonging to that database.\n   *\n   * This does not make a network call. Use `.read` to get info about the database after getting the {@link Database} object.\n   *\n   * @param id - The id of the database.\n   * @example Create a new container off of an existing database\n   * ```typescript\n   * const container = client.database(\"<database id>\").containers.create(\"<container id>\");\n   * ```\n   *\n   * @example Delete an existing database\n   * ```typescript\n   * await client.database(\"<id here>\").delete();\n   * ```\n   */\n  database(id) {\n    return new Database(this, id, this.clientContext);\n  }\n  /**\n   * Used for reading, or updating a existing offer by id.\n   * @param id - The id of the offer.\n   */\n  offer(id) {\n    return new Offer(this, id, this.clientContext);\n  }\n  /**\n   * Clears background endpoint refresher. Use client.dispose() when destroying the CosmosClient within another process.\n   */\n  dispose() {\n    clearTimeout(this.endpointRefresher);\n  }\n  async backgroundRefreshEndpointList(globalEndpointManager, refreshRate) {\n    this.endpointRefresher = setInterval(() => {\n      try {\n        return withDiagnostics(async diagnosticNode => {\n          return globalEndpointManager.refreshEndpointList(diagnosticNode);\n        }, this.clientContext, DiagnosticNodeType.BACKGROUND_REFRESH_THREAD);\n      } catch (e) {\n        console.warn(\"Failed to refresh endpoints\", e);\n      }\n    }, refreshRate);\n    if (this.endpointRefresher.unref && typeof this.endpointRefresher.unref === \"function\") {\n      this.endpointRefresher.unref();\n    }\n  }\n}","map":{"version":3,"names":["Database","Databases","Offer","Offers","ClientContext","parseConnectionString","Constants","getUserAgent","determineDiagnosticLevel","getDiagnosticLevelFromEnvironment","DiagnosticNodeType","defaultConnectionPolicy","GlobalEndpointManager","ResourceResponse","checkURL","getEmptyCosmosDiagnostics","withDiagnostics","CosmosClient","constructor","optionsOrConnectionString","endpoint","Error","clientConfig","initializeClientConfigDiagnostic","connectionPolicy","Object","assign","defaultHeaders","HttpHeaders","CacheControl","Version","CurrentVersion","consistencyLevel","undefined","ConsistencyLevel","UserAgent","userAgentSuffix","globalEndpointManager","diagnosticNode","opts","getDatabaseAccountInternal","clientContext","diagnosticLevel","_a","enableEndpointDiscovery","_b","enableBackgroundEndpointRefreshing","backgroundRefreshEndpointList","endpointRefreshRateInMs","databases","offers","resourceTokensConfigured","resourceTokens","tokenProviderConfigured","tokenProvider","aadCredentialsConfigured","aadCredentials","connectionPolicyConfigured","agentConfigured","agent","pluginsConfigured","plugins","sDKVersion","SDKVersion","getDatabaseAccount","options","response","result","headers","code","substatus","getWriteEndpoint","getReadEndpoint","getWriteEndpoints","getReadEndpoints","database","id","offer","dispose","clearTimeout","endpointRefresher","refreshRate","setInterval","refreshEndpointList","BACKGROUND_REFRESH_THREAD","e","console","warn","unref"],"sources":["/Users/ajitpawar/microsoft/bap/POCs/Scenario_checker_for_maker/mcs-scenario-checker-for-maker/node_modules/@azure/cosmos/src/CosmosClient.ts"],"sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport { Database, Databases } from \"./client/Database\";\nimport { Offer, Offers } from \"./client/Offer\";\nimport { ClientContext } from \"./ClientContext\";\nimport { parseConnectionString } from \"./common\";\nimport { Constants } from \"./common/constants\";\nimport { getUserAgent } from \"./common/platform\";\nimport type { CosmosClientOptions } from \"./CosmosClientOptions\";\nimport type { ClientConfigDiagnostic } from \"./CosmosDiagnostics\";\nimport { determineDiagnosticLevel, getDiagnosticLevelFromEnvironment } from \"./diagnostics\";\nimport type { DiagnosticNodeInternal } from \"./diagnostics/DiagnosticNodeInternal\";\nimport { DiagnosticNodeType } from \"./diagnostics/DiagnosticNodeInternal\";\nimport type { DatabaseAccount } from \"./documents\";\nimport { defaultConnectionPolicy } from \"./documents\";\nimport { GlobalEndpointManager } from \"./globalEndpointManager\";\nimport type { RequestOptions } from \"./request\";\nimport { ResourceResponse } from \"./request\";\nimport { checkURL } from \"./utils/checkURL\";\nimport { getEmptyCosmosDiagnostics, withDiagnostics } from \"./utils/diagnostics\";\n\n/**\n * Provides a client-side logical representation of the Azure Cosmos DB database account.\n * This client is used to configure and execute requests in the Azure Cosmos DB database service.\n * @example Instantiate a client and create a new database\n * ```typescript\n * const client = new CosmosClient({endpoint: \"<URL HERE>\", key: \"<KEY HERE>\"});\n * await client.databases.create({id: \"<database name here>\"});\n * ```\n * @example Instantiate a client with custom Connection Policy\n * ```typescript\n * const client = new CosmosClient({\n *    endpoint: \"<URL HERE>\",\n *    key: \"<KEY HERE>\",\n *    connectionPolicy: {\n *     requestTimeout: 10000,\n *    },\n * });\n * ```\n */\nexport class CosmosClient {\n  /**\n   * Used for creating new databases, or querying/reading all databases.\n   *\n   * Use `.database(id)` to read, replace, or delete a specific, existing database by id.\n   *\n   * @example Create a new database\n   * ```typescript\n   * const {resource: databaseDefinition, database} = await client.databases.create({id: \"<name here>\"});\n   * ```\n   */\n  public readonly databases: Databases;\n  /**\n   * Used for querying & reading all offers.\n   *\n   * Use `.offer(id)` to read, or replace existing offers.\n   */\n  public readonly offers: Offers;\n  private clientContext: ClientContext;\n  private endpointRefresher: NodeJS.Timeout;\n  /**\n   * Creates a new {@link CosmosClient} object from a connection string. Your database connection string can be found in the Azure Portal\n   */\n  constructor(connectionString: string);\n  /**\n   * Creates a new {@link CosmosClient} object. See {@link CosmosClientOptions} for more details on what options you can use.\n   * @param options - bag of options; require at least endpoint and auth to be configured\n   */\n  constructor(options: CosmosClientOptions);\n  constructor(optionsOrConnectionString: string | CosmosClientOptions) {\n    if (typeof optionsOrConnectionString === \"string\") {\n      optionsOrConnectionString = parseConnectionString(optionsOrConnectionString);\n    }\n\n    const endpoint = checkURL(optionsOrConnectionString.endpoint);\n    if (!endpoint) {\n      throw new Error(\"Invalid endpoint specified\");\n    }\n\n    const clientConfig: ClientConfigDiagnostic =\n      this.initializeClientConfigDiagnostic(optionsOrConnectionString);\n\n    optionsOrConnectionString.connectionPolicy = Object.assign(\n      {},\n      defaultConnectionPolicy,\n      optionsOrConnectionString.connectionPolicy,\n    );\n\n    optionsOrConnectionString.defaultHeaders = optionsOrConnectionString.defaultHeaders || {};\n    optionsOrConnectionString.defaultHeaders[Constants.HttpHeaders.CacheControl] = \"no-cache\";\n    optionsOrConnectionString.defaultHeaders[Constants.HttpHeaders.Version] =\n      Constants.CurrentVersion;\n    if (optionsOrConnectionString.consistencyLevel !== undefined) {\n      optionsOrConnectionString.defaultHeaders[Constants.HttpHeaders.ConsistencyLevel] =\n        optionsOrConnectionString.consistencyLevel;\n    }\n\n    optionsOrConnectionString.defaultHeaders[Constants.HttpHeaders.UserAgent] = getUserAgent(\n      optionsOrConnectionString.userAgentSuffix,\n    );\n\n    const globalEndpointManager = new GlobalEndpointManager(\n      optionsOrConnectionString,\n      async (diagnosticNode: DiagnosticNodeInternal, opts: RequestOptions) =>\n        this.getDatabaseAccountInternal(diagnosticNode, opts),\n    );\n\n    this.clientContext = new ClientContext(\n      optionsOrConnectionString,\n      globalEndpointManager,\n      clientConfig,\n      determineDiagnosticLevel(\n        optionsOrConnectionString.diagnosticLevel,\n        getDiagnosticLevelFromEnvironment(),\n      ),\n    );\n    if (\n      optionsOrConnectionString.connectionPolicy?.enableEndpointDiscovery &&\n      optionsOrConnectionString.connectionPolicy?.enableBackgroundEndpointRefreshing\n    ) {\n      this.backgroundRefreshEndpointList(\n        globalEndpointManager,\n        optionsOrConnectionString.connectionPolicy.endpointRefreshRateInMs ||\n          defaultConnectionPolicy.endpointRefreshRateInMs,\n      );\n    }\n\n    this.databases = new Databases(this, this.clientContext);\n    this.offers = new Offers(this, this.clientContext);\n  }\n\n  private initializeClientConfigDiagnostic(\n    optionsOrConnectionString: CosmosClientOptions,\n  ): ClientConfigDiagnostic {\n    return {\n      endpoint: optionsOrConnectionString.endpoint,\n      resourceTokensConfigured: optionsOrConnectionString.resourceTokens !== undefined,\n      tokenProviderConfigured: optionsOrConnectionString.tokenProvider !== undefined,\n      aadCredentialsConfigured: optionsOrConnectionString.aadCredentials !== undefined,\n      connectionPolicyConfigured: optionsOrConnectionString.connectionPolicy !== undefined,\n      consistencyLevel: optionsOrConnectionString.consistencyLevel,\n      defaultHeaders: optionsOrConnectionString.defaultHeaders,\n      agentConfigured: optionsOrConnectionString.agent !== undefined,\n      userAgentSuffix: optionsOrConnectionString.userAgentSuffix,\n      diagnosticLevel: optionsOrConnectionString.diagnosticLevel,\n      pluginsConfigured: optionsOrConnectionString.plugins !== undefined,\n      sDKVersion: Constants.SDKVersion,\n    };\n  }\n\n  /**\n   * Get information about the current {@link DatabaseAccount} (including which regions are supported, etc.)\n   */\n  public async getDatabaseAccount(\n    options?: RequestOptions,\n  ): Promise<ResourceResponse<DatabaseAccount>> {\n    return withDiagnostics(async (diagnosticNode: DiagnosticNodeInternal) => {\n      return this.getDatabaseAccountInternal(diagnosticNode, options);\n    }, this.clientContext);\n  }\n\n  /**\n   * @hidden\n   */\n  public async getDatabaseAccountInternal(\n    diagnosticNode: DiagnosticNodeInternal,\n    options?: RequestOptions,\n  ): Promise<ResourceResponse<DatabaseAccount>> {\n    const response = await this.clientContext.getDatabaseAccount(diagnosticNode, options);\n    return new ResourceResponse<DatabaseAccount>(\n      response.result,\n      response.headers,\n      response.code,\n      getEmptyCosmosDiagnostics(),\n      response.substatus,\n    );\n  }\n\n  /**\n   * Gets the currently used write endpoint url. Useful for troubleshooting purposes.\n   *\n   * The url may contain a region suffix (e.g. \"-eastus\") if we're using location specific endpoints.\n   */\n  public async getWriteEndpoint(): Promise<string> {\n    return withDiagnostics(async (diagnosticNode: DiagnosticNodeInternal) => {\n      return this.clientContext.getWriteEndpoint(diagnosticNode);\n    }, this.clientContext);\n  }\n\n  /**\n   * Gets the currently used read endpoint. Useful for troubleshooting purposes.\n   *\n   * The url may contain a region suffix (e.g. \"-eastus\") if we're using location specific endpoints.\n   */\n  public async getReadEndpoint(): Promise<string> {\n    return withDiagnostics(async (diagnosticNode: DiagnosticNodeInternal) => {\n      return this.clientContext.getReadEndpoint(diagnosticNode);\n    }, this.clientContext);\n  }\n\n  /**\n   * Gets the known write endpoints. Useful for troubleshooting purposes.\n   *\n   * The urls may contain a region suffix (e.g. \"-eastus\") if we're using location specific endpoints.\n   */\n  public getWriteEndpoints(): Promise<readonly string[]> {\n    return this.clientContext.getWriteEndpoints();\n  }\n\n  /**\n   * Gets the currently used read endpoint. Useful for troubleshooting purposes.\n   *\n   * The url may contain a region suffix (e.g. \"-eastus\") if we're using location specific endpoints.\n   */\n  public getReadEndpoints(): Promise<readonly string[]> {\n    return this.clientContext.getReadEndpoints();\n  }\n\n  /**\n   * Used for reading, updating, or deleting a existing database by id or accessing containers belonging to that database.\n   *\n   * This does not make a network call. Use `.read` to get info about the database after getting the {@link Database} object.\n   *\n   * @param id - The id of the database.\n   * @example Create a new container off of an existing database\n   * ```typescript\n   * const container = client.database(\"<database id>\").containers.create(\"<container id>\");\n   * ```\n   *\n   * @example Delete an existing database\n   * ```typescript\n   * await client.database(\"<id here>\").delete();\n   * ```\n   */\n  public database(id: string): Database {\n    return new Database(this, id, this.clientContext);\n  }\n\n  /**\n   * Used for reading, or updating a existing offer by id.\n   * @param id - The id of the offer.\n   */\n  public offer(id: string): Offer {\n    return new Offer(this, id, this.clientContext);\n  }\n\n  /**\n   * Clears background endpoint refresher. Use client.dispose() when destroying the CosmosClient within another process.\n   */\n  public dispose(): void {\n    clearTimeout(this.endpointRefresher);\n  }\n\n  private async backgroundRefreshEndpointList(\n    globalEndpointManager: GlobalEndpointManager,\n    refreshRate: number,\n  ) {\n    this.endpointRefresher = setInterval(() => {\n      try {\n        return withDiagnostics(\n          async (diagnosticNode: DiagnosticNodeInternal) => {\n            return globalEndpointManager.refreshEndpointList(diagnosticNode);\n          },\n          this.clientContext,\n          DiagnosticNodeType.BACKGROUND_REFRESH_THREAD,\n        );\n      } catch (e: any) {\n        console.warn(\"Failed to refresh endpoints\", e);\n      }\n    }, refreshRate);\n    if (this.endpointRefresher.unref && typeof this.endpointRefresher.unref === \"function\") {\n      this.endpointRefresher.unref();\n    }\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}