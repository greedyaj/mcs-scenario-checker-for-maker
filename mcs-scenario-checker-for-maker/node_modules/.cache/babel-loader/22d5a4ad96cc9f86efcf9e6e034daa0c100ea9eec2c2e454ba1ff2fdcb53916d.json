{"ast":null,"code":"import { __asyncGenerator, __await } from \"tslib\";\n// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport { ChangeFeedRange } from \"./ChangeFeedRange\";\nimport { ChangeFeedIteratorResponse } from \"./ChangeFeedIteratorResponse\";\nimport { QueryRange } from \"../../routing\";\nimport { FeedRangeQueue } from \"./FeedRangeQueue\";\nimport { Constants, SubStatusCodes, StatusCodes, ResourceType } from \"../../common\";\nimport { ErrorResponse } from \"../../request\";\nimport { CompositeContinuationToken } from \"./CompositeContinuationToken\";\nimport { extractOverlappingRanges } from \"./changeFeedUtils\";\nimport { getEmptyCosmosDiagnostics, withDiagnostics } from \"../../utils/diagnostics\";\nimport { ChangeFeedMode } from \"./ChangeFeedMode\";\n/**\n * @hidden\n * Provides iterator for change feed for entire container or an epk range.\n *\n * Use `Items.getChangeFeedIterator()` to get an instance of the iterator.\n */\nexport class ChangeFeedForEpkRange {\n  /**\n   * @internal\n   */\n  constructor(clientContext, container, partitionKeyRangeCache, resourceId, resourceLink, url, changeFeedOptions, epkRange) {\n    this.clientContext = clientContext;\n    this.container = container;\n    this.partitionKeyRangeCache = partitionKeyRangeCache;\n    this.resourceId = resourceId;\n    this.resourceLink = resourceLink;\n    this.url = url;\n    this.changeFeedOptions = changeFeedOptions;\n    this.epkRange = epkRange;\n    this.generateContinuationToken = () => {\n      return JSON.stringify(new CompositeContinuationToken(this.rId, this.queue.returnSnapshot()));\n    };\n    this.queue = new FeedRangeQueue();\n    this.continuationToken = changeFeedOptions.continuationToken ? JSON.parse(changeFeedOptions.continuationToken) : undefined;\n    this.isInstantiated = false;\n    // startTime is used to store and specify time from which change feed should start reading new changes. StartFromNow flag is used to indicate fetching changes from now.\n    if (changeFeedOptions.startFromNow) {\n      this.startFromNow = true;\n    } else if (changeFeedOptions.startTime) {\n      this.startTime = changeFeedOptions.startTime.toUTCString();\n    }\n  }\n  async setIteratorRid(diagnosticNode) {\n    const {\n      resource\n    } = await this.container.readInternal(diagnosticNode);\n    this.rId = resource._rid;\n  }\n  continuationTokenRidMatchContainerRid() {\n    if (this.continuationToken.rid !== this.rId) {\n      return false;\n    }\n    return true;\n  }\n  async fillChangeFeedQueue(diagnosticNode) {\n    if (this.continuationToken) {\n      // fill the queue with feed ranges in continuation token.\n      await this.fetchContinuationTokenFeedRanges(diagnosticNode);\n    } else {\n      // fill the queue with feed ranges overlapping the given epk range.\n      await this.fetchOverLappingFeedRanges(diagnosticNode);\n    }\n    this.isInstantiated = true;\n  }\n  /**\n   * Fill the queue with the feed ranges overlapping with the given epk range.\n   */\n  async fetchOverLappingFeedRanges(diagnosticNode) {\n    try {\n      const overLappingRanges = await this.partitionKeyRangeCache.getOverlappingRanges(this.url, this.epkRange, diagnosticNode);\n      for (const overLappingRange of overLappingRanges) {\n        const [epkMinHeader, epkMaxHeader] = await extractOverlappingRanges(this.epkRange, overLappingRange);\n        const feedRange = new ChangeFeedRange(overLappingRange.minInclusive, overLappingRange.maxExclusive, \"\", epkMinHeader, epkMaxHeader);\n        this.queue.enqueue(feedRange);\n      }\n    } catch (err) {\n      throw new ErrorResponse(err.message);\n    }\n  }\n  /**\n   * Fill the queue with feed ranges from continuation token\n   */\n  async fetchContinuationTokenFeedRanges(diagnosticNode) {\n    const contToken = this.continuationToken;\n    if (!this.continuationTokenRidMatchContainerRid()) {\n      throw new ErrorResponse(\"The continuation token is not for the current container definition\");\n    } else {\n      for (const cToken of contToken.Continuation) {\n        const queryRange = new QueryRange(cToken.minInclusive, cToken.maxExclusive, true, false);\n        try {\n          const overLappingRanges = await this.partitionKeyRangeCache.getOverlappingRanges(this.url, queryRange, diagnosticNode);\n          for (const overLappingRange of overLappingRanges) {\n            // check if the epk range present in continuation token entirely covers the overlapping range.\n            // If yes, minInclusive and maxExclusive of the overlapping range will be set.\n            // If no, i.e. there is only partial overlap, epkMinHeader and epkMaxHeader are set as min and max of overlap.\n            // This will be used when we make a call to fetch change feed.\n            const [epkMinHeader, epkMaxHeader] = await extractOverlappingRanges(queryRange, overLappingRange);\n            const feedRange = new ChangeFeedRange(overLappingRange.minInclusive, overLappingRange.maxExclusive, cToken.continuationToken, epkMinHeader, epkMaxHeader);\n            this.queue.enqueue(feedRange);\n          }\n        } catch (err) {\n          throw new ErrorResponse(err.message);\n        }\n      }\n    }\n  }\n  /**\n   * Change feed is an infinite feed. hasMoreResults is always true.\n   */\n  get hasMoreResults() {\n    return true;\n  }\n  /**\n   * Gets an async iterator which will yield change feed results.\n   */\n  getAsyncIterator() {\n    return __asyncGenerator(this, arguments, function* getAsyncIterator_1() {\n      do {\n        const result = yield __await(this.readNext());\n        yield yield __await(result);\n      } while (this.hasMoreResults);\n    });\n  }\n  /**\n   * Gets an async iterator which will yield pages of results from Azure Cosmos DB.\n   *\n   * Keeps iterating over the feedranges and checks if any feed range has new result. Keeps note of the last feed range which returned non 304 result.\n   *\n   * When same feed range is reached and no new changes are found, a 304 (not Modified) is returned to the end user. Then starts process all over again.\n   */\n  async readNext() {\n    return withDiagnostics(async diagnosticNode => {\n      // validate if the internal queue is filled up with feed ranges.\n      if (!this.isInstantiated) {\n        await this.setIteratorRid(diagnosticNode);\n        await this.fillChangeFeedQueue(diagnosticNode);\n      }\n      // stores the last feedRange for which statusCode is not 304 i.e. there were new changes in that feed range.\n      let firstNotModifiedFeedRange = undefined;\n      let result;\n      do {\n        const [processedFeedRange, response] = await this.fetchNext(diagnosticNode);\n        result = response;\n        if (result !== undefined) {\n          {\n            if (firstNotModifiedFeedRange === undefined) {\n              firstNotModifiedFeedRange = processedFeedRange;\n            }\n            // move current feed range to end of queue to fetch result of next feed range.\n            // This is done to fetch changes in breadth first manner and avoid starvation.\n            this.queue.moveFirstElementToTheEnd();\n            // check if there are new results for the given feed range.\n            if (result.statusCode === StatusCodes.Ok) {\n              result.headers[Constants.HttpHeaders.ContinuationToken] = this.generateContinuationToken();\n              return result;\n            }\n          }\n        }\n      } while (!this.checkedAllFeedRanges(firstNotModifiedFeedRange));\n      // set the continuation token after processing.\n      result.headers[Constants.HttpHeaders.ContinuationToken] = this.generateContinuationToken();\n      return result;\n    }, this.clientContext);\n  }\n  /**\n   * Read feed and retrieves the next page of results in Azure Cosmos DB.\n   */\n  async fetchNext(diagnosticNode) {\n    const feedRange = this.queue.peek();\n    if (feedRange) {\n      // fetch results for feed range at the beginning of the queue.\n      const result = await this.getFeedResponse(feedRange, diagnosticNode);\n      // check if results need to be fetched again depending on status code returned.\n      // Eg. in case of paritionSplit, results need to be fetched for the child partitions.\n      const shouldRetry = await this.shouldRetryOnFailure(feedRange, result, diagnosticNode);\n      if (shouldRetry) {\n        this.queue.dequeue();\n        return this.fetchNext(diagnosticNode);\n      } else {\n        // update the continuation value for the current feed range.\n        const continuationValueForFeedRange = result.headers[Constants.HttpHeaders.ETag];\n        const newFeedRange = this.queue.peek();\n        newFeedRange.continuationToken = continuationValueForFeedRange;\n        return [[newFeedRange.minInclusive, newFeedRange.maxExclusive], result];\n      }\n    } else {\n      return [[undefined, undefined], undefined];\n    }\n  }\n  checkedAllFeedRanges(firstNotModifiedFeedRange) {\n    if (firstNotModifiedFeedRange === undefined) {\n      return false;\n    }\n    const feedRangeQueueFirstElement = this.queue.peek();\n    return firstNotModifiedFeedRange[0] === (feedRangeQueueFirstElement === null || feedRangeQueueFirstElement === void 0 ? void 0 : feedRangeQueueFirstElement.minInclusive) && firstNotModifiedFeedRange[1] === (feedRangeQueueFirstElement === null || feedRangeQueueFirstElement === void 0 ? void 0 : feedRangeQueueFirstElement.maxExclusive);\n  }\n  /**\n   * Checks whether the current EpkRange is split into multiple ranges or not.\n   *\n   * If yes, it force refreshes the partitionKeyRange cache and enqueue children epk ranges.\n   */\n  async shouldRetryOnFailure(feedRange, response, diagnosticNode) {\n    if (response.statusCode === StatusCodes.Ok || response.statusCode === StatusCodes.NotModified) {\n      return false;\n    }\n    const partitionSplit = response.statusCode === StatusCodes.Gone && (response.subStatusCode === SubStatusCodes.PartitionKeyRangeGone || response.subStatusCode === SubStatusCodes.CompletingSplit);\n    if (partitionSplit) {\n      const queryRange = new QueryRange(feedRange.epkMinHeader ? feedRange.epkMinHeader : feedRange.minInclusive, feedRange.epkMaxHeader ? feedRange.epkMaxHeader : feedRange.maxExclusive, true, false);\n      const resolvedRanges = await this.partitionKeyRangeCache.getOverlappingRanges(this.url, queryRange, diagnosticNode, true);\n      if (resolvedRanges.length < 1) {\n        throw new ErrorResponse(\"Partition split/merge detected but no overlapping ranges found.\");\n      }\n      // This covers both cases of merge and split.\n      // resolvedRanges.length > 1 in case of split.\n      // resolvedRanges.length === 1 in case of merge. EpkRange headers will be added in this case.\n      if (resolvedRanges.length >= 1) {\n        await this.handleSplit(false, resolvedRanges, queryRange, feedRange.continuationToken);\n      }\n      return true;\n    }\n    return false;\n  }\n  /*\n   * Enqueues all the children feed ranges for the given feed range.\n   */\n  async handleSplit(shiftLeft, resolvedRanges, oldFeedRange, continuationToken) {\n    let flag = 0;\n    if (shiftLeft) {\n      // This section is only applicable when handleSplit is called by getPartitionRangeId().\n      // used only when existing partition key range cache is used to check for any overlapping ranges.\n      // Modifies the first element with the first overlapping range.\n      const [epkMinHeader, epkMaxHeader] = await extractOverlappingRanges(oldFeedRange, resolvedRanges[0]);\n      const newFeedRange = new ChangeFeedRange(resolvedRanges[0].minInclusive, resolvedRanges[0].maxExclusive, continuationToken, epkMinHeader, epkMaxHeader);\n      this.queue.modifyFirstElement(newFeedRange);\n      flag = 1;\n    }\n    // Enqueue the overlapping ranges.\n    for (let i = flag; i < resolvedRanges.length; i++) {\n      const [epkMinHeader, epkMaxHeader] = await extractOverlappingRanges(oldFeedRange, resolvedRanges[i]);\n      const newFeedRange = new ChangeFeedRange(resolvedRanges[i].minInclusive, resolvedRanges[i].maxExclusive, continuationToken, epkMinHeader, epkMaxHeader);\n      this.queue.enqueue(newFeedRange);\n    }\n  }\n  /**\n   * Fetch the partitionKeyRangeId for the given feed range.\n   *\n   * This partitionKeyRangeId is passed to queryFeed to fetch the results.\n   */\n  async getPartitionRangeId(feedRange, diagnosticNode) {\n    const min = feedRange.epkMinHeader ? feedRange.epkMinHeader : feedRange.minInclusive;\n    const max = feedRange.epkMaxHeader ? feedRange.epkMaxHeader : feedRange.maxExclusive;\n    const queryRange = new QueryRange(min, max, true, false);\n    const resolvedRanges = await this.partitionKeyRangeCache.getOverlappingRanges(this.url, queryRange, diagnosticNode, false);\n    if (resolvedRanges.length < 1) {\n      throw new ErrorResponse(\"No overlapping ranges found.\");\n    }\n    const firstResolvedRange = resolvedRanges[0];\n    if (resolvedRanges.length > 1) {\n      await this.handleSplit(true, resolvedRanges, queryRange, feedRange.continuationToken);\n    }\n    return firstResolvedRange.id;\n  }\n  async getFeedResponse(feedRange, diagnosticNode) {\n    const feedOptions = {\n      initialHeaders: {},\n      useLatestVersionFeed: true,\n      useAllVersionsAndDeletesFeed: false\n    };\n    if (typeof this.changeFeedOptions.maxItemCount === \"number\") {\n      feedOptions.maxItemCount = this.changeFeedOptions.maxItemCount;\n    }\n    if (this.changeFeedOptions.sessionToken) {\n      feedOptions.sessionToken = this.changeFeedOptions.sessionToken;\n    }\n    if (feedRange.continuationToken) {\n      feedOptions.accessCondition = {\n        type: Constants.HttpHeaders.IfNoneMatch,\n        condition: feedRange.continuationToken\n      };\n    } else if (this.startFromNow) {\n      feedOptions.initialHeaders[Constants.HttpHeaders.IfNoneMatch] = Constants.ChangeFeedIfNoneMatchStartFromNowHeader;\n    }\n    if (this.startTime) {\n      feedOptions.initialHeaders[Constants.HttpHeaders.IfModifiedSince] = this.startTime;\n    }\n    if (this.changeFeedOptions.changeFeedMode && this.changeFeedOptions.changeFeedMode === ChangeFeedMode.AllVersionsAndDeletes) {\n      feedOptions.useAllVersionsAndDeletesFeed = true;\n      feedOptions.useLatestVersionFeed = false;\n    }\n    const rangeId = await this.getPartitionRangeId(feedRange, diagnosticNode);\n    try {\n      // startEpk and endEpk are only valid in case we want to fetch result for a part of partition and not the entire partition.\n      const response = await this.clientContext.queryFeed({\n        path: this.resourceLink,\n        resourceType: ResourceType.item,\n        resourceId: this.resourceId,\n        resultFn: result => result ? result.Documents : [],\n        query: undefined,\n        options: feedOptions,\n        diagnosticNode,\n        partitionKey: undefined,\n        partitionKeyRangeId: rangeId,\n        startEpk: feedRange.epkMinHeader,\n        endEpk: feedRange.epkMaxHeader\n      });\n      return new ChangeFeedIteratorResponse(response.result, response.result ? response.result.length : 0, response.code, response.headers, getEmptyCosmosDiagnostics());\n    } catch (err) {\n      if (err.code >= StatusCodes.BadRequest && err.code !== StatusCodes.Gone) {\n        const errorResponse = new ErrorResponse(err.message);\n        errorResponse.code = err.code;\n        errorResponse.headers = err.headers;\n        throw errorResponse;\n      }\n      // If any other errors are encountered, eg. partition split or gone, handle it based on error code and not break the flow.\n      return new ChangeFeedIteratorResponse([], 0, err.code, err.headers, getEmptyCosmosDiagnostics(), err.substatus);\n    }\n  }\n}","map":{"version":3,"names":["ChangeFeedRange","ChangeFeedIteratorResponse","QueryRange","FeedRangeQueue","Constants","SubStatusCodes","StatusCodes","ResourceType","ErrorResponse","CompositeContinuationToken","extractOverlappingRanges","getEmptyCosmosDiagnostics","withDiagnostics","ChangeFeedMode","ChangeFeedForEpkRange","constructor","clientContext","container","partitionKeyRangeCache","resourceId","resourceLink","url","changeFeedOptions","epkRange","generateContinuationToken","JSON","stringify","rId","queue","returnSnapshot","continuationToken","parse","undefined","isInstantiated","startFromNow","startTime","toUTCString","setIteratorRid","diagnosticNode","resource","readInternal","_rid","continuationTokenRidMatchContainerRid","rid","fillChangeFeedQueue","fetchContinuationTokenFeedRanges","fetchOverLappingFeedRanges","overLappingRanges","getOverlappingRanges","overLappingRange","epkMinHeader","epkMaxHeader","feedRange","minInclusive","maxExclusive","enqueue","err","message","contToken","cToken","Continuation","queryRange","hasMoreResults","getAsyncIterator","result","__await","readNext","firstNotModifiedFeedRange","processedFeedRange","response","fetchNext","moveFirstElementToTheEnd","statusCode","Ok","headers","HttpHeaders","ContinuationToken","checkedAllFeedRanges","peek","getFeedResponse","shouldRetry","shouldRetryOnFailure","dequeue","continuationValueForFeedRange","ETag","newFeedRange","feedRangeQueueFirstElement","NotModified","partitionSplit","Gone","subStatusCode","PartitionKeyRangeGone","CompletingSplit","resolvedRanges","length","handleSplit","shiftLeft","oldFeedRange","flag","modifyFirstElement","i","getPartitionRangeId","min","max","firstResolvedRange","id","feedOptions","initialHeaders","useLatestVersionFeed","useAllVersionsAndDeletesFeed","maxItemCount","sessionToken","accessCondition","type","IfNoneMatch","condition","ChangeFeedIfNoneMatchStartFromNowHeader","IfModifiedSince","changeFeedMode","AllVersionsAndDeletes","rangeId","queryFeed","path","resourceType","item","resultFn","Documents","query","options","partitionKey","partitionKeyRangeId","startEpk","endEpk","code","BadRequest","errorResponse","substatus"],"sources":["/Users/ajitpawar/microsoft/bap/POCs/Scenario_checker_for_maker/mcs-scenario-checker-for-maker/node_modules/@azure/cosmos/src/client/ChangeFeed/ChangeFeedForEpkRange.ts"],"sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport { ChangeFeedRange } from \"./ChangeFeedRange\";\nimport { ChangeFeedIteratorResponse } from \"./ChangeFeedIteratorResponse\";\nimport type { PartitionKeyRangeCache } from \"../../routing\";\nimport { QueryRange } from \"../../routing\";\nimport { FeedRangeQueue } from \"./FeedRangeQueue\";\nimport type { ClientContext } from \"../../ClientContext\";\nimport type { Container, Resource } from \"../../client\";\nimport { Constants, SubStatusCodes, StatusCodes, ResourceType } from \"../../common\";\nimport type { Response, FeedOptions } from \"../../request\";\nimport { ErrorResponse } from \"../../request\";\nimport { CompositeContinuationToken } from \"./CompositeContinuationToken\";\nimport type { ChangeFeedPullModelIterator } from \"./ChangeFeedPullModelIterator\";\nimport { extractOverlappingRanges } from \"./changeFeedUtils\";\nimport type { InternalChangeFeedIteratorOptions } from \"./InternalChangeFeedOptions\";\nimport type { DiagnosticNodeInternal } from \"../../diagnostics/DiagnosticNodeInternal\";\nimport { getEmptyCosmosDiagnostics, withDiagnostics } from \"../../utils/diagnostics\";\nimport { ChangeFeedMode } from \"./ChangeFeedMode\";\n/**\n * @hidden\n * Provides iterator for change feed for entire container or an epk range.\n *\n * Use `Items.getChangeFeedIterator()` to get an instance of the iterator.\n */\nexport class ChangeFeedForEpkRange<T> implements ChangeFeedPullModelIterator<T> {\n  private continuationToken?: CompositeContinuationToken;\n  private queue: FeedRangeQueue<ChangeFeedRange>;\n  private startTime: string;\n  private isInstantiated: boolean;\n  private rId: string;\n  private startFromNow: boolean;\n  /**\n   * @internal\n   */\n  constructor(\n    private clientContext: ClientContext,\n    private container: Container,\n    private partitionKeyRangeCache: PartitionKeyRangeCache,\n    private resourceId: string,\n    private resourceLink: string,\n    private url: string,\n    private changeFeedOptions: InternalChangeFeedIteratorOptions,\n    private epkRange: QueryRange,\n  ) {\n    this.queue = new FeedRangeQueue<ChangeFeedRange>();\n    this.continuationToken = changeFeedOptions.continuationToken\n      ? JSON.parse(changeFeedOptions.continuationToken)\n      : undefined;\n    this.isInstantiated = false;\n    // startTime is used to store and specify time from which change feed should start reading new changes. StartFromNow flag is used to indicate fetching changes from now.\n    if (changeFeedOptions.startFromNow) {\n      this.startFromNow = true;\n    } else if (changeFeedOptions.startTime) {\n      this.startTime = changeFeedOptions.startTime.toUTCString();\n    }\n  }\n\n  private async setIteratorRid(diagnosticNode: DiagnosticNodeInternal): Promise<void> {\n    const { resource } = await this.container.readInternal(diagnosticNode);\n    this.rId = resource._rid;\n  }\n\n  private continuationTokenRidMatchContainerRid(): boolean {\n    if (this.continuationToken.rid !== this.rId) {\n      return false;\n    }\n    return true;\n  }\n\n  private async fillChangeFeedQueue(diagnosticNode: DiagnosticNodeInternal): Promise<void> {\n    if (this.continuationToken) {\n      // fill the queue with feed ranges in continuation token.\n      await this.fetchContinuationTokenFeedRanges(diagnosticNode);\n    } else {\n      // fill the queue with feed ranges overlapping the given epk range.\n      await this.fetchOverLappingFeedRanges(diagnosticNode);\n    }\n    this.isInstantiated = true;\n  }\n\n  /**\n   * Fill the queue with the feed ranges overlapping with the given epk range.\n   */\n  private async fetchOverLappingFeedRanges(diagnosticNode: DiagnosticNodeInternal): Promise<void> {\n    try {\n      const overLappingRanges = await this.partitionKeyRangeCache.getOverlappingRanges(\n        this.url,\n        this.epkRange,\n        diagnosticNode,\n      );\n      for (const overLappingRange of overLappingRanges) {\n        const [epkMinHeader, epkMaxHeader] = await extractOverlappingRanges(\n          this.epkRange,\n          overLappingRange,\n        );\n        const feedRange: ChangeFeedRange = new ChangeFeedRange(\n          overLappingRange.minInclusive,\n          overLappingRange.maxExclusive,\n          \"\",\n          epkMinHeader,\n          epkMaxHeader,\n        );\n        this.queue.enqueue(feedRange);\n      }\n    } catch (err) {\n      throw new ErrorResponse(err.message);\n    }\n  }\n  /**\n   * Fill the queue with feed ranges from continuation token\n   */\n  private async fetchContinuationTokenFeedRanges(\n    diagnosticNode: DiagnosticNodeInternal,\n  ): Promise<void> {\n    const contToken = this.continuationToken;\n    if (!this.continuationTokenRidMatchContainerRid()) {\n      throw new ErrorResponse(\"The continuation token is not for the current container definition\");\n    } else {\n      for (const cToken of contToken.Continuation) {\n        const queryRange = new QueryRange(cToken.minInclusive, cToken.maxExclusive, true, false);\n        try {\n          const overLappingRanges = await this.partitionKeyRangeCache.getOverlappingRanges(\n            this.url,\n            queryRange,\n            diagnosticNode,\n          );\n          for (const overLappingRange of overLappingRanges) {\n            // check if the epk range present in continuation token entirely covers the overlapping range.\n            // If yes, minInclusive and maxExclusive of the overlapping range will be set.\n            // If no, i.e. there is only partial overlap, epkMinHeader and epkMaxHeader are set as min and max of overlap.\n            // This will be used when we make a call to fetch change feed.\n            const [epkMinHeader, epkMaxHeader] = await extractOverlappingRanges(\n              queryRange,\n              overLappingRange,\n            );\n            const feedRange: ChangeFeedRange = new ChangeFeedRange(\n              overLappingRange.minInclusive,\n              overLappingRange.maxExclusive,\n              cToken.continuationToken,\n              epkMinHeader,\n              epkMaxHeader,\n            );\n            this.queue.enqueue(feedRange);\n          }\n        } catch (err) {\n          throw new ErrorResponse(err.message);\n        }\n      }\n    }\n  }\n\n  /**\n   * Change feed is an infinite feed. hasMoreResults is always true.\n   */\n  get hasMoreResults(): boolean {\n    return true;\n  }\n\n  /**\n   * Gets an async iterator which will yield change feed results.\n   */\n  public async *getAsyncIterator(): AsyncIterable<ChangeFeedIteratorResponse<Array<T & Resource>>> {\n    do {\n      const result = await this.readNext();\n      yield result;\n    } while (this.hasMoreResults);\n  }\n\n  /**\n   * Gets an async iterator which will yield pages of results from Azure Cosmos DB.\n   *\n   * Keeps iterating over the feedranges and checks if any feed range has new result. Keeps note of the last feed range which returned non 304 result.\n   *\n   * When same feed range is reached and no new changes are found, a 304 (not Modified) is returned to the end user. Then starts process all over again.\n   */\n  public async readNext(): Promise<ChangeFeedIteratorResponse<Array<T & Resource>>> {\n    return withDiagnostics(async (diagnosticNode: DiagnosticNodeInternal) => {\n      // validate if the internal queue is filled up with feed ranges.\n      if (!this.isInstantiated) {\n        await this.setIteratorRid(diagnosticNode);\n        await this.fillChangeFeedQueue(diagnosticNode);\n      }\n\n      // stores the last feedRange for which statusCode is not 304 i.e. there were new changes in that feed range.\n      let firstNotModifiedFeedRange: [string, string] = undefined;\n      let result: ChangeFeedIteratorResponse<Array<T & Resource>>;\n      do {\n        const [processedFeedRange, response] = await this.fetchNext(diagnosticNode);\n        result = response;\n        if (result !== undefined) {\n          {\n            if (firstNotModifiedFeedRange === undefined) {\n              firstNotModifiedFeedRange = processedFeedRange;\n            }\n            // move current feed range to end of queue to fetch result of next feed range.\n            // This is done to fetch changes in breadth first manner and avoid starvation.\n            this.queue.moveFirstElementToTheEnd();\n            // check if there are new results for the given feed range.\n            if (result.statusCode === StatusCodes.Ok) {\n              result.headers[Constants.HttpHeaders.ContinuationToken] =\n                this.generateContinuationToken();\n              return result;\n            }\n          }\n        }\n      } while (!this.checkedAllFeedRanges(firstNotModifiedFeedRange));\n      // set the continuation token after processing.\n      result.headers[Constants.HttpHeaders.ContinuationToken] = this.generateContinuationToken();\n      return result;\n    }, this.clientContext);\n  }\n\n  private generateContinuationToken = (): string => {\n    return JSON.stringify(new CompositeContinuationToken(this.rId, this.queue.returnSnapshot()));\n  };\n\n  /**\n   * Read feed and retrieves the next page of results in Azure Cosmos DB.\n   */\n  private async fetchNext(\n    diagnosticNode: DiagnosticNodeInternal,\n  ): Promise<[[string, string], ChangeFeedIteratorResponse<Array<T & Resource>>]> {\n    const feedRange = this.queue.peek();\n    if (feedRange) {\n      // fetch results for feed range at the beginning of the queue.\n      const result = await this.getFeedResponse(feedRange, diagnosticNode);\n\n      // check if results need to be fetched again depending on status code returned.\n      // Eg. in case of paritionSplit, results need to be fetched for the child partitions.\n      const shouldRetry: boolean = await this.shouldRetryOnFailure(\n        feedRange,\n        result,\n        diagnosticNode,\n      );\n\n      if (shouldRetry) {\n        this.queue.dequeue();\n        return this.fetchNext(diagnosticNode);\n      } else {\n        // update the continuation value for the current feed range.\n        const continuationValueForFeedRange = result.headers[Constants.HttpHeaders.ETag];\n        const newFeedRange = this.queue.peek();\n        newFeedRange.continuationToken = continuationValueForFeedRange;\n\n        return [[newFeedRange.minInclusive, newFeedRange.maxExclusive], result];\n      }\n    } else {\n      return [[undefined, undefined], undefined];\n    }\n  }\n\n  private checkedAllFeedRanges(firstNotModifiedFeedRange: [string, string]): boolean {\n    if (firstNotModifiedFeedRange === undefined) {\n      return false;\n    }\n    const feedRangeQueueFirstElement = this.queue.peek();\n    return (\n      firstNotModifiedFeedRange[0] === feedRangeQueueFirstElement?.minInclusive &&\n      firstNotModifiedFeedRange[1] === feedRangeQueueFirstElement?.maxExclusive\n    );\n  }\n\n  /**\n   * Checks whether the current EpkRange is split into multiple ranges or not.\n   *\n   * If yes, it force refreshes the partitionKeyRange cache and enqueue children epk ranges.\n   */\n  private async shouldRetryOnFailure(\n    feedRange: ChangeFeedRange,\n    response: ChangeFeedIteratorResponse<Array<T & Resource>>,\n    diagnosticNode: DiagnosticNodeInternal,\n  ): Promise<boolean> {\n    if (response.statusCode === StatusCodes.Ok || response.statusCode === StatusCodes.NotModified) {\n      return false;\n    }\n\n    const partitionSplit =\n      response.statusCode === StatusCodes.Gone &&\n      (response.subStatusCode === SubStatusCodes.PartitionKeyRangeGone ||\n        response.subStatusCode === SubStatusCodes.CompletingSplit);\n\n    if (partitionSplit) {\n      const queryRange = new QueryRange(\n        feedRange.epkMinHeader ? feedRange.epkMinHeader : feedRange.minInclusive,\n        feedRange.epkMaxHeader ? feedRange.epkMaxHeader : feedRange.maxExclusive,\n        true,\n        false,\n      );\n      const resolvedRanges = await this.partitionKeyRangeCache.getOverlappingRanges(\n        this.url,\n        queryRange,\n        diagnosticNode,\n        true,\n      );\n      if (resolvedRanges.length < 1) {\n        throw new ErrorResponse(\"Partition split/merge detected but no overlapping ranges found.\");\n      }\n      // This covers both cases of merge and split.\n      // resolvedRanges.length > 1 in case of split.\n      // resolvedRanges.length === 1 in case of merge. EpkRange headers will be added in this case.\n      if (resolvedRanges.length >= 1) {\n        await this.handleSplit(false, resolvedRanges, queryRange, feedRange.continuationToken);\n      }\n      return true;\n    }\n    return false;\n  }\n  /*\n   * Enqueues all the children feed ranges for the given feed range.\n   */\n  private async handleSplit(\n    shiftLeft: boolean,\n    resolvedRanges: any,\n    oldFeedRange: QueryRange,\n    continuationToken: string,\n  ): Promise<void> {\n    let flag = 0;\n    if (shiftLeft) {\n      // This section is only applicable when handleSplit is called by getPartitionRangeId().\n      // used only when existing partition key range cache is used to check for any overlapping ranges.\n      // Modifies the first element with the first overlapping range.\n      const [epkMinHeader, epkMaxHeader] = await extractOverlappingRanges(\n        oldFeedRange,\n        resolvedRanges[0],\n      );\n      const newFeedRange = new ChangeFeedRange(\n        resolvedRanges[0].minInclusive,\n        resolvedRanges[0].maxExclusive,\n        continuationToken,\n        epkMinHeader,\n        epkMaxHeader,\n      );\n\n      this.queue.modifyFirstElement(newFeedRange);\n      flag = 1;\n    }\n    // Enqueue the overlapping ranges.\n    for (let i = flag; i < resolvedRanges.length; i++) {\n      const [epkMinHeader, epkMaxHeader] = await extractOverlappingRanges(\n        oldFeedRange,\n        resolvedRanges[i],\n      );\n      const newFeedRange = new ChangeFeedRange(\n        resolvedRanges[i].minInclusive,\n        resolvedRanges[i].maxExclusive,\n        continuationToken,\n        epkMinHeader,\n        epkMaxHeader,\n      );\n      this.queue.enqueue(newFeedRange);\n    }\n  }\n\n  /**\n   * Fetch the partitionKeyRangeId for the given feed range.\n   *\n   * This partitionKeyRangeId is passed to queryFeed to fetch the results.\n   */\n  private async getPartitionRangeId(\n    feedRange: ChangeFeedRange,\n    diagnosticNode: DiagnosticNodeInternal,\n  ): Promise<string> {\n    const min = feedRange.epkMinHeader ? feedRange.epkMinHeader : feedRange.minInclusive;\n    const max = feedRange.epkMaxHeader ? feedRange.epkMaxHeader : feedRange.maxExclusive;\n    const queryRange = new QueryRange(min, max, true, false);\n    const resolvedRanges = await this.partitionKeyRangeCache.getOverlappingRanges(\n      this.url,\n      queryRange,\n      diagnosticNode,\n      false,\n    );\n    if (resolvedRanges.length < 1) {\n      throw new ErrorResponse(\"No overlapping ranges found.\");\n    }\n    const firstResolvedRange = resolvedRanges[0];\n    if (resolvedRanges.length > 1) {\n      await this.handleSplit(true, resolvedRanges, queryRange, feedRange.continuationToken);\n    }\n    return firstResolvedRange.id;\n  }\n\n  private async getFeedResponse(\n    feedRange: ChangeFeedRange,\n    diagnosticNode: DiagnosticNodeInternal,\n  ): Promise<ChangeFeedIteratorResponse<Array<T & Resource>>> {\n    const feedOptions: FeedOptions = {\n      initialHeaders: {},\n      useLatestVersionFeed: true,\n      useAllVersionsAndDeletesFeed: false,\n    };\n\n    if (typeof this.changeFeedOptions.maxItemCount === \"number\") {\n      feedOptions.maxItemCount = this.changeFeedOptions.maxItemCount;\n    }\n\n    if (this.changeFeedOptions.sessionToken) {\n      feedOptions.sessionToken = this.changeFeedOptions.sessionToken;\n    }\n\n    if (feedRange.continuationToken) {\n      feedOptions.accessCondition = {\n        type: Constants.HttpHeaders.IfNoneMatch,\n        condition: feedRange.continuationToken,\n      };\n    } else if (this.startFromNow) {\n      feedOptions.initialHeaders[Constants.HttpHeaders.IfNoneMatch] =\n        Constants.ChangeFeedIfNoneMatchStartFromNowHeader;\n    }\n\n    if (this.startTime) {\n      feedOptions.initialHeaders[Constants.HttpHeaders.IfModifiedSince] = this.startTime;\n    }\n\n    if (\n      this.changeFeedOptions.changeFeedMode &&\n      this.changeFeedOptions.changeFeedMode === ChangeFeedMode.AllVersionsAndDeletes\n    ) {\n      feedOptions.useAllVersionsAndDeletesFeed = true;\n      feedOptions.useLatestVersionFeed = false;\n    }\n\n    const rangeId = await this.getPartitionRangeId(feedRange, diagnosticNode);\n    try {\n      // startEpk and endEpk are only valid in case we want to fetch result for a part of partition and not the entire partition.\n      const response: Response<Array<T & Resource>> = await (this.clientContext.queryFeed<T>({\n        path: this.resourceLink,\n        resourceType: ResourceType.item,\n        resourceId: this.resourceId,\n        resultFn: (result) => (result ? result.Documents : []),\n        query: undefined,\n        options: feedOptions,\n        diagnosticNode,\n        partitionKey: undefined,\n        partitionKeyRangeId: rangeId,\n        startEpk: feedRange.epkMinHeader,\n        endEpk: feedRange.epkMaxHeader,\n      }) as Promise<any>);\n\n      return new ChangeFeedIteratorResponse(\n        response.result,\n        response.result ? response.result.length : 0,\n        response.code,\n        response.headers,\n        getEmptyCosmosDiagnostics(),\n      );\n    } catch (err) {\n      if (err.code >= StatusCodes.BadRequest && err.code !== StatusCodes.Gone) {\n        const errorResponse = new ErrorResponse(err.message);\n        errorResponse.code = err.code;\n        errorResponse.headers = err.headers;\n\n        throw errorResponse;\n      }\n\n      // If any other errors are encountered, eg. partition split or gone, handle it based on error code and not break the flow.\n      return new ChangeFeedIteratorResponse(\n        [],\n        0,\n        err.code,\n        err.headers,\n        getEmptyCosmosDiagnostics(),\n        err.substatus,\n      );\n    }\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}