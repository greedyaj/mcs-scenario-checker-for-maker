{"ast":null,"code":"// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport { BytePrefix } from \"./prefix\";\nexport function writeStringForBinaryEncoding(payload) {\n  let outputStream = Buffer.from(BytePrefix.String, \"hex\");\n  const MAX_STRING_BYTES_TO_APPEND = 100;\n  const byteArray = [...Buffer.from(payload)];\n  const isShortString = payload.length <= MAX_STRING_BYTES_TO_APPEND;\n  for (let index = 0; index < (isShortString ? byteArray.length : MAX_STRING_BYTES_TO_APPEND + 1); index++) {\n    let charByte = byteArray[index];\n    if (charByte < 0xff) {\n      charByte++;\n    }\n    outputStream = Buffer.concat([outputStream, Buffer.from(charByte.toString(16), \"hex\")]);\n  }\n  if (isShortString) {\n    outputStream = Buffer.concat([outputStream, Buffer.from(BytePrefix.Undefined, \"hex\")]);\n  }\n  return outputStream;\n}","map":{"version":3,"names":["BytePrefix","writeStringForBinaryEncoding","payload","outputStream","Buffer","from","String","MAX_STRING_BYTES_TO_APPEND","byteArray","isShortString","length","index","charByte","concat","toString","Undefined"],"sources":["/Users/ajitpawar/microsoft/bap/POCs/Scenario_checker_for_maker/mcs-scenario-checker-for-maker/node_modules/@azure/cosmos/src/utils/hashing/encoding/string.ts"],"sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\nimport { BytePrefix } from \"./prefix\";\n\nexport function writeStringForBinaryEncoding(payload: string): Buffer {\n  let outputStream = Buffer.from(BytePrefix.String, \"hex\");\n  const MAX_STRING_BYTES_TO_APPEND = 100;\n  const byteArray = [...Buffer.from(payload)];\n\n  const isShortString = payload.length <= MAX_STRING_BYTES_TO_APPEND;\n\n  for (\n    let index = 0;\n    index < (isShortString ? byteArray.length : MAX_STRING_BYTES_TO_APPEND + 1);\n    index++\n  ) {\n    let charByte = byteArray[index];\n    if (charByte < 0xff) {\n      charByte++;\n    }\n    outputStream = Buffer.concat([outputStream, Buffer.from(charByte.toString(16), \"hex\")]);\n  }\n\n  if (isShortString) {\n    outputStream = Buffer.concat([outputStream, Buffer.from(BytePrefix.Undefined, \"hex\")]);\n  }\n  return outputStream;\n}\n"],"mappings":"AAAA;AACA;AAEA,SAASA,UAAU,QAAQ,UAAU;AAErC,OAAM,SAAUC,4BAA4BA,CAACC,OAAe;EAC1D,IAAIC,YAAY,GAAGC,MAAM,CAACC,IAAI,CAACL,UAAU,CAACM,MAAM,EAAE,KAAK,CAAC;EACxD,MAAMC,0BAA0B,GAAG,GAAG;EACtC,MAAMC,SAAS,GAAG,CAAC,GAAGJ,MAAM,CAACC,IAAI,CAACH,OAAO,CAAC,CAAC;EAE3C,MAAMO,aAAa,GAAGP,OAAO,CAACQ,MAAM,IAAIH,0BAA0B;EAElE,KACE,IAAII,KAAK,GAAG,CAAC,EACbA,KAAK,IAAIF,aAAa,GAAGD,SAAS,CAACE,MAAM,GAAGH,0BAA0B,GAAG,CAAC,CAAC,EAC3EI,KAAK,EAAE,EACP;IACA,IAAIC,QAAQ,GAAGJ,SAAS,CAACG,KAAK,CAAC;IAC/B,IAAIC,QAAQ,GAAG,IAAI,EAAE;MACnBA,QAAQ,EAAE;IACZ;IACAT,YAAY,GAAGC,MAAM,CAACS,MAAM,CAAC,CAACV,YAAY,EAAEC,MAAM,CAACC,IAAI,CAACO,QAAQ,CAACE,QAAQ,CAAC,EAAE,CAAC,EAAE,KAAK,CAAC,CAAC,CAAC;EACzF;EAEA,IAAIL,aAAa,EAAE;IACjBN,YAAY,GAAGC,MAAM,CAACS,MAAM,CAAC,CAACV,YAAY,EAAEC,MAAM,CAACC,IAAI,CAACL,UAAU,CAACe,SAAS,EAAE,KAAK,CAAC,CAAC,CAAC;EACxF;EACA,OAAOZ,YAAY;AACrB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}