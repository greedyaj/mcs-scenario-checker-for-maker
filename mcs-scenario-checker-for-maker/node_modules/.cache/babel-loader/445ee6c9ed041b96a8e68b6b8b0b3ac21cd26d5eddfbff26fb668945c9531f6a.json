{"ast":null,"code":"// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nexport class IndexUtilizationInfo {\n  constructor(UtilizedSingleIndexes, PotentialSingleIndexes, UtilizedCompositeIndexes, PotentialCompositeIndexes) {\n    this.UtilizedSingleIndexes = UtilizedSingleIndexes;\n    this.PotentialSingleIndexes = PotentialSingleIndexes;\n    this.UtilizedCompositeIndexes = UtilizedCompositeIndexes;\n    this.PotentialCompositeIndexes = PotentialCompositeIndexes;\n  }\n  static tryCreateFromDelimitedBase64String(delimitedString, out) {\n    if (delimitedString == null) {\n      out.result = IndexUtilizationInfo.Empty;\n      return false;\n    }\n    return IndexUtilizationInfo.tryCreateFromDelimitedString(Buffer.from(delimitedString, \"base64\").toString(), out);\n  }\n  static tryCreateFromDelimitedString(delimitedString, out) {\n    if (delimitedString == null) {\n      out.result = IndexUtilizationInfo.Empty;\n      return false;\n    }\n    try {\n      out.result = JSON.parse(delimitedString) || IndexUtilizationInfo.Empty;\n      return true;\n    } catch (error) {\n      out.result = IndexUtilizationInfo.Empty;\n      return false;\n    }\n  }\n  static createFromString(delimitedString, isBase64Encoded) {\n    var _a;\n    const result = {\n      result: undefined\n    };\n    if (isBase64Encoded) {\n      IndexUtilizationInfo.tryCreateFromDelimitedBase64String(delimitedString, result);\n    } else {\n      IndexUtilizationInfo.tryCreateFromDelimitedString(delimitedString, result);\n    }\n    return (_a = result.result) !== null && _a !== void 0 ? _a : IndexUtilizationInfo.Empty;\n  }\n}\nIndexUtilizationInfo.Empty = new IndexUtilizationInfo([], [], [], []);","map":{"version":3,"names":["IndexUtilizationInfo","constructor","UtilizedSingleIndexes","PotentialSingleIndexes","UtilizedCompositeIndexes","PotentialCompositeIndexes","tryCreateFromDelimitedBase64String","delimitedString","out","result","Empty","tryCreateFromDelimitedString","Buffer","from","toString","JSON","parse","error","createFromString","isBase64Encoded","undefined","_a"],"sources":["/Users/ajitpawar/microsoft/bap/POCs/Scenario_checker_for_maker/mcs-scenario-checker-for-maker/node_modules/@azure/cosmos/src/indexMetrics/IndexUtilizationInfo.ts"],"sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\nimport type { SingleIndexUtilizationEntity } from \"./SingleIndexUtilizationEntity\";\nimport type { CompositeIndexUtilizationEntity } from \"./CompositeIndexUtilizationEntity\";\nexport class IndexUtilizationInfo {\n  public static readonly Empty = new IndexUtilizationInfo([], [], [], []);\n\n  constructor(\n    public readonly UtilizedSingleIndexes: SingleIndexUtilizationEntity[],\n    public readonly PotentialSingleIndexes: SingleIndexUtilizationEntity[],\n    public readonly UtilizedCompositeIndexes: CompositeIndexUtilizationEntity[],\n    public readonly PotentialCompositeIndexes: CompositeIndexUtilizationEntity[],\n  ) {}\n\n  public static tryCreateFromDelimitedBase64String(\n    delimitedString: string,\n    out: { result?: IndexUtilizationInfo },\n  ): boolean {\n    if (delimitedString == null) {\n      out.result = IndexUtilizationInfo.Empty;\n      return false;\n    }\n\n    return IndexUtilizationInfo.tryCreateFromDelimitedString(\n      Buffer.from(delimitedString, \"base64\").toString(),\n      out,\n    );\n  }\n\n  public static tryCreateFromDelimitedString(\n    delimitedString: string,\n    out: { result?: IndexUtilizationInfo },\n  ): boolean {\n    if (delimitedString == null) {\n      out.result = IndexUtilizationInfo.Empty;\n      return false;\n    }\n\n    try {\n      out.result = JSON.parse(delimitedString) || IndexUtilizationInfo.Empty;\n      return true;\n    } catch (error) {\n      out.result = IndexUtilizationInfo.Empty;\n      return false;\n    }\n  }\n\n  public static createFromString(\n    delimitedString: string,\n    isBase64Encoded: boolean,\n  ): IndexUtilizationInfo {\n    const result: { result?: IndexUtilizationInfo } = { result: undefined };\n\n    if (isBase64Encoded) {\n      IndexUtilizationInfo.tryCreateFromDelimitedBase64String(delimitedString, result);\n    } else {\n      IndexUtilizationInfo.tryCreateFromDelimitedString(delimitedString, result);\n    }\n\n    return result.result ?? IndexUtilizationInfo.Empty;\n  }\n}\n"],"mappings":"AAAA;AACA;AAIA,OAAM,MAAOA,oBAAoB;EAG/BC,YACkBC,qBAAqD,EACrDC,sBAAsD,EACtDC,wBAA2D,EAC3DC,yBAA4D;IAH5D,KAAAH,qBAAqB,GAArBA,qBAAqB;IACrB,KAAAC,sBAAsB,GAAtBA,sBAAsB;IACtB,KAAAC,wBAAwB,GAAxBA,wBAAwB;IACxB,KAAAC,yBAAyB,GAAzBA,yBAAyB;EACxC;EAEI,OAAOC,kCAAkCA,CAC9CC,eAAuB,EACvBC,GAAsC;IAEtC,IAAID,eAAe,IAAI,IAAI,EAAE;MAC3BC,GAAG,CAACC,MAAM,GAAGT,oBAAoB,CAACU,KAAK;MACvC,OAAO,KAAK;IACd;IAEA,OAAOV,oBAAoB,CAACW,4BAA4B,CACtDC,MAAM,CAACC,IAAI,CAACN,eAAe,EAAE,QAAQ,CAAC,CAACO,QAAQ,EAAE,EACjDN,GAAG,CACJ;EACH;EAEO,OAAOG,4BAA4BA,CACxCJ,eAAuB,EACvBC,GAAsC;IAEtC,IAAID,eAAe,IAAI,IAAI,EAAE;MAC3BC,GAAG,CAACC,MAAM,GAAGT,oBAAoB,CAACU,KAAK;MACvC,OAAO,KAAK;IACd;IAEA,IAAI;MACFF,GAAG,CAACC,MAAM,GAAGM,IAAI,CAACC,KAAK,CAACT,eAAe,CAAC,IAAIP,oBAAoB,CAACU,KAAK;MACtE,OAAO,IAAI;IACb,CAAC,CAAC,OAAOO,KAAK,EAAE;MACdT,GAAG,CAACC,MAAM,GAAGT,oBAAoB,CAACU,KAAK;MACvC,OAAO,KAAK;IACd;EACF;EAEO,OAAOQ,gBAAgBA,CAC5BX,eAAuB,EACvBY,eAAwB;;IAExB,MAAMV,MAAM,GAAsC;MAAEA,MAAM,EAAEW;IAAS,CAAE;IAEvE,IAAID,eAAe,EAAE;MACnBnB,oBAAoB,CAACM,kCAAkC,CAACC,eAAe,EAAEE,MAAM,CAAC;IAClF,CAAC,MAAM;MACLT,oBAAoB,CAACW,4BAA4B,CAACJ,eAAe,EAAEE,MAAM,CAAC;IAC5E;IAEA,OAAO,CAAAY,EAAA,GAAAZ,MAAM,CAACA,MAAM,cAAAY,EAAA,cAAAA,EAAA,GAAIrB,oBAAoB,CAACU,KAAK;EACpD;;AAvDuBV,oBAAA,CAAAU,KAAK,GAAG,IAAIV,oBAAoB,CAAC,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}