{"ast":null,"code":"/**\n * This class implements the resource throttle retry policy for requests.\n * @hidden\n */\nexport class ResourceThrottleRetryPolicy {\n  /**\n   * @param maxTries - Max number of retries to be performed for a request.\n   * @param fixedRetryIntervalInMs - Fixed retry interval in milliseconds to wait between each\n   * retry ignoring the retryAfter returned as part of the response.\n   * @param timeoutInSeconds - Max wait time in seconds to wait for a request while the\n   * retries are happening.\n   */\n  constructor(maxTries = 9, fixedRetryIntervalInMs = 0, timeoutInSeconds = 30) {\n    this.maxTries = maxTries;\n    this.fixedRetryIntervalInMs = fixedRetryIntervalInMs;\n    /** Current retry attempt count. */\n    this.currentRetryAttemptCount = 0;\n    /** Cummulative wait time in milliseconds for a request while the retries are happening. */\n    this.cummulativeWaitTimeinMs = 0;\n    /** Retry interval in milliseconds to wait before the next request will be sent. */\n    this.retryAfterInMs = 0;\n    this.timeoutInMs = timeoutInSeconds * 1000;\n    this.currentRetryAttemptCount = 0;\n    this.cummulativeWaitTimeinMs = 0;\n  }\n  /**\n   * Determines whether the request should be retried or not.\n   * @param err - Error returned by the request.\n   */\n  async shouldRetry(err, diagnosticNode) {\n    // TODO: any custom error object\n    if (err) {\n      if (this.currentRetryAttemptCount < this.maxTries) {\n        this.currentRetryAttemptCount++;\n        this.retryAfterInMs = 0;\n        if (this.fixedRetryIntervalInMs) {\n          this.retryAfterInMs = this.fixedRetryIntervalInMs;\n        } else if (err.retryAfterInMs) {\n          this.retryAfterInMs = err.retryAfterInMs;\n        }\n        if (this.cummulativeWaitTimeinMs < this.timeoutInMs) {\n          this.cummulativeWaitTimeinMs += this.retryAfterInMs;\n          diagnosticNode.addData({\n            successfulRetryPolicy: \"resourceThrottle\"\n          });\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n}","map":{"version":3,"names":["ResourceThrottleRetryPolicy","constructor","maxTries","fixedRetryIntervalInMs","timeoutInSeconds","currentRetryAttemptCount","cummulativeWaitTimeinMs","retryAfterInMs","timeoutInMs","shouldRetry","err","diagnosticNode","addData","successfulRetryPolicy"],"sources":["/Users/ajitpawar/microsoft/bap/POCs/Scenario_checker_for_maker/mcs-scenario-checker-for-maker/node_modules/@azure/cosmos/src/retry/resourceThrottleRetryPolicy.ts"],"sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport type { DiagnosticNodeInternal } from \"../diagnostics/DiagnosticNodeInternal\";\nimport type { ErrorResponse } from \"../request\";\n\n/**\n * This class implements the resource throttle retry policy for requests.\n * @hidden\n */\nexport class ResourceThrottleRetryPolicy {\n  /** Current retry attempt count. */\n  public currentRetryAttemptCount: number = 0;\n  /** Cummulative wait time in milliseconds for a request while the retries are happening. */\n  public cummulativeWaitTimeinMs: number = 0;\n  /** Retry interval in milliseconds to wait before the next request will be sent. */\n  public retryAfterInMs: number = 0;\n\n  /** Max wait time in milliseconds to wait for a request while the retries are happening. */\n  private timeoutInMs: number;\n  /**\n   * @param maxTries - Max number of retries to be performed for a request.\n   * @param fixedRetryIntervalInMs - Fixed retry interval in milliseconds to wait between each\n   * retry ignoring the retryAfter returned as part of the response.\n   * @param timeoutInSeconds - Max wait time in seconds to wait for a request while the\n   * retries are happening.\n   */\n  constructor(\n    private maxTries: number = 9,\n    private fixedRetryIntervalInMs: number = 0,\n    timeoutInSeconds: number = 30,\n  ) {\n    this.timeoutInMs = timeoutInSeconds * 1000;\n    this.currentRetryAttemptCount = 0;\n    this.cummulativeWaitTimeinMs = 0;\n  }\n  /**\n   * Determines whether the request should be retried or not.\n   * @param err - Error returned by the request.\n   */\n  public async shouldRetry(\n    err: ErrorResponse,\n    diagnosticNode: DiagnosticNodeInternal,\n  ): Promise<boolean> {\n    // TODO: any custom error object\n    if (err) {\n      if (this.currentRetryAttemptCount < this.maxTries) {\n        this.currentRetryAttemptCount++;\n        this.retryAfterInMs = 0;\n\n        if (this.fixedRetryIntervalInMs) {\n          this.retryAfterInMs = this.fixedRetryIntervalInMs;\n        } else if (err.retryAfterInMs) {\n          this.retryAfterInMs = err.retryAfterInMs;\n        }\n\n        if (this.cummulativeWaitTimeinMs < this.timeoutInMs) {\n          this.cummulativeWaitTimeinMs += this.retryAfterInMs;\n          diagnosticNode.addData({ successfulRetryPolicy: \"resourceThrottle\" });\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n}\n"],"mappings":"AAKA;;;;AAIA,OAAM,MAAOA,2BAA2B;EAUtC;;;;;;;EAOAC,YACUC,QAAA,GAAmB,CAAC,EACpBC,sBAAA,GAAiC,CAAC,EAC1CC,gBAAA,GAA2B,EAAE;IAFrB,KAAAF,QAAQ,GAARA,QAAQ;IACR,KAAAC,sBAAsB,GAAtBA,sBAAsB;IAlBhC;IACO,KAAAE,wBAAwB,GAAW,CAAC;IAC3C;IACO,KAAAC,uBAAuB,GAAW,CAAC;IAC1C;IACO,KAAAC,cAAc,GAAW,CAAC;IAgB/B,IAAI,CAACC,WAAW,GAAGJ,gBAAgB,GAAG,IAAI;IAC1C,IAAI,CAACC,wBAAwB,GAAG,CAAC;IACjC,IAAI,CAACC,uBAAuB,GAAG,CAAC;EAClC;EACA;;;;EAIO,MAAMG,WAAWA,CACtBC,GAAkB,EAClBC,cAAsC;IAEtC;IACA,IAAID,GAAG,EAAE;MACP,IAAI,IAAI,CAACL,wBAAwB,GAAG,IAAI,CAACH,QAAQ,EAAE;QACjD,IAAI,CAACG,wBAAwB,EAAE;QAC/B,IAAI,CAACE,cAAc,GAAG,CAAC;QAEvB,IAAI,IAAI,CAACJ,sBAAsB,EAAE;UAC/B,IAAI,CAACI,cAAc,GAAG,IAAI,CAACJ,sBAAsB;QACnD,CAAC,MAAM,IAAIO,GAAG,CAACH,cAAc,EAAE;UAC7B,IAAI,CAACA,cAAc,GAAGG,GAAG,CAACH,cAAc;QAC1C;QAEA,IAAI,IAAI,CAACD,uBAAuB,GAAG,IAAI,CAACE,WAAW,EAAE;UACnD,IAAI,CAACF,uBAAuB,IAAI,IAAI,CAACC,cAAc;UACnDI,cAAc,CAACC,OAAO,CAAC;YAAEC,qBAAqB,EAAE;UAAkB,CAAE,CAAC;UACrE,OAAO,IAAI;QACb;MACF;IACF;IACA,OAAO,KAAK;EACd","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}