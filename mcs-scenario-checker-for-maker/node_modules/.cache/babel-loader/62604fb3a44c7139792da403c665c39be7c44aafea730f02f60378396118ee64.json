{"ast":null,"code":"import { Constants, getIdFromLink, getPathFromLink, ResourceType, StatusCodes, SubStatusCodes } from \"../common\";\nimport { DefaultQueryExecutionContext } from \"./defaultQueryExecutionContext\";\nimport { FetchResult, FetchResultType } from \"./FetchResult\";\nimport { getInitialHeader, mergeHeaders } from \"./headerUtils\";\n/** @hidden */\nexport class DocumentProducer {\n  /**\n   * Provides the Target Partition Range Query Execution Context.\n   * @param clientContext  - The service endpoint to use to create the client.\n   * @param collectionLink - Represents collection link\n   * @param query          - A SQL query.\n   * @param targetPartitionKeyRange - Query Target Partition key Range\n   * @hidden\n   */\n  constructor(clientContext, collectionLink, query, targetPartitionKeyRange, options, correlatedActivityId) {\n    this.clientContext = clientContext;\n    this.generation = 0;\n    this.fetchFunction = async (diagnosticNode, options, correlatedActivityId) => {\n      const path = getPathFromLink(this.collectionLink, ResourceType.item);\n      diagnosticNode.addData({\n        partitionKeyRangeId: this.targetPartitionKeyRange.id\n      });\n      const id = getIdFromLink(this.collectionLink);\n      return this.clientContext.queryFeed({\n        path,\n        resourceType: ResourceType.item,\n        resourceId: id,\n        resultFn: result => result.Documents,\n        query: this.query,\n        options,\n        diagnosticNode,\n        partitionKeyRangeId: this.targetPartitionKeyRange[\"id\"],\n        correlatedActivityId: correlatedActivityId\n      });\n    };\n    // TODO: any options\n    this.collectionLink = collectionLink;\n    this.query = query;\n    this.targetPartitionKeyRange = targetPartitionKeyRange;\n    this.fetchResults = [];\n    this.allFetched = false;\n    this.err = undefined;\n    this.previousContinuationToken = undefined;\n    this.continuationToken = undefined;\n    this.respHeaders = getInitialHeader();\n    this.internalExecutionContext = new DefaultQueryExecutionContext(options, this.fetchFunction, correlatedActivityId);\n  }\n  /**\n   * Synchronously gives the contiguous buffered results (stops at the first non result) if any\n   * @returns buffered current items if any\n   * @hidden\n   */\n  peekBufferedItems() {\n    const bufferedResults = [];\n    for (let i = 0, done = false; i < this.fetchResults.length && !done; i++) {\n      const fetchResult = this.fetchResults[i];\n      switch (fetchResult.fetchResultType) {\n        case FetchResultType.Done:\n          done = true;\n          break;\n        case FetchResultType.Exception:\n          done = true;\n          break;\n        case FetchResultType.Result:\n          bufferedResults.push(fetchResult.feedResponse);\n          break;\n      }\n    }\n    return bufferedResults;\n  }\n  hasMoreResults() {\n    return this.internalExecutionContext.hasMoreResults() || this.fetchResults.length !== 0;\n  }\n  gotSplit() {\n    const fetchResult = this.fetchResults[0];\n    if (fetchResult.fetchResultType === FetchResultType.Exception) {\n      if (DocumentProducer._needPartitionKeyRangeCacheRefresh(fetchResult.error)) {\n        return true;\n      }\n    }\n    return false;\n  }\n  _getAndResetActiveResponseHeaders() {\n    const ret = this.respHeaders;\n    this.respHeaders = getInitialHeader();\n    return ret;\n  }\n  _updateStates(err, allFetched) {\n    // TODO: any Error\n    if (err) {\n      this.err = err;\n      return;\n    }\n    if (allFetched) {\n      this.allFetched = true;\n    }\n    if (this.internalExecutionContext.continuationToken === this.continuationToken) {\n      // nothing changed\n      return;\n    }\n    this.previousContinuationToken = this.continuationToken;\n    this.continuationToken = this.internalExecutionContext.continuationToken;\n  }\n  static _needPartitionKeyRangeCacheRefresh(error) {\n    // TODO: error\n    return error.code === StatusCodes.Gone && \"substatus\" in error && error[\"substatus\"] === SubStatusCodes.PartitionKeyRangeGone;\n  }\n  /**\n   * Fetches and bufferes the next page of results and executes the given callback\n   */\n  async bufferMore(diagnosticNode) {\n    if (this.err) {\n      throw this.err;\n    }\n    try {\n      const {\n        result: resources,\n        headers: headerResponse\n      } = await this.internalExecutionContext.fetchMore(diagnosticNode);\n      ++this.generation;\n      this._updateStates(undefined, resources === undefined);\n      if (resources !== undefined) {\n        // some more results\n        resources.forEach(element => {\n          // TODO: resources any\n          this.fetchResults.push(new FetchResult(element, undefined));\n        });\n      }\n      // need to modify the header response so that the query metrics are per partition\n      if (headerResponse != null && Constants.HttpHeaders.QueryMetrics in headerResponse) {\n        // \"0\" is the default partition before one is actually assigned.\n        const queryMetrics = headerResponse[Constants.HttpHeaders.QueryMetrics][\"0\"];\n        // Wraping query metrics in a object where the keys are the partition key range.\n        headerResponse[Constants.HttpHeaders.QueryMetrics] = {};\n        headerResponse[Constants.HttpHeaders.QueryMetrics][this.targetPartitionKeyRange.id] = queryMetrics;\n      }\n      return {\n        result: resources,\n        headers: headerResponse\n      };\n    } catch (err) {\n      // TODO: any error\n      if (DocumentProducer._needPartitionKeyRangeCacheRefresh(err)) {\n        // Split just happend\n        // Buffer the error so the execution context can still get the feedResponses in the itemBuffer\n        const bufferedError = new FetchResult(undefined, err);\n        this.fetchResults.push(bufferedError);\n        // Putting a dummy result so that the rest of code flows\n        return {\n          result: [bufferedError],\n          headers: err.headers\n        };\n      } else {\n        this._updateStates(err, err.resources === undefined);\n        throw err;\n      }\n    }\n  }\n  /**\n   * Synchronously gives the bufferend current item if any\n   * @returns buffered current item if any\n   * @hidden\n   */\n  getTargetParitionKeyRange() {\n    return this.targetPartitionKeyRange;\n  }\n  /**\n   * Fetches the next element in the DocumentProducer.\n   */\n  async nextItem(diagnosticNode) {\n    if (this.err) {\n      this._updateStates(this.err, undefined);\n      throw this.err;\n    }\n    try {\n      const {\n        result,\n        headers\n      } = await this.current(diagnosticNode);\n      const fetchResult = this.fetchResults.shift();\n      this._updateStates(undefined, result === undefined);\n      if (fetchResult.feedResponse !== result) {\n        throw new Error(`Expected ${fetchResult.feedResponse} to equal ${result}`);\n      }\n      switch (fetchResult.fetchResultType) {\n        case FetchResultType.Done:\n          return {\n            result: undefined,\n            headers\n          };\n        case FetchResultType.Exception:\n          fetchResult.error.headers = headers;\n          throw fetchResult.error;\n        case FetchResultType.Result:\n          return {\n            result: fetchResult.feedResponse,\n            headers\n          };\n      }\n    } catch (err) {\n      this._updateStates(err, err.item === undefined);\n      throw err;\n    }\n  }\n  /**\n   * Retrieve the current element on the DocumentProducer.\n   */\n  async current(diagnosticNode) {\n    // If something is buffered just give that\n    if (this.fetchResults.length > 0) {\n      const fetchResult = this.fetchResults[0];\n      // Need to unwrap fetch results\n      switch (fetchResult.fetchResultType) {\n        case FetchResultType.Done:\n          return {\n            result: undefined,\n            headers: this._getAndResetActiveResponseHeaders()\n          };\n        case FetchResultType.Exception:\n          fetchResult.error.headers = this._getAndResetActiveResponseHeaders();\n          throw fetchResult.error;\n        case FetchResultType.Result:\n          return {\n            result: fetchResult.feedResponse,\n            headers: this._getAndResetActiveResponseHeaders()\n          };\n      }\n    }\n    // If there isn't anymore items left to fetch then let the user know.\n    if (this.allFetched) {\n      return {\n        result: undefined,\n        headers: this._getAndResetActiveResponseHeaders()\n      };\n    }\n    // If there are no more bufferd items and there are still items to be fetched then buffer more\n    const {\n      result,\n      headers\n    } = await this.bufferMore(diagnosticNode);\n    mergeHeaders(this.respHeaders, headers);\n    if (result === undefined) {\n      return {\n        result: undefined,\n        headers: this.respHeaders\n      };\n    }\n    return this.current(diagnosticNode);\n  }\n}","map":{"version":3,"names":["Constants","getIdFromLink","getPathFromLink","ResourceType","StatusCodes","SubStatusCodes","DefaultQueryExecutionContext","FetchResult","FetchResultType","getInitialHeader","mergeHeaders","DocumentProducer","constructor","clientContext","collectionLink","query","targetPartitionKeyRange","options","correlatedActivityId","generation","fetchFunction","diagnosticNode","path","item","addData","partitionKeyRangeId","id","queryFeed","resourceType","resourceId","resultFn","result","Documents","fetchResults","allFetched","err","undefined","previousContinuationToken","continuationToken","respHeaders","internalExecutionContext","peekBufferedItems","bufferedResults","i","done","length","fetchResult","fetchResultType","Done","Exception","Result","push","feedResponse","hasMoreResults","gotSplit","_needPartitionKeyRangeCacheRefresh","error","_getAndResetActiveResponseHeaders","ret","_updateStates","code","Gone","PartitionKeyRangeGone","bufferMore","resources","headers","headerResponse","fetchMore","forEach","element","HttpHeaders","QueryMetrics","queryMetrics","bufferedError","getTargetParitionKeyRange","nextItem","current","shift","Error"],"sources":["/Users/ajitpawar/microsoft/bap/POCs/Scenario_checker_for_maker/mcs-scenario-checker-for-maker/node_modules/@azure/cosmos/src/queryExecutionContext/documentProducer.ts"],"sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport type { PartitionKeyRange, Resource } from \"../client\";\nimport type { ClientContext } from \"../ClientContext\";\nimport {\n  Constants,\n  getIdFromLink,\n  getPathFromLink,\n  ResourceType,\n  StatusCodes,\n  SubStatusCodes,\n} from \"../common\";\nimport type { DiagnosticNodeInternal } from \"../diagnostics/DiagnosticNodeInternal\";\nimport type { FeedOptions } from \"../request\";\nimport type { Response } from \"../request\";\nimport type { FetchFunctionCallback } from \"./defaultQueryExecutionContext\";\nimport { DefaultQueryExecutionContext } from \"./defaultQueryExecutionContext\";\nimport { FetchResult, FetchResultType } from \"./FetchResult\";\nimport type { CosmosHeaders } from \"./headerUtils\";\nimport { getInitialHeader, mergeHeaders } from \"./headerUtils\";\nimport type { SqlQuerySpec } from \"./index\";\n\n/** @hidden */\nexport class DocumentProducer {\n  private collectionLink: string;\n  private query: string | SqlQuerySpec;\n  public targetPartitionKeyRange: PartitionKeyRange;\n  public fetchResults: FetchResult[];\n  public allFetched: boolean;\n  private err: Error;\n  public previousContinuationToken: string;\n  public continuationToken: string;\n  public generation: number = 0;\n  private respHeaders: CosmosHeaders;\n  private internalExecutionContext: DefaultQueryExecutionContext;\n\n  /**\n   * Provides the Target Partition Range Query Execution Context.\n   * @param clientContext  - The service endpoint to use to create the client.\n   * @param collectionLink - Represents collection link\n   * @param query          - A SQL query.\n   * @param targetPartitionKeyRange - Query Target Partition key Range\n   * @hidden\n   */\n  constructor(\n    private clientContext: ClientContext,\n    collectionLink: string,\n    query: SqlQuerySpec,\n    targetPartitionKeyRange: PartitionKeyRange,\n    options: FeedOptions,\n    correlatedActivityId: string,\n  ) {\n    // TODO: any options\n    this.collectionLink = collectionLink;\n    this.query = query;\n    this.targetPartitionKeyRange = targetPartitionKeyRange;\n    this.fetchResults = [];\n\n    this.allFetched = false;\n    this.err = undefined;\n\n    this.previousContinuationToken = undefined;\n    this.continuationToken = undefined;\n    this.respHeaders = getInitialHeader();\n\n    this.internalExecutionContext = new DefaultQueryExecutionContext(\n      options,\n      this.fetchFunction,\n      correlatedActivityId,\n    );\n  }\n  /**\n   * Synchronously gives the contiguous buffered results (stops at the first non result) if any\n   * @returns buffered current items if any\n   * @hidden\n   */\n  public peekBufferedItems(): any[] {\n    const bufferedResults = [];\n    for (let i = 0, done = false; i < this.fetchResults.length && !done; i++) {\n      const fetchResult = this.fetchResults[i];\n      switch (fetchResult.fetchResultType) {\n        case FetchResultType.Done:\n          done = true;\n          break;\n        case FetchResultType.Exception:\n          done = true;\n          break;\n        case FetchResultType.Result:\n          bufferedResults.push(fetchResult.feedResponse);\n          break;\n      }\n    }\n    return bufferedResults;\n  }\n\n  public fetchFunction: FetchFunctionCallback = async (\n    diagnosticNode: DiagnosticNodeInternal,\n    options: FeedOptions,\n    correlatedActivityId: string,\n  ): Promise<Response<Resource>> => {\n    const path = getPathFromLink(this.collectionLink, ResourceType.item);\n    diagnosticNode.addData({ partitionKeyRangeId: this.targetPartitionKeyRange.id });\n    const id = getIdFromLink(this.collectionLink);\n\n    return this.clientContext.queryFeed({\n      path,\n      resourceType: ResourceType.item,\n      resourceId: id,\n      resultFn: (result: any) => result.Documents,\n      query: this.query,\n      options,\n      diagnosticNode,\n      partitionKeyRangeId: this.targetPartitionKeyRange[\"id\"],\n      correlatedActivityId: correlatedActivityId,\n    });\n  };\n\n  public hasMoreResults(): boolean {\n    return this.internalExecutionContext.hasMoreResults() || this.fetchResults.length !== 0;\n  }\n\n  public gotSplit(): boolean {\n    const fetchResult = this.fetchResults[0];\n    if (fetchResult.fetchResultType === FetchResultType.Exception) {\n      if (DocumentProducer._needPartitionKeyRangeCacheRefresh(fetchResult.error)) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  private _getAndResetActiveResponseHeaders(): CosmosHeaders {\n    const ret = this.respHeaders;\n    this.respHeaders = getInitialHeader();\n    return ret;\n  }\n\n  private _updateStates(err: any, allFetched: boolean): void {\n    // TODO: any Error\n    if (err) {\n      this.err = err;\n      return;\n    }\n    if (allFetched) {\n      this.allFetched = true;\n    }\n    if (this.internalExecutionContext.continuationToken === this.continuationToken) {\n      // nothing changed\n      return;\n    }\n    this.previousContinuationToken = this.continuationToken;\n    this.continuationToken = this.internalExecutionContext.continuationToken;\n  }\n\n  private static _needPartitionKeyRangeCacheRefresh(error: any): boolean {\n    // TODO: error\n    return (\n      error.code === StatusCodes.Gone &&\n      \"substatus\" in error &&\n      error[\"substatus\"] === SubStatusCodes.PartitionKeyRangeGone\n    );\n  }\n\n  /**\n   * Fetches and bufferes the next page of results and executes the given callback\n   */\n  public async bufferMore(diagnosticNode: DiagnosticNodeInternal): Promise<Response<any>> {\n    if (this.err) {\n      throw this.err;\n    }\n\n    try {\n      const { result: resources, headers: headerResponse } =\n        await this.internalExecutionContext.fetchMore(diagnosticNode);\n      ++this.generation;\n      this._updateStates(undefined, resources === undefined);\n      if (resources !== undefined) {\n        // some more results\n        resources.forEach((element: any) => {\n          // TODO: resources any\n          this.fetchResults.push(new FetchResult(element, undefined));\n        });\n      }\n\n      // need to modify the header response so that the query metrics are per partition\n      if (headerResponse != null && Constants.HttpHeaders.QueryMetrics in headerResponse) {\n        // \"0\" is the default partition before one is actually assigned.\n        const queryMetrics = headerResponse[Constants.HttpHeaders.QueryMetrics][\"0\"];\n\n        // Wraping query metrics in a object where the keys are the partition key range.\n        headerResponse[Constants.HttpHeaders.QueryMetrics] = {};\n        headerResponse[Constants.HttpHeaders.QueryMetrics][this.targetPartitionKeyRange.id] =\n          queryMetrics;\n      }\n\n      return { result: resources, headers: headerResponse };\n    } catch (err: any) {\n      // TODO: any error\n      if (DocumentProducer._needPartitionKeyRangeCacheRefresh(err)) {\n        // Split just happend\n        // Buffer the error so the execution context can still get the feedResponses in the itemBuffer\n        const bufferedError = new FetchResult(undefined, err);\n        this.fetchResults.push(bufferedError);\n        // Putting a dummy result so that the rest of code flows\n        return {\n          result: [bufferedError],\n          headers: err.headers,\n        };\n      } else {\n        this._updateStates(err, err.resources === undefined);\n        throw err;\n      }\n    }\n  }\n\n  /**\n   * Synchronously gives the bufferend current item if any\n   * @returns buffered current item if any\n   * @hidden\n   */\n  public getTargetParitionKeyRange(): PartitionKeyRange {\n    return this.targetPartitionKeyRange;\n  }\n\n  /**\n   * Fetches the next element in the DocumentProducer.\n   */\n  public async nextItem(diagnosticNode: DiagnosticNodeInternal): Promise<Response<any>> {\n    if (this.err) {\n      this._updateStates(this.err, undefined);\n      throw this.err;\n    }\n\n    try {\n      const { result, headers } = await this.current(diagnosticNode);\n\n      const fetchResult = this.fetchResults.shift();\n      this._updateStates(undefined, result === undefined);\n      if (fetchResult.feedResponse !== result) {\n        throw new Error(`Expected ${fetchResult.feedResponse} to equal ${result}`);\n      }\n      switch (fetchResult.fetchResultType) {\n        case FetchResultType.Done:\n          return { result: undefined, headers };\n        case FetchResultType.Exception:\n          fetchResult.error.headers = headers;\n          throw fetchResult.error;\n        case FetchResultType.Result:\n          return { result: fetchResult.feedResponse, headers };\n      }\n    } catch (err: any) {\n      this._updateStates(err, err.item === undefined);\n      throw err;\n    }\n  }\n\n  /**\n   * Retrieve the current element on the DocumentProducer.\n   */\n  public async current(diagnosticNode: DiagnosticNodeInternal): Promise<Response<any>> {\n    // If something is buffered just give that\n    if (this.fetchResults.length > 0) {\n      const fetchResult = this.fetchResults[0];\n      // Need to unwrap fetch results\n      switch (fetchResult.fetchResultType) {\n        case FetchResultType.Done:\n          return {\n            result: undefined,\n            headers: this._getAndResetActiveResponseHeaders(),\n          };\n        case FetchResultType.Exception:\n          fetchResult.error.headers = this._getAndResetActiveResponseHeaders();\n          throw fetchResult.error;\n        case FetchResultType.Result:\n          return {\n            result: fetchResult.feedResponse,\n            headers: this._getAndResetActiveResponseHeaders(),\n          };\n      }\n    }\n\n    // If there isn't anymore items left to fetch then let the user know.\n    if (this.allFetched) {\n      return {\n        result: undefined,\n        headers: this._getAndResetActiveResponseHeaders(),\n      };\n    }\n\n    // If there are no more bufferd items and there are still items to be fetched then buffer more\n    const { result, headers } = await this.bufferMore(diagnosticNode);\n    mergeHeaders(this.respHeaders, headers);\n    if (result === undefined) {\n      return { result: undefined, headers: this.respHeaders };\n    }\n    return this.current(diagnosticNode);\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}