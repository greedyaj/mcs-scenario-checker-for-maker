{"ast":null,"code":"import { ErrorResponse } from \"../request/ErrorResponse\";\nimport { OffsetLimitEndpointComponent } from \"./EndpointComponent/OffsetLimitEndpointComponent\";\nimport { OrderByEndpointComponent } from \"./EndpointComponent/OrderByEndpointComponent\";\nimport { OrderedDistinctEndpointComponent } from \"./EndpointComponent/OrderedDistinctEndpointComponent\";\nimport { UnorderedDistinctEndpointComponent } from \"./EndpointComponent/UnorderedDistinctEndpointComponent\";\nimport { GroupByEndpointComponent } from \"./EndpointComponent/GroupByEndpointComponent\";\nimport { getInitialHeader, mergeHeaders } from \"./headerUtils\";\nimport { OrderByQueryExecutionContext } from \"./orderByQueryExecutionContext\";\nimport { ParallelQueryExecutionContext } from \"./parallelQueryExecutionContext\";\nimport { GroupByValueEndpointComponent } from \"./EndpointComponent/GroupByValueEndpointComponent\";\nimport { NonStreamingOrderByDistinctEndpointComponent } from \"./EndpointComponent/NonStreamingOrderByDistinctEndpointComponent\";\nimport { NonStreamingOrderByEndpointComponent } from \"./EndpointComponent/NonStreamingOrderByEndpointComponent\";\n/** @hidden */\nexport class PipelinedQueryExecutionContext {\n  constructor(clientContext, collectionLink, query, options, partitionedQueryExecutionInfo, correlatedActivityId, emitRawOrderByPayload = false) {\n    this.clientContext = clientContext;\n    this.collectionLink = collectionLink;\n    this.query = query;\n    this.options = options;\n    this.partitionedQueryExecutionInfo = partitionedQueryExecutionInfo;\n    this.emitRawOrderByPayload = emitRawOrderByPayload;\n    this.vectorSearchBufferSize = 0;\n    this.nonStreamingOrderBy = false;\n    this.endpoint = null;\n    this.pageSize = options[\"maxItemCount\"];\n    if (this.pageSize === undefined) {\n      this.pageSize = PipelinedQueryExecutionContext.DEFAULT_PAGE_SIZE;\n    }\n    // Pick between Nonstreaming and streaming endpoints\n    this.nonStreamingOrderBy = partitionedQueryExecutionInfo.queryInfo.hasNonStreamingOrderBy;\n    // Pick between parallel vs order by execution context\n    const sortOrders = partitionedQueryExecutionInfo.queryInfo.orderBy;\n    // TODO: Currently we don't get any field from backend to determine streaming queries\n    if (this.nonStreamingOrderBy) {\n      if (!options.allowUnboundedNonStreamingQueries) {\n        this.checkQueryConstraints(partitionedQueryExecutionInfo.queryInfo);\n      }\n      this.vectorSearchBufferSize = this.calculateVectorSearchBufferSize(partitionedQueryExecutionInfo.queryInfo, options);\n      const maxBufferSize = options[\"vectorSearchBufferSize\"] ? options[\"vectorSearchBufferSize\"] : PipelinedQueryExecutionContext.DEFAULT_MAX_VECTOR_SEARCH_BUFFER_SIZE;\n      if (this.vectorSearchBufferSize > maxBufferSize) {\n        throw new ErrorResponse(`Executing a vector search query with TOP or OFFSET + LIMIT value ${this.vectorSearchBufferSize} larger than the vectorSearchBufferSize ${maxBufferSize} ` + `is not allowed`);\n      }\n      const distinctType = partitionedQueryExecutionInfo.queryInfo.distinctType;\n      const context = new ParallelQueryExecutionContext(this.clientContext, this.collectionLink, this.query, this.options, this.partitionedQueryExecutionInfo, correlatedActivityId);\n      if (distinctType === \"None\") {\n        this.endpoint = new NonStreamingOrderByEndpointComponent(context, sortOrders, this.vectorSearchBufferSize, partitionedQueryExecutionInfo.queryInfo.offset, this.emitRawOrderByPayload);\n      } else {\n        this.endpoint = new NonStreamingOrderByDistinctEndpointComponent(context, partitionedQueryExecutionInfo.queryInfo, this.vectorSearchBufferSize, this.emitRawOrderByPayload);\n      }\n    } else {\n      if (Array.isArray(sortOrders) && sortOrders.length > 0) {\n        // Need to wrap orderby execution context in endpoint component, since the data is nested as a \\\n        //      \"payload\" property.\n        this.endpoint = new OrderByEndpointComponent(new OrderByQueryExecutionContext(this.clientContext, this.collectionLink, this.query, this.options, this.partitionedQueryExecutionInfo, correlatedActivityId), this.emitRawOrderByPayload);\n      } else {\n        this.endpoint = new ParallelQueryExecutionContext(this.clientContext, this.collectionLink, this.query, this.options, this.partitionedQueryExecutionInfo, correlatedActivityId);\n      }\n      if (Object.keys(partitionedQueryExecutionInfo.queryInfo.groupByAliasToAggregateType).length > 0 || partitionedQueryExecutionInfo.queryInfo.aggregates.length > 0 || partitionedQueryExecutionInfo.queryInfo.groupByExpressions.length > 0) {\n        if (partitionedQueryExecutionInfo.queryInfo.hasSelectValue) {\n          this.endpoint = new GroupByValueEndpointComponent(this.endpoint, partitionedQueryExecutionInfo.queryInfo);\n        } else {\n          this.endpoint = new GroupByEndpointComponent(this.endpoint, partitionedQueryExecutionInfo.queryInfo);\n        }\n      }\n      // If top then add that to the pipeline. TOP N is effectively OFFSET 0 LIMIT N\n      const top = partitionedQueryExecutionInfo.queryInfo.top;\n      if (typeof top === \"number\") {\n        this.endpoint = new OffsetLimitEndpointComponent(this.endpoint, 0, top);\n      }\n      // If offset+limit then add that to the pipeline\n      const limit = partitionedQueryExecutionInfo.queryInfo.limit;\n      const offset = partitionedQueryExecutionInfo.queryInfo.offset;\n      if (typeof limit === \"number\" && typeof offset === \"number\") {\n        this.endpoint = new OffsetLimitEndpointComponent(this.endpoint, offset, limit);\n      }\n      // If distinct then add that to the pipeline\n      const distinctType = partitionedQueryExecutionInfo.queryInfo.distinctType;\n      if (distinctType === \"Ordered\") {\n        this.endpoint = new OrderedDistinctEndpointComponent(this.endpoint);\n      }\n      if (distinctType === \"Unordered\") {\n        this.endpoint = new UnorderedDistinctEndpointComponent(this.endpoint);\n      }\n    }\n  }\n  async nextItem(diagnosticNode) {\n    return this.endpoint.nextItem(diagnosticNode);\n  }\n  // Removed callback here beacuse it wouldn't have ever worked...\n  hasMoreResults() {\n    return this.endpoint.hasMoreResults();\n  }\n  async fetchMore(diagnosticNode) {\n    // if the wrapped endpoint has different implementation for fetchMore use that\n    // otherwise use the default implementation\n    if (typeof this.endpoint.fetchMore === \"function\") {\n      return this.endpoint.fetchMore(diagnosticNode);\n    } else {\n      this.fetchBuffer = [];\n      this.fetchMoreRespHeaders = getInitialHeader();\n      return this.nonStreamingOrderBy ? this._nonStreamingFetchMoreImplementation(diagnosticNode) : this._fetchMoreImplementation(diagnosticNode);\n    }\n  }\n  async _fetchMoreImplementation(diagnosticNode) {\n    try {\n      const {\n        result: item,\n        headers\n      } = await this.endpoint.nextItem(diagnosticNode);\n      mergeHeaders(this.fetchMoreRespHeaders, headers);\n      if (item === undefined) {\n        // no more results\n        if (this.fetchBuffer.length === 0) {\n          return {\n            result: undefined,\n            headers: this.fetchMoreRespHeaders\n          };\n        } else {\n          // Just give what we have\n          const temp = this.fetchBuffer;\n          this.fetchBuffer = [];\n          return {\n            result: temp,\n            headers: this.fetchMoreRespHeaders\n          };\n        }\n      } else {\n        this.fetchBuffer.push(item);\n        if (this.fetchBuffer.length >= this.pageSize) {\n          // fetched enough results\n          const temp = this.fetchBuffer.slice(0, this.pageSize);\n          this.fetchBuffer = this.fetchBuffer.splice(this.pageSize);\n          return {\n            result: temp,\n            headers: this.fetchMoreRespHeaders\n          };\n        } else {\n          // recursively fetch more\n          // TODO: is recursion a good idea?\n          return this._fetchMoreImplementation(diagnosticNode);\n        }\n      }\n    } catch (err) {\n      mergeHeaders(this.fetchMoreRespHeaders, err.headers);\n      err.headers = this.fetchMoreRespHeaders;\n      if (err) {\n        throw err;\n      }\n    }\n  }\n  async _nonStreamingFetchMoreImplementation(diagnosticNode) {\n    try {\n      const {\n        result: item,\n        headers\n      } = await this.endpoint.nextItem(diagnosticNode);\n      mergeHeaders(this.fetchMoreRespHeaders, headers);\n      if (item === undefined) {\n        // no more results\n        if (this.fetchBuffer.length === 0) {\n          return {\n            result: undefined,\n            headers: this.fetchMoreRespHeaders\n          };\n        } else {\n          // Just give what we have\n          const temp = this.fetchBuffer;\n          this.fetchBuffer = [];\n          return {\n            result: temp,\n            headers: this.fetchMoreRespHeaders\n          };\n        }\n      } else {\n        // append the result\n        if (typeof item !== \"object\") {\n          this.fetchBuffer.push(item);\n        } else if (Object.keys(item).length !== 0) {\n          this.fetchBuffer.push(item);\n        }\n        if (this.fetchBuffer.length >= this.pageSize) {\n          // fetched enough results\n          const temp = this.fetchBuffer.slice(0, this.pageSize);\n          this.fetchBuffer = this.fetchBuffer.splice(this.pageSize);\n          return {\n            result: temp,\n            headers: this.fetchMoreRespHeaders\n          };\n        } else {\n          return this._nonStreamingFetchMoreImplementation(diagnosticNode);\n        }\n      }\n    } catch (err) {\n      mergeHeaders(this.fetchMoreRespHeaders, err.headers);\n      err.headers = this.fetchMoreRespHeaders;\n      if (err) {\n        throw err;\n      }\n    }\n  }\n  calculateVectorSearchBufferSize(queryInfo, options) {\n    if (queryInfo.top === 0 || queryInfo.limit === 0) return 0;\n    return queryInfo.top ? queryInfo.top : queryInfo.limit ? queryInfo.offset + queryInfo.limit : options[\"vectorSearchBufferSize\"] && options[\"vectorSearchBufferSize\"] > 0 ? options[\"vectorSearchBufferSize\"] : PipelinedQueryExecutionContext.DEFAULT_MAX_VECTOR_SEARCH_BUFFER_SIZE;\n  }\n  checkQueryConstraints(queryInfo) {\n    const hasTop = queryInfo.top || queryInfo.top === 0;\n    const hasLimit = queryInfo.limit || queryInfo.limit === 0;\n    if (!hasTop && !hasLimit) {\n      throw new ErrorResponse(\"Executing a non-streaming search query without TOP or LIMIT can consume a large number of RUs \" + \"very fast and have long runtimes. Please ensure you are using one of the above two filters \" + \"with your vector search query.\");\n    }\n    return;\n  }\n}\nPipelinedQueryExecutionContext.DEFAULT_PAGE_SIZE = 10;\nPipelinedQueryExecutionContext.DEFAULT_MAX_VECTOR_SEARCH_BUFFER_SIZE = 50000;","map":{"version":3,"names":["ErrorResponse","OffsetLimitEndpointComponent","OrderByEndpointComponent","OrderedDistinctEndpointComponent","UnorderedDistinctEndpointComponent","GroupByEndpointComponent","getInitialHeader","mergeHeaders","OrderByQueryExecutionContext","ParallelQueryExecutionContext","GroupByValueEndpointComponent","NonStreamingOrderByDistinctEndpointComponent","NonStreamingOrderByEndpointComponent","PipelinedQueryExecutionContext","constructor","clientContext","collectionLink","query","options","partitionedQueryExecutionInfo","correlatedActivityId","emitRawOrderByPayload","vectorSearchBufferSize","nonStreamingOrderBy","endpoint","pageSize","undefined","DEFAULT_PAGE_SIZE","queryInfo","hasNonStreamingOrderBy","sortOrders","orderBy","allowUnboundedNonStreamingQueries","checkQueryConstraints","calculateVectorSearchBufferSize","maxBufferSize","DEFAULT_MAX_VECTOR_SEARCH_BUFFER_SIZE","distinctType","context","offset","Array","isArray","length","Object","keys","groupByAliasToAggregateType","aggregates","groupByExpressions","hasSelectValue","top","limit","nextItem","diagnosticNode","hasMoreResults","fetchMore","fetchBuffer","fetchMoreRespHeaders","_nonStreamingFetchMoreImplementation","_fetchMoreImplementation","result","item","headers","temp","push","slice","splice","err","hasTop","hasLimit"],"sources":["/Users/ajitpawar/microsoft/bap/POCs/Scenario_checker_for_maker/mcs-scenario-checker-for-maker/node_modules/@azure/cosmos/src/queryExecutionContext/pipelinedQueryExecutionContext.ts"],"sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport type { ClientContext } from \"../ClientContext\";\nimport type { Response, FeedOptions } from \"../request\";\nimport type { PartitionedQueryExecutionInfo, QueryInfo } from \"../request/ErrorResponse\";\nimport { ErrorResponse } from \"../request/ErrorResponse\";\nimport type { CosmosHeaders } from \"./CosmosHeaders\";\nimport { OffsetLimitEndpointComponent } from \"./EndpointComponent/OffsetLimitEndpointComponent\";\nimport { OrderByEndpointComponent } from \"./EndpointComponent/OrderByEndpointComponent\";\nimport { OrderedDistinctEndpointComponent } from \"./EndpointComponent/OrderedDistinctEndpointComponent\";\nimport { UnorderedDistinctEndpointComponent } from \"./EndpointComponent/UnorderedDistinctEndpointComponent\";\nimport { GroupByEndpointComponent } from \"./EndpointComponent/GroupByEndpointComponent\";\nimport type { ExecutionContext } from \"./ExecutionContext\";\nimport { getInitialHeader, mergeHeaders } from \"./headerUtils\";\nimport { OrderByQueryExecutionContext } from \"./orderByQueryExecutionContext\";\nimport { ParallelQueryExecutionContext } from \"./parallelQueryExecutionContext\";\nimport { GroupByValueEndpointComponent } from \"./EndpointComponent/GroupByValueEndpointComponent\";\nimport type { SqlQuerySpec } from \"./SqlQuerySpec\";\nimport type { DiagnosticNodeInternal } from \"../diagnostics/DiagnosticNodeInternal\";\nimport { NonStreamingOrderByDistinctEndpointComponent } from \"./EndpointComponent/NonStreamingOrderByDistinctEndpointComponent\";\nimport { NonStreamingOrderByEndpointComponent } from \"./EndpointComponent/NonStreamingOrderByEndpointComponent\";\n\n/** @hidden */\nexport class PipelinedQueryExecutionContext implements ExecutionContext {\n  private fetchBuffer: any[];\n  private fetchMoreRespHeaders: CosmosHeaders;\n  private endpoint: ExecutionContext;\n  private pageSize: number;\n  private vectorSearchBufferSize: number = 0;\n  private static DEFAULT_PAGE_SIZE = 10;\n  private static DEFAULT_MAX_VECTOR_SEARCH_BUFFER_SIZE = 50000;\n  private nonStreamingOrderBy = false;\n\n  constructor(\n    private clientContext: ClientContext,\n    private collectionLink: string,\n    private query: string | SqlQuerySpec,\n    private options: FeedOptions,\n    private partitionedQueryExecutionInfo: PartitionedQueryExecutionInfo,\n    correlatedActivityId: string,\n    private emitRawOrderByPayload: boolean = false,\n  ) {\n    this.endpoint = null;\n    this.pageSize = options[\"maxItemCount\"];\n    if (this.pageSize === undefined) {\n      this.pageSize = PipelinedQueryExecutionContext.DEFAULT_PAGE_SIZE;\n    }\n    // Pick between Nonstreaming and streaming endpoints\n    this.nonStreamingOrderBy = partitionedQueryExecutionInfo.queryInfo.hasNonStreamingOrderBy;\n\n    // Pick between parallel vs order by execution context\n    const sortOrders = partitionedQueryExecutionInfo.queryInfo.orderBy;\n    // TODO: Currently we don't get any field from backend to determine streaming queries\n    if (this.nonStreamingOrderBy) {\n      if (!options.allowUnboundedNonStreamingQueries) {\n        this.checkQueryConstraints(partitionedQueryExecutionInfo.queryInfo);\n      }\n\n      this.vectorSearchBufferSize = this.calculateVectorSearchBufferSize(\n        partitionedQueryExecutionInfo.queryInfo,\n        options,\n      );\n      const maxBufferSize = options[\"vectorSearchBufferSize\"]\n        ? options[\"vectorSearchBufferSize\"]\n        : PipelinedQueryExecutionContext.DEFAULT_MAX_VECTOR_SEARCH_BUFFER_SIZE;\n\n      if (this.vectorSearchBufferSize > maxBufferSize) {\n        throw new ErrorResponse(\n          `Executing a vector search query with TOP or OFFSET + LIMIT value ${this.vectorSearchBufferSize} larger than the vectorSearchBufferSize ${maxBufferSize} ` +\n            `is not allowed`,\n        );\n      }\n\n      const distinctType = partitionedQueryExecutionInfo.queryInfo.distinctType;\n      const context: ExecutionContext = new ParallelQueryExecutionContext(\n        this.clientContext,\n        this.collectionLink,\n        this.query,\n        this.options,\n        this.partitionedQueryExecutionInfo,\n        correlatedActivityId,\n      );\n\n      if (distinctType === \"None\") {\n        this.endpoint = new NonStreamingOrderByEndpointComponent(\n          context,\n          sortOrders,\n          this.vectorSearchBufferSize,\n          partitionedQueryExecutionInfo.queryInfo.offset,\n          this.emitRawOrderByPayload,\n        );\n      } else {\n        this.endpoint = new NonStreamingOrderByDistinctEndpointComponent(\n          context,\n          partitionedQueryExecutionInfo.queryInfo,\n          this.vectorSearchBufferSize,\n          this.emitRawOrderByPayload,\n        );\n      }\n    } else {\n      if (Array.isArray(sortOrders) && sortOrders.length > 0) {\n        // Need to wrap orderby execution context in endpoint component, since the data is nested as a \\\n        //      \"payload\" property.\n        this.endpoint = new OrderByEndpointComponent(\n          new OrderByQueryExecutionContext(\n            this.clientContext,\n            this.collectionLink,\n            this.query,\n            this.options,\n            this.partitionedQueryExecutionInfo,\n            correlatedActivityId,\n          ),\n          this.emitRawOrderByPayload,\n        );\n      } else {\n        this.endpoint = new ParallelQueryExecutionContext(\n          this.clientContext,\n          this.collectionLink,\n          this.query,\n          this.options,\n          this.partitionedQueryExecutionInfo,\n          correlatedActivityId,\n        );\n      }\n      if (\n        Object.keys(partitionedQueryExecutionInfo.queryInfo.groupByAliasToAggregateType).length >\n          0 ||\n        partitionedQueryExecutionInfo.queryInfo.aggregates.length > 0 ||\n        partitionedQueryExecutionInfo.queryInfo.groupByExpressions.length > 0\n      ) {\n        if (partitionedQueryExecutionInfo.queryInfo.hasSelectValue) {\n          this.endpoint = new GroupByValueEndpointComponent(\n            this.endpoint,\n            partitionedQueryExecutionInfo.queryInfo,\n          );\n        } else {\n          this.endpoint = new GroupByEndpointComponent(\n            this.endpoint,\n            partitionedQueryExecutionInfo.queryInfo,\n          );\n        }\n      }\n      // If top then add that to the pipeline. TOP N is effectively OFFSET 0 LIMIT N\n      const top = partitionedQueryExecutionInfo.queryInfo.top;\n      if (typeof top === \"number\") {\n        this.endpoint = new OffsetLimitEndpointComponent(this.endpoint, 0, top);\n      }\n\n      // If offset+limit then add that to the pipeline\n      const limit = partitionedQueryExecutionInfo.queryInfo.limit;\n      const offset = partitionedQueryExecutionInfo.queryInfo.offset;\n      if (typeof limit === \"number\" && typeof offset === \"number\") {\n        this.endpoint = new OffsetLimitEndpointComponent(this.endpoint, offset, limit);\n      }\n\n      // If distinct then add that to the pipeline\n      const distinctType = partitionedQueryExecutionInfo.queryInfo.distinctType;\n      if (distinctType === \"Ordered\") {\n        this.endpoint = new OrderedDistinctEndpointComponent(this.endpoint);\n      }\n      if (distinctType === \"Unordered\") {\n        this.endpoint = new UnorderedDistinctEndpointComponent(this.endpoint);\n      }\n    }\n  }\n\n  public async nextItem(diagnosticNode: DiagnosticNodeInternal): Promise<Response<any>> {\n    return this.endpoint.nextItem(diagnosticNode);\n  }\n\n  // Removed callback here beacuse it wouldn't have ever worked...\n  public hasMoreResults(): boolean {\n    return this.endpoint.hasMoreResults();\n  }\n\n  public async fetchMore(diagnosticNode: DiagnosticNodeInternal): Promise<Response<any>> {\n    // if the wrapped endpoint has different implementation for fetchMore use that\n    // otherwise use the default implementation\n    if (typeof this.endpoint.fetchMore === \"function\") {\n      return this.endpoint.fetchMore(diagnosticNode);\n    } else {\n      this.fetchBuffer = [];\n      this.fetchMoreRespHeaders = getInitialHeader();\n      return this.nonStreamingOrderBy\n        ? this._nonStreamingFetchMoreImplementation(diagnosticNode)\n        : this._fetchMoreImplementation(diagnosticNode);\n    }\n  }\n\n  private async _fetchMoreImplementation(\n    diagnosticNode: DiagnosticNodeInternal,\n  ): Promise<Response<any>> {\n    try {\n      const { result: item, headers } = await this.endpoint.nextItem(diagnosticNode);\n      mergeHeaders(this.fetchMoreRespHeaders, headers);\n      if (item === undefined) {\n        // no more results\n        if (this.fetchBuffer.length === 0) {\n          return {\n            result: undefined,\n            headers: this.fetchMoreRespHeaders,\n          };\n        } else {\n          // Just give what we have\n          const temp = this.fetchBuffer;\n          this.fetchBuffer = [];\n          return { result: temp, headers: this.fetchMoreRespHeaders };\n        }\n      } else {\n        this.fetchBuffer.push(item);\n        if (this.fetchBuffer.length >= this.pageSize) {\n          // fetched enough results\n          const temp = this.fetchBuffer.slice(0, this.pageSize);\n          this.fetchBuffer = this.fetchBuffer.splice(this.pageSize);\n          return { result: temp, headers: this.fetchMoreRespHeaders };\n        } else {\n          // recursively fetch more\n          // TODO: is recursion a good idea?\n          return this._fetchMoreImplementation(diagnosticNode);\n        }\n      }\n    } catch (err: any) {\n      mergeHeaders(this.fetchMoreRespHeaders, err.headers);\n      err.headers = this.fetchMoreRespHeaders;\n      if (err) {\n        throw err;\n      }\n    }\n  }\n\n  private async _nonStreamingFetchMoreImplementation(\n    diagnosticNode: DiagnosticNodeInternal,\n  ): Promise<Response<any>> {\n    try {\n      const { result: item, headers } = await this.endpoint.nextItem(diagnosticNode);\n      mergeHeaders(this.fetchMoreRespHeaders, headers);\n      if (item === undefined) {\n        // no more results\n        if (this.fetchBuffer.length === 0) {\n          return {\n            result: undefined,\n            headers: this.fetchMoreRespHeaders,\n          };\n        } else {\n          // Just give what we have\n          const temp = this.fetchBuffer;\n          this.fetchBuffer = [];\n          return { result: temp, headers: this.fetchMoreRespHeaders };\n        }\n      } else {\n        // append the result\n        if (typeof item !== \"object\") {\n          this.fetchBuffer.push(item);\n        } else if (Object.keys(item).length !== 0) {\n          this.fetchBuffer.push(item);\n        }\n        if (this.fetchBuffer.length >= this.pageSize) {\n          // fetched enough results\n          const temp = this.fetchBuffer.slice(0, this.pageSize);\n          this.fetchBuffer = this.fetchBuffer.splice(this.pageSize);\n          return { result: temp, headers: this.fetchMoreRespHeaders };\n        } else {\n          return this._nonStreamingFetchMoreImplementation(diagnosticNode);\n        }\n      }\n    } catch (err: any) {\n      mergeHeaders(this.fetchMoreRespHeaders, err.headers);\n      err.headers = this.fetchMoreRespHeaders;\n      if (err) {\n        throw err;\n      }\n    }\n  }\n\n  private calculateVectorSearchBufferSize(queryInfo: QueryInfo, options: FeedOptions): number {\n    if (queryInfo.top === 0 || queryInfo.limit === 0) return 0;\n    return queryInfo.top\n      ? queryInfo.top\n      : queryInfo.limit\n        ? queryInfo.offset + queryInfo.limit\n        : options[\"vectorSearchBufferSize\"] && options[\"vectorSearchBufferSize\"] > 0\n          ? options[\"vectorSearchBufferSize\"]\n          : PipelinedQueryExecutionContext.DEFAULT_MAX_VECTOR_SEARCH_BUFFER_SIZE;\n  }\n\n  private checkQueryConstraints(queryInfo: QueryInfo): void {\n    const hasTop = queryInfo.top || queryInfo.top === 0;\n    const hasLimit = queryInfo.limit || queryInfo.limit === 0;\n    if (!hasTop && !hasLimit) {\n      throw new ErrorResponse(\n        \"Executing a non-streaming search query without TOP or LIMIT can consume a large number of RUs \" +\n          \"very fast and have long runtimes. Please ensure you are using one of the above two filters \" +\n          \"with your vector search query.\",\n      );\n    }\n    return;\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}