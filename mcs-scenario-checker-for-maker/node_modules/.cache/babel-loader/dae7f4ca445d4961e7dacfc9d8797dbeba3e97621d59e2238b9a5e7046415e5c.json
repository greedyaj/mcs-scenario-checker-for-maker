{"ast":null,"code":"import { createClientLogger } from \"@azure/logger\";\nimport { Constants } from \"../common\";\nimport { ClientSideMetrics, QueryMetrics } from \"../queryMetrics\";\nimport { getInitialHeader } from \"./headerUtils\";\nimport { DiagnosticNodeType } from \"../diagnostics/DiagnosticNodeInternal\";\nimport { addDignosticChild } from \"../utils/diagnostics\";\nimport { CosmosDbDiagnosticLevel } from \"../diagnostics/CosmosDbDiagnosticLevel\";\nconst logger = createClientLogger(\"ClientContext\");\n/** @hidden */\nvar STATES;\n(function (STATES) {\n  STATES[\"start\"] = \"start\";\n  STATES[\"inProgress\"] = \"inProgress\";\n  STATES[\"ended\"] = \"ended\";\n})(STATES || (STATES = {}));\n/** @hidden */\nexport class DefaultQueryExecutionContext {\n  get continuation() {\n    return this.continuationToken;\n  }\n  /**\n   * Provides the basic Query Execution Context.\n   * This wraps the internal logic query execution using provided fetch functions\n   *\n   * @param clientContext  - Is used to read the partitionKeyRanges for split proofing\n   * @param query          - A SQL query.\n   * @param options        - Represents the feed options.\n   * @param fetchFunctions - A function to retrieve each page of data.\n   *                          An array of functions may be used to query more than one partition.\n   * @hidden\n   */\n  constructor(options, fetchFunctions, correlatedActivityId) {\n    this.resources = [];\n    this.currentIndex = 0;\n    this.currentPartitionIndex = 0;\n    this.fetchFunctions = Array.isArray(fetchFunctions) ? fetchFunctions : [fetchFunctions];\n    this.options = options || {};\n    this.continuationToken = this.options.continuationToken || this.options.continuation || null;\n    this.state = DefaultQueryExecutionContext.STATES.start;\n    this.correlatedActivityId = correlatedActivityId;\n  }\n  /**\n   * Execute a provided callback on the next element in the execution context.\n   */\n  async nextItem(diagnosticNode) {\n    ++this.currentIndex;\n    const response = await this.current(diagnosticNode);\n    return response;\n  }\n  /**\n   * Retrieve the current element on the execution context.\n   */\n  async current(diagnosticNode) {\n    if (this.currentIndex < this.resources.length) {\n      return {\n        result: this.resources[this.currentIndex],\n        headers: getInitialHeader()\n      };\n    }\n    if (this._canFetchMore()) {\n      const {\n        result: resources,\n        headers\n      } = await this.fetchMore(diagnosticNode);\n      this.resources = resources;\n      if (this.resources.length === 0) {\n        if (!this.continuationToken && this.currentPartitionIndex >= this.fetchFunctions.length) {\n          this.state = DefaultQueryExecutionContext.STATES.ended;\n          return {\n            result: undefined,\n            headers\n          };\n        } else {\n          return this.current(diagnosticNode);\n        }\n      }\n      return {\n        result: this.resources[this.currentIndex],\n        headers\n      };\n    } else {\n      this.state = DefaultQueryExecutionContext.STATES.ended;\n      return {\n        result: undefined,\n        headers: getInitialHeader()\n      };\n    }\n  }\n  /**\n   * Determine if there are still remaining resources to processs based on\n   * the value of the continuation token or the elements remaining on the current batch in the execution context.\n   *\n   * @returns true if there is other elements to process in the DefaultQueryExecutionContext.\n   */\n  hasMoreResults() {\n    return this.state === DefaultQueryExecutionContext.STATES.start || this.continuationToken !== undefined || this.currentIndex < this.resources.length - 1 || this.currentPartitionIndex < this.fetchFunctions.length;\n  }\n  /**\n   * Fetches the next batch of the feed and pass them as an array to a callback\n   */\n  async fetchMore(diagnosticNode) {\n    return addDignosticChild(async childDiagnosticNode => {\n      if (this.currentPartitionIndex >= this.fetchFunctions.length) {\n        return {\n          headers: getInitialHeader(),\n          result: undefined\n        };\n      }\n      // Keep to the original continuation and to restore the value after fetchFunction call\n      const originalContinuation = this.options.continuationToken || this.options.continuation;\n      this.options.continuationToken = this.continuationToken;\n      // Return undefined if there is no more results\n      if (this.currentPartitionIndex >= this.fetchFunctions.length) {\n        return {\n          headers: getInitialHeader(),\n          result: undefined\n        };\n      }\n      let resources;\n      let responseHeaders;\n      try {\n        let p;\n        if (this.nextFetchFunction !== undefined) {\n          logger.verbose(\"using prefetch\");\n          p = this.nextFetchFunction;\n          this.nextFetchFunction = undefined;\n        } else {\n          logger.verbose(\"using fresh fetch\");\n          p = this.fetchFunctions[this.currentPartitionIndex](childDiagnosticNode, this.options, this.correlatedActivityId);\n        }\n        const response = await p;\n        resources = response.result;\n        childDiagnosticNode.recordQueryResult(resources, CosmosDbDiagnosticLevel.debugUnsafe);\n        responseHeaders = response.headers;\n        this.continuationToken = responseHeaders[Constants.HttpHeaders.Continuation];\n        if (!this.continuationToken) {\n          ++this.currentPartitionIndex;\n        }\n        if (this.options && this.options.bufferItems === true) {\n          const fetchFunction = this.fetchFunctions[this.currentPartitionIndex];\n          this.nextFetchFunction = fetchFunction ? fetchFunction(childDiagnosticNode, Object.assign(Object.assign({}, this.options), {\n            continuationToken: this.continuationToken\n          }), this.correlatedActivityId) : undefined;\n        }\n      } catch (err) {\n        this.state = DefaultQueryExecutionContext.STATES.ended;\n        // return callback(err, undefined, responseHeaders);\n        // TODO: Error and data being returned is an antipattern, this might broken\n        throw err;\n      }\n      this.state = DefaultQueryExecutionContext.STATES.inProgress;\n      this.currentIndex = 0;\n      this.options.continuationToken = originalContinuation;\n      this.options.continuation = originalContinuation;\n      // deserializing query metrics so that we aren't working with delimited strings in the rest of the code base\n      if (Constants.HttpHeaders.QueryMetrics in responseHeaders) {\n        const delimitedString = responseHeaders[Constants.HttpHeaders.QueryMetrics];\n        let queryMetrics = QueryMetrics.createFromDelimitedString(delimitedString);\n        // Add the request charge to the query metrics so that we can have per partition request charge.\n        if (Constants.HttpHeaders.RequestCharge in responseHeaders) {\n          const requestCharge = Number(responseHeaders[Constants.HttpHeaders.RequestCharge]) || 0;\n          queryMetrics = new QueryMetrics(queryMetrics.retrievedDocumentCount, queryMetrics.retrievedDocumentSize, queryMetrics.outputDocumentCount, queryMetrics.outputDocumentSize, queryMetrics.indexHitDocumentCount, queryMetrics.totalQueryExecutionTime, queryMetrics.queryPreparationTimes, queryMetrics.indexLookupTime, queryMetrics.documentLoadTime, queryMetrics.vmExecutionTime, queryMetrics.runtimeExecutionTimes, queryMetrics.documentWriteTime, new ClientSideMetrics(requestCharge));\n        }\n        // Wraping query metrics in a object where the key is '0' just so single partition\n        // and partition queries have the same response schema\n        responseHeaders[Constants.HttpHeaders.QueryMetrics] = {};\n        responseHeaders[Constants.HttpHeaders.QueryMetrics][\"0\"] = queryMetrics;\n      }\n      return {\n        result: resources,\n        headers: responseHeaders\n      };\n    }, diagnosticNode, DiagnosticNodeType.DEFAULT_QUERY_NODE, {\n      queryMethodIdentifier: \"fetchMore\"\n    });\n  }\n  _canFetchMore() {\n    const res = this.state === DefaultQueryExecutionContext.STATES.start || this.continuationToken && this.state === DefaultQueryExecutionContext.STATES.inProgress || this.currentPartitionIndex < this.fetchFunctions.length && this.state === DefaultQueryExecutionContext.STATES.inProgress;\n    return res;\n  }\n}\nDefaultQueryExecutionContext.STATES = STATES;","map":{"version":3,"names":["createClientLogger","Constants","ClientSideMetrics","QueryMetrics","getInitialHeader","DiagnosticNodeType","addDignosticChild","CosmosDbDiagnosticLevel","logger","STATES","DefaultQueryExecutionContext","continuation","continuationToken","constructor","options","fetchFunctions","correlatedActivityId","resources","currentIndex","currentPartitionIndex","Array","isArray","state","start","nextItem","diagnosticNode","response","current","length","result","headers","_canFetchMore","fetchMore","ended","undefined","hasMoreResults","childDiagnosticNode","originalContinuation","responseHeaders","p","nextFetchFunction","verbose","recordQueryResult","debugUnsafe","HttpHeaders","Continuation","bufferItems","fetchFunction","Object","assign","err","inProgress","delimitedString","queryMetrics","createFromDelimitedString","RequestCharge","requestCharge","Number","retrievedDocumentCount","retrievedDocumentSize","outputDocumentCount","outputDocumentSize","indexHitDocumentCount","totalQueryExecutionTime","queryPreparationTimes","indexLookupTime","documentLoadTime","vmExecutionTime","runtimeExecutionTimes","documentWriteTime","DEFAULT_QUERY_NODE","queryMethodIdentifier","res"],"sources":["/Users/ajitpawar/microsoft/bap/POCs/Scenario_checker_for_maker/mcs-scenario-checker-for-maker/node_modules/@azure/cosmos/src/queryExecutionContext/defaultQueryExecutionContext.ts"],"sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport type { AzureLogger } from \"@azure/logger\";\nimport { createClientLogger } from \"@azure/logger\";\nimport { Constants } from \"../common\";\nimport { ClientSideMetrics, QueryMetrics } from \"../queryMetrics\";\nimport type { FeedOptions, Response } from \"../request\";\nimport { getInitialHeader } from \"./headerUtils\";\nimport type { ExecutionContext } from \"./index\";\nimport type { DiagnosticNodeInternal } from \"../diagnostics/DiagnosticNodeInternal\";\nimport { DiagnosticNodeType } from \"../diagnostics/DiagnosticNodeInternal\";\nimport { addDignosticChild } from \"../utils/diagnostics\";\nimport { CosmosDbDiagnosticLevel } from \"../diagnostics/CosmosDbDiagnosticLevel\";\n\nconst logger: AzureLogger = createClientLogger(\"ClientContext\");\n/** @hidden */\nexport type FetchFunctionCallback = (\n  diagnosticNode: DiagnosticNodeInternal,\n  options: FeedOptions,\n  correlatedActivityId: string,\n) => Promise<Response<any>>;\n\n/** @hidden */\nenum STATES {\n  start = \"start\",\n  inProgress = \"inProgress\",\n  ended = \"ended\",\n}\n\n/** @hidden */\nexport class DefaultQueryExecutionContext implements ExecutionContext {\n  private static readonly STATES = STATES;\n  private resources: any[]; // TODO: any resources\n  private currentIndex: number;\n  private currentPartitionIndex: number;\n  private fetchFunctions: FetchFunctionCallback[];\n  private options: FeedOptions; // TODO: any options\n  public continuationToken: string; // TODO: any continuation\n  public get continuation(): string {\n    return this.continuationToken;\n  }\n  private state: STATES;\n  private nextFetchFunction: Promise<Response<any>>;\n  private correlatedActivityId: string;\n  /**\n   * Provides the basic Query Execution Context.\n   * This wraps the internal logic query execution using provided fetch functions\n   *\n   * @param clientContext  - Is used to read the partitionKeyRanges for split proofing\n   * @param query          - A SQL query.\n   * @param options        - Represents the feed options.\n   * @param fetchFunctions - A function to retrieve each page of data.\n   *                          An array of functions may be used to query more than one partition.\n   * @hidden\n   */\n  constructor(\n    options: FeedOptions,\n    fetchFunctions: FetchFunctionCallback | FetchFunctionCallback[],\n    correlatedActivityId: string,\n  ) {\n    this.resources = [];\n    this.currentIndex = 0;\n    this.currentPartitionIndex = 0;\n    this.fetchFunctions = Array.isArray(fetchFunctions) ? fetchFunctions : [fetchFunctions];\n    this.options = options || {};\n    this.continuationToken = this.options.continuationToken || this.options.continuation || null;\n    this.state = DefaultQueryExecutionContext.STATES.start;\n    this.correlatedActivityId = correlatedActivityId;\n  }\n\n  /**\n   * Execute a provided callback on the next element in the execution context.\n   */\n  public async nextItem(diagnosticNode: DiagnosticNodeInternal): Promise<Response<any>> {\n    ++this.currentIndex;\n    const response = await this.current(diagnosticNode);\n    return response;\n  }\n\n  /**\n   * Retrieve the current element on the execution context.\n   */\n  public async current(diagnosticNode: DiagnosticNodeInternal): Promise<Response<any>> {\n    if (this.currentIndex < this.resources.length) {\n      return {\n        result: this.resources[this.currentIndex],\n        headers: getInitialHeader(),\n      };\n    }\n\n    if (this._canFetchMore()) {\n      const { result: resources, headers } = await this.fetchMore(diagnosticNode);\n      this.resources = resources;\n      if (this.resources.length === 0) {\n        if (!this.continuationToken && this.currentPartitionIndex >= this.fetchFunctions.length) {\n          this.state = DefaultQueryExecutionContext.STATES.ended;\n          return { result: undefined, headers };\n        } else {\n          return this.current(diagnosticNode);\n        }\n      }\n      return { result: this.resources[this.currentIndex], headers };\n    } else {\n      this.state = DefaultQueryExecutionContext.STATES.ended;\n      return {\n        result: undefined,\n        headers: getInitialHeader(),\n      };\n    }\n  }\n\n  /**\n   * Determine if there are still remaining resources to processs based on\n   * the value of the continuation token or the elements remaining on the current batch in the execution context.\n   *\n   * @returns true if there is other elements to process in the DefaultQueryExecutionContext.\n   */\n  public hasMoreResults(): boolean {\n    return (\n      this.state === DefaultQueryExecutionContext.STATES.start ||\n      this.continuationToken !== undefined ||\n      this.currentIndex < this.resources.length - 1 ||\n      this.currentPartitionIndex < this.fetchFunctions.length\n    );\n  }\n\n  /**\n   * Fetches the next batch of the feed and pass them as an array to a callback\n   */\n  public async fetchMore(diagnosticNode: DiagnosticNodeInternal): Promise<Response<any>> {\n    return addDignosticChild(\n      async (childDiagnosticNode: DiagnosticNodeInternal) => {\n        if (this.currentPartitionIndex >= this.fetchFunctions.length) {\n          return {\n            headers: getInitialHeader(),\n            result: undefined,\n          };\n        }\n\n        // Keep to the original continuation and to restore the value after fetchFunction call\n        const originalContinuation = this.options.continuationToken || this.options.continuation;\n        this.options.continuationToken = this.continuationToken;\n\n        // Return undefined if there is no more results\n        if (this.currentPartitionIndex >= this.fetchFunctions.length) {\n          return {\n            headers: getInitialHeader(),\n            result: undefined,\n          };\n        }\n\n        let resources;\n        let responseHeaders;\n        try {\n          let p: Promise<Response<any>>;\n          if (this.nextFetchFunction !== undefined) {\n            logger.verbose(\"using prefetch\");\n            p = this.nextFetchFunction;\n            this.nextFetchFunction = undefined;\n          } else {\n            logger.verbose(\"using fresh fetch\");\n            p = this.fetchFunctions[this.currentPartitionIndex](\n              childDiagnosticNode,\n              this.options,\n              this.correlatedActivityId,\n            );\n          }\n          const response = await p;\n          resources = response.result;\n          childDiagnosticNode.recordQueryResult(resources, CosmosDbDiagnosticLevel.debugUnsafe);\n          responseHeaders = response.headers;\n          this.continuationToken = responseHeaders[Constants.HttpHeaders.Continuation];\n          if (!this.continuationToken) {\n            ++this.currentPartitionIndex;\n          }\n\n          if (this.options && this.options.bufferItems === true) {\n            const fetchFunction = this.fetchFunctions[this.currentPartitionIndex];\n            this.nextFetchFunction = fetchFunction\n              ? fetchFunction(\n                  childDiagnosticNode,\n                  {\n                    ...this.options,\n                    continuationToken: this.continuationToken,\n                  },\n                  this.correlatedActivityId,\n                )\n              : undefined;\n          }\n        } catch (err: any) {\n          this.state = DefaultQueryExecutionContext.STATES.ended;\n          // return callback(err, undefined, responseHeaders);\n          // TODO: Error and data being returned is an antipattern, this might broken\n          throw err;\n        }\n\n        this.state = DefaultQueryExecutionContext.STATES.inProgress;\n        this.currentIndex = 0;\n        this.options.continuationToken = originalContinuation;\n        this.options.continuation = originalContinuation;\n\n        // deserializing query metrics so that we aren't working with delimited strings in the rest of the code base\n        if (Constants.HttpHeaders.QueryMetrics in responseHeaders) {\n          const delimitedString = responseHeaders[Constants.HttpHeaders.QueryMetrics];\n          let queryMetrics = QueryMetrics.createFromDelimitedString(delimitedString);\n\n          // Add the request charge to the query metrics so that we can have per partition request charge.\n          if (Constants.HttpHeaders.RequestCharge in responseHeaders) {\n            const requestCharge = Number(responseHeaders[Constants.HttpHeaders.RequestCharge]) || 0;\n            queryMetrics = new QueryMetrics(\n              queryMetrics.retrievedDocumentCount,\n              queryMetrics.retrievedDocumentSize,\n              queryMetrics.outputDocumentCount,\n              queryMetrics.outputDocumentSize,\n              queryMetrics.indexHitDocumentCount,\n              queryMetrics.totalQueryExecutionTime,\n              queryMetrics.queryPreparationTimes,\n              queryMetrics.indexLookupTime,\n              queryMetrics.documentLoadTime,\n              queryMetrics.vmExecutionTime,\n              queryMetrics.runtimeExecutionTimes,\n              queryMetrics.documentWriteTime,\n              new ClientSideMetrics(requestCharge),\n            );\n          }\n\n          // Wraping query metrics in a object where the key is '0' just so single partition\n          // and partition queries have the same response schema\n          responseHeaders[Constants.HttpHeaders.QueryMetrics] = {};\n          responseHeaders[Constants.HttpHeaders.QueryMetrics][\"0\"] = queryMetrics;\n        }\n\n        return { result: resources, headers: responseHeaders };\n      },\n      diagnosticNode,\n      DiagnosticNodeType.DEFAULT_QUERY_NODE,\n      {\n        queryMethodIdentifier: \"fetchMore\",\n      },\n    );\n  }\n\n  private _canFetchMore(): boolean {\n    const res =\n      this.state === DefaultQueryExecutionContext.STATES.start ||\n      (this.continuationToken && this.state === DefaultQueryExecutionContext.STATES.inProgress) ||\n      (this.currentPartitionIndex < this.fetchFunctions.length &&\n        this.state === DefaultQueryExecutionContext.STATES.inProgress);\n    return res;\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}