{"ast":null,"code":"// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport { createClientLogger } from \"@azure/logger\";\nimport { HybridSearchQueryResult } from \"../request/hybridSearchQueryResult\";\nimport { GlobalStatisticsAggregator } from \"./Aggregators/GlobalStatisticsAggregator\";\nimport { getInitialHeader, mergeHeaders } from \"./headerUtils\";\nimport { ParallelQueryExecutionContext } from \"./parallelQueryExecutionContext\";\nimport { PipelinedQueryExecutionContext } from \"./pipelinedQueryExecutionContext\";\n/** @hidden */\nexport var HybridQueryExecutionContextBaseStates;\n(function (HybridQueryExecutionContextBaseStates) {\n  HybridQueryExecutionContextBaseStates[\"uninitialized\"] = \"uninitialized\";\n  HybridQueryExecutionContextBaseStates[\"initialized\"] = \"initialized\";\n  HybridQueryExecutionContextBaseStates[\"draining\"] = \"draining\";\n  HybridQueryExecutionContextBaseStates[\"done\"] = \"done\";\n})(HybridQueryExecutionContextBaseStates || (HybridQueryExecutionContextBaseStates = {}));\nexport class HybridQueryExecutionContext {\n  constructor(clientContext, collectionLink, options, partitionedQueryExecutionInfo, correlatedActivityId, allPartitionsRanges) {\n    this.clientContext = clientContext;\n    this.collectionLink = collectionLink;\n    this.options = options;\n    this.partitionedQueryExecutionInfo = partitionedQueryExecutionInfo;\n    this.correlatedActivityId = correlatedActivityId;\n    this.allPartitionsRanges = allPartitionsRanges;\n    this.componentsExecutionContext = [];\n    this.emitRawOrderByPayload = true;\n    this.buffer = [];\n    this.DEFAULT_PAGE_SIZE = 10;\n    this.TOTAL_WORD_COUNT_PLACEHOLDER = \"documentdb-formattablehybridsearchquery-totalwordcount\";\n    this.HIT_COUNTS_ARRAY_PLACEHOLDER = \"documentdb-formattablehybridsearchquery-hitcountsarray\";\n    this.TOTAL_DOCUMENT_COUNT_PLACEHOLDER = \"documentdb-formattablehybridsearchquery-totaldocumentcount\";\n    this.RRF_CONSTANT = 60; // Constant for RRF score calculation\n    this.logger = createClientLogger(\"HybridQueryExecutionContext\");\n    this.state = HybridQueryExecutionContextBaseStates.uninitialized;\n    this.pageSize = this.options.maxItemCount;\n    if (this.pageSize === undefined) {\n      this.pageSize = this.DEFAULT_PAGE_SIZE;\n    }\n    if (partitionedQueryExecutionInfo.hybridSearchQueryInfo.requiresGlobalStatistics) {\n      const globalStaticsQueryOptions = {\n        maxItemCount: this.pageSize\n      };\n      this.globalStatisticsAggregator = new GlobalStatisticsAggregator();\n      const globalStatisticsQuery = this.partitionedQueryExecutionInfo.hybridSearchQueryInfo.globalStatisticsQuery;\n      const globalStatisticsQueryExecutionInfo = {\n        partitionedQueryExecutionInfoVersion: 1,\n        queryInfo: {\n          distinctType: \"None\",\n          hasSelectValue: false,\n          groupByAliasToAggregateType: {},\n          rewrittenQuery: globalStatisticsQuery,\n          hasNonStreamingOrderBy: false\n        },\n        queryRanges: this.allPartitionsRanges\n      };\n      this.globalStatisticsExecutionContext = new ParallelQueryExecutionContext(this.clientContext, this.collectionLink, globalStatisticsQuery, globalStaticsQueryOptions, globalStatisticsQueryExecutionInfo, this.correlatedActivityId);\n    } else {\n      this.createComponentExecutionContexts();\n      this.state = HybridQueryExecutionContextBaseStates.initialized;\n    }\n  }\n  async nextItem(diagnosticNode) {\n    const nextItemRespHeaders = getInitialHeader();\n    while ((this.state === HybridQueryExecutionContextBaseStates.uninitialized || this.state === HybridQueryExecutionContextBaseStates.initialized) && this.buffer.length === 0) {\n      await this.fetchMoreInternal(diagnosticNode, nextItemRespHeaders);\n    }\n    if (this.state === HybridQueryExecutionContextBaseStates.draining && this.buffer.length > 0) {\n      return this.drainOne(nextItemRespHeaders);\n    } else {\n      return this.done(nextItemRespHeaders);\n    }\n  }\n  hasMoreResults() {\n    switch (this.state) {\n      case HybridQueryExecutionContextBaseStates.uninitialized:\n        return true;\n      case HybridQueryExecutionContextBaseStates.initialized:\n        return true;\n      case HybridQueryExecutionContextBaseStates.draining:\n        return this.buffer.length > 0;\n      case HybridQueryExecutionContextBaseStates.done:\n        return false;\n      default:\n        return false;\n    }\n  }\n  async fetchMore(diagnosticNode) {\n    const fetchMoreRespHeaders = getInitialHeader();\n    return this.fetchMoreInternal(diagnosticNode, fetchMoreRespHeaders);\n  }\n  async fetchMoreInternal(diagnosticNode, headers) {\n    switch (this.state) {\n      case HybridQueryExecutionContextBaseStates.uninitialized:\n        await this.initialize(diagnosticNode, headers);\n        return {\n          result: [],\n          headers: headers\n        };\n      case HybridQueryExecutionContextBaseStates.initialized:\n        await this.executeComponentQueries(diagnosticNode, headers);\n        return {\n          result: [],\n          headers: headers\n        };\n      case HybridQueryExecutionContextBaseStates.draining:\n        return this.drain(headers);\n      case HybridQueryExecutionContextBaseStates.done:\n        return this.done(headers);\n      default:\n        throw new Error(`Invalid state: ${this.state}`);\n    }\n  }\n  async initialize(diagnosticNode, fetchMoreRespHeaders) {\n    try {\n      while (this.globalStatisticsExecutionContext.hasMoreResults()) {\n        const result = await this.globalStatisticsExecutionContext.nextItem(diagnosticNode);\n        const globalStatistics = result.result;\n        mergeHeaders(fetchMoreRespHeaders, result.headers);\n        if (globalStatistics) {\n          // iterate over the components update placeholders from globalStatistics\n          this.globalStatisticsAggregator.aggregate(globalStatistics);\n        }\n      }\n    } catch (error) {\n      this.state = HybridQueryExecutionContextBaseStates.done;\n      throw error;\n    }\n    // create component execution contexts for each component query\n    this.createComponentExecutionContexts();\n    this.state = HybridQueryExecutionContextBaseStates.initialized;\n  }\n  async executeComponentQueries(diagnosticNode, fetchMoreRespHeaders) {\n    if (this.componentsExecutionContext.length === 1) {\n      await this.drainSingleComponent(diagnosticNode, fetchMoreRespHeaders);\n      return;\n    }\n    try {\n      const hybridSearchResult = [];\n      const uniqueItems = new Map();\n      for (const componentExecutionContext of this.componentsExecutionContext) {\n        while (componentExecutionContext.hasMoreResults()) {\n          const result = await componentExecutionContext.fetchMore(diagnosticNode);\n          const response = result.result;\n          mergeHeaders(fetchMoreRespHeaders, result.headers);\n          if (response) {\n            response.forEach(item => {\n              const hybridItem = HybridSearchQueryResult.create(item);\n              if (!uniqueItems.has(hybridItem.rid)) {\n                uniqueItems.set(hybridItem.rid, hybridItem);\n              }\n            });\n          }\n        }\n      }\n      uniqueItems.forEach(item => hybridSearchResult.push(item));\n      if (hybridSearchResult.length === 0 || hybridSearchResult.length === 1) {\n        // return the result as no or one element is present\n        hybridSearchResult.forEach(item => this.buffer.push(item.data));\n        this.state = HybridQueryExecutionContextBaseStates.draining;\n        return;\n      }\n      // Initialize an array to hold ranks for each document\n      const sortedHybridSearchResult = this.sortHybridSearchResultByRRFScore(hybridSearchResult);\n      // store the result to buffer\n      // add only data from the sortedHybridSearchResult in the buffer\n      sortedHybridSearchResult.forEach(item => this.buffer.push(item.data));\n      this.applySkipAndTakeToBuffer();\n      this.state = HybridQueryExecutionContextBaseStates.draining;\n    } catch (error) {\n      this.state = HybridQueryExecutionContextBaseStates.done;\n      throw error;\n    }\n  }\n  applySkipAndTakeToBuffer() {\n    const {\n      skip,\n      take\n    } = this.partitionedQueryExecutionInfo.hybridSearchQueryInfo;\n    if (skip) {\n      this.buffer = skip >= this.buffer.length ? [] : this.buffer.slice(skip);\n    }\n    if (take) {\n      this.buffer = take <= 0 ? [] : this.buffer.slice(0, take);\n    }\n  }\n  async drain(fetchMoreRespHeaders) {\n    try {\n      if (this.buffer.length === 0) {\n        this.state = HybridQueryExecutionContextBaseStates.done;\n        return this.done(fetchMoreRespHeaders);\n      }\n      const result = this.buffer.slice(0, this.pageSize);\n      this.buffer = this.buffer.slice(this.pageSize);\n      if (this.buffer.length === 0) {\n        this.state = HybridQueryExecutionContextBaseStates.done;\n      }\n      return {\n        result: result,\n        headers: fetchMoreRespHeaders\n      };\n    } catch (error) {\n      this.state = HybridQueryExecutionContextBaseStates.done;\n      throw error;\n    }\n  }\n  async drainOne(nextItemRespHeaders) {\n    try {\n      if (this.buffer.length === 0) {\n        this.state = HybridQueryExecutionContextBaseStates.done;\n        return this.done(nextItemRespHeaders);\n      }\n      const result = this.buffer.shift();\n      if (this.buffer.length === 0) {\n        this.state = HybridQueryExecutionContextBaseStates.done;\n      }\n      return {\n        result: result,\n        headers: nextItemRespHeaders\n      };\n    } catch (error) {\n      this.state = HybridQueryExecutionContextBaseStates.done;\n      throw error;\n    }\n  }\n  done(fetchMoreRespHeaders) {\n    return {\n      result: undefined,\n      headers: fetchMoreRespHeaders\n    };\n  }\n  sortHybridSearchResultByRRFScore(hybridSearchResult) {\n    const ranksArray = hybridSearchResult.map(item => ({\n      rid: item.rid,\n      ranks: new Array(item.componentScores.length).fill(0)\n    }));\n    // Compute ranks for each component score\n    for (let i = 0; i < hybridSearchResult[0].componentScores.length; i++) {\n      // Sort based on the i-th component score\n      hybridSearchResult.sort((a, b) => b.componentScores[i] - a.componentScores[i]);\n      // Assign ranks\n      let rank = 1;\n      for (let j = 0; j < hybridSearchResult.length; j++) {\n        if (j > 0 && hybridSearchResult[j].componentScores[i] !== hybridSearchResult[j - 1].componentScores[i]) {\n          rank = j + 1;\n        }\n        const rankIndex = ranksArray.findIndex(rankItem => rankItem.rid === hybridSearchResult[j].rid);\n        ranksArray[rankIndex].ranks[i] = rank; // 1-based rank\n      }\n    }\n    // Function to compute RRF score\n    const computeRRFScore = (ranks, k) => {\n      return ranks.reduce((acc, rank) => acc + 1 / (k + rank), 0);\n    };\n    // Compute RRF scores and sort based on them\n    const rrfScores = ranksArray.map(item => ({\n      rid: item.rid,\n      rrfScore: computeRRFScore(item.ranks, this.RRF_CONSTANT)\n    }));\n    // Sort based on RRF scores\n    rrfScores.sort((a, b) => b.rrfScore - a.rrfScore);\n    // Map sorted RRF scores back to hybridSearchResult\n    const sortedHybridSearchResult = rrfScores.map(scoreItem => hybridSearchResult.find(item => item.rid === scoreItem.rid));\n    return sortedHybridSearchResult;\n  }\n  async drainSingleComponent(diagNode, fetchMoreRespHeaders) {\n    if (this.componentsExecutionContext && this.componentsExecutionContext.length !== 1) {\n      this.logger.error(\"drainSingleComponent called on multiple components\");\n      return;\n    }\n    try {\n      const componentExecutionContext = this.componentsExecutionContext[0];\n      const hybridSearchResult = [];\n      while (componentExecutionContext.hasMoreResults()) {\n        const result = await componentExecutionContext.fetchMore(diagNode);\n        const response = result.result;\n        mergeHeaders(fetchMoreRespHeaders, result.headers);\n        if (response) {\n          response.forEach(item => {\n            hybridSearchResult.push(HybridSearchQueryResult.create(item));\n          });\n        }\n      }\n      hybridSearchResult.forEach(item => this.buffer.push(item.data));\n      this.applySkipAndTakeToBuffer();\n      this.state = HybridQueryExecutionContextBaseStates.draining;\n    } catch (error) {\n      this.state = HybridQueryExecutionContextBaseStates.done;\n      throw error;\n    }\n  }\n  createComponentExecutionContexts() {\n    // rewrite queries based on global statistics\n    let queryInfos = this.partitionedQueryExecutionInfo.hybridSearchQueryInfo.componentQueryInfos;\n    if (this.partitionedQueryExecutionInfo.hybridSearchQueryInfo.requiresGlobalStatistics) {\n      queryInfos = this.processComponentQueries(this.partitionedQueryExecutionInfo.hybridSearchQueryInfo.componentQueryInfos, this.globalStatisticsAggregator.getResult());\n    }\n    // create component execution contexts\n    for (const componentQueryInfo of queryInfos) {\n      const componentPartitionExecutionInfo = {\n        partitionedQueryExecutionInfoVersion: 1,\n        queryInfo: componentQueryInfo,\n        queryRanges: this.partitionedQueryExecutionInfo.queryRanges\n      };\n      this.componentsExecutionContext.push(new PipelinedQueryExecutionContext(this.clientContext, this.collectionLink, componentQueryInfo.rewrittenQuery, this.options, componentPartitionExecutionInfo, this.correlatedActivityId, this.emitRawOrderByPayload));\n    }\n  }\n  processComponentQueries(componentQueryInfos, globalStats) {\n    return componentQueryInfos.map(queryInfo => {\n      if (!queryInfo.hasNonStreamingOrderBy) {\n        throw new Error(\"The component query must have a non-streaming order by clause.\");\n      }\n      return Object.assign(Object.assign({}, queryInfo), {\n        rewrittenQuery: this.replacePlaceholdersWorkaroud(queryInfo.rewrittenQuery, globalStats, componentQueryInfos.length),\n        orderByExpressions: queryInfo.orderByExpressions.map(expr => this.replacePlaceholdersWorkaroud(expr, globalStats, componentQueryInfos.length))\n      });\n    });\n  }\n  // This method is commented currently, but we will switch back to using this\n  // once the gateway has been redeployed with the fix for placeholder indexes\n  // private replacePlaceholders(query: string, globalStats: GlobalStatistics): string {\n  //   // Replace total document count\n  //   query = query.replace(\n  //     new RegExp(`{${this.TOTAL_DOCUMENT_COUNT_PLACEHOLDER}}`, \"g\"),\n  //     globalStats.documentCount.toString(),\n  //   );\n  //   // Replace total word counts and hit counts from fullTextStatistics\n  //   globalStats.fullTextStatistics.forEach((stats, index) => {\n  //     // Replace total word counts\n  //     query = query.replace(\n  //       new RegExp(`{${this.TOTAL_WORD_COUNT_PLACEHOLDER}-${index}}`, \"g\"),\n  //       stats.totalWordCount.toString(),\n  //     );\n  //     // Replace hit counts\n  //     query = query.replace(\n  //       new RegExp(`{${this.HIT_COUNTS_ARRAY_PLACEHOLDER}-${index}}`, \"g\"),\n  //       `[${stats.hitCounts.join(\",\")}]`,\n  //     );\n  //   });\n  //   return query;\n  // }\n  replacePlaceholdersWorkaroud(query, globalStats, componentCount) {\n    // Replace total document count\n    query = query.replace(new RegExp(`{${this.TOTAL_DOCUMENT_COUNT_PLACEHOLDER}}`, \"g\"), globalStats.documentCount.toString());\n    let statisticsIndex = 0;\n    for (let i = 0; i < componentCount; i++) {\n      // Replace total word counts and hit counts from fullTextStatistics\n      const wordCountPlaceholder = `{${this.TOTAL_WORD_COUNT_PLACEHOLDER}-${i}}`;\n      const hitCountPlaceholder = `{${this.HIT_COUNTS_ARRAY_PLACEHOLDER}-${i}}`;\n      if (!query.includes(wordCountPlaceholder)) {\n        continue;\n      }\n      const stats = globalStats.fullTextStatistics[statisticsIndex];\n      // Replace total word counts\n      query = query.replace(new RegExp(wordCountPlaceholder, \"g\"), stats.totalWordCount.toString());\n      // Replace hit counts\n      query = query.replace(new RegExp(hitCountPlaceholder, \"g\"), `[${stats.hitCounts.join(\",\")}]`);\n      statisticsIndex++;\n    }\n    return query;\n  }\n}","map":{"version":3,"names":["createClientLogger","HybridSearchQueryResult","GlobalStatisticsAggregator","getInitialHeader","mergeHeaders","ParallelQueryExecutionContext","PipelinedQueryExecutionContext","HybridQueryExecutionContextBaseStates","HybridQueryExecutionContext","constructor","clientContext","collectionLink","options","partitionedQueryExecutionInfo","correlatedActivityId","allPartitionsRanges","componentsExecutionContext","emitRawOrderByPayload","buffer","DEFAULT_PAGE_SIZE","TOTAL_WORD_COUNT_PLACEHOLDER","HIT_COUNTS_ARRAY_PLACEHOLDER","TOTAL_DOCUMENT_COUNT_PLACEHOLDER","RRF_CONSTANT","logger","state","uninitialized","pageSize","maxItemCount","undefined","hybridSearchQueryInfo","requiresGlobalStatistics","globalStaticsQueryOptions","globalStatisticsAggregator","globalStatisticsQuery","globalStatisticsQueryExecutionInfo","partitionedQueryExecutionInfoVersion","queryInfo","distinctType","hasSelectValue","groupByAliasToAggregateType","rewrittenQuery","hasNonStreamingOrderBy","queryRanges","globalStatisticsExecutionContext","createComponentExecutionContexts","initialized","nextItem","diagnosticNode","nextItemRespHeaders","length","fetchMoreInternal","draining","drainOne","done","hasMoreResults","fetchMore","fetchMoreRespHeaders","headers","initialize","result","executeComponentQueries","drain","Error","globalStatistics","aggregate","error","drainSingleComponent","hybridSearchResult","uniqueItems","Map","componentExecutionContext","response","forEach","item","hybridItem","create","has","rid","set","push","data","sortedHybridSearchResult","sortHybridSearchResultByRRFScore","applySkipAndTakeToBuffer","skip","take","slice","shift","ranksArray","map","ranks","Array","componentScores","fill","i","sort","a","b","rank","j","rankIndex","findIndex","rankItem","computeRRFScore","k","reduce","acc","rrfScores","rrfScore","scoreItem","find","diagNode","queryInfos","componentQueryInfos","processComponentQueries","getResult","componentQueryInfo","componentPartitionExecutionInfo","globalStats","Object","assign","replacePlaceholdersWorkaroud","orderByExpressions","expr","query","componentCount","replace","RegExp","documentCount","toString","statisticsIndex","wordCountPlaceholder","hitCountPlaceholder","includes","stats","fullTextStatistics","totalWordCount","hitCounts","join"],"sources":["/Users/ajitpawar/microsoft/bap/POCs/Scenario_checker_for_maker/mcs-scenario-checker-for-maker/node_modules/@azure/cosmos/src/queryExecutionContext/hybridQueryExecutionContext.ts"],"sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\nimport { AzureLogger, createClientLogger } from \"@azure/logger\";\nimport { ClientContext } from \"../ClientContext\";\nimport { DiagnosticNodeInternal } from \"../diagnostics/DiagnosticNodeInternal\";\nimport {\n  FeedOptions,\n  GlobalStatistics,\n  PartitionedQueryExecutionInfo,\n  QueryInfo,\n  QueryRange,\n  Response,\n} from \"../request\";\nimport { HybridSearchQueryResult } from \"../request/hybridSearchQueryResult\";\nimport { GlobalStatisticsAggregator } from \"./Aggregators/GlobalStatisticsAggregator\";\nimport { CosmosHeaders } from \"./CosmosHeaders\";\nimport { ExecutionContext } from \"./ExecutionContext\";\nimport { getInitialHeader, mergeHeaders } from \"./headerUtils\";\nimport { ParallelQueryExecutionContext } from \"./parallelQueryExecutionContext\";\nimport { PipelinedQueryExecutionContext } from \"./pipelinedQueryExecutionContext\";\n\n/** @hidden */\nexport enum HybridQueryExecutionContextBaseStates {\n  uninitialized = \"uninitialized\",\n  initialized = \"initialized\",\n  draining = \"draining\",\n  done = \"done\",\n}\nexport class HybridQueryExecutionContext implements ExecutionContext {\n  private globalStatisticsExecutionContext: ExecutionContext;\n  private componentsExecutionContext: ExecutionContext[] = [];\n  private pageSize: number;\n  private state: HybridQueryExecutionContextBaseStates;\n  private globalStatisticsAggregator: GlobalStatisticsAggregator;\n  private emitRawOrderByPayload: boolean = true;\n  private buffer: HybridSearchQueryResult[] = [];\n  private DEFAULT_PAGE_SIZE = 10;\n  private TOTAL_WORD_COUNT_PLACEHOLDER = \"documentdb-formattablehybridsearchquery-totalwordcount\";\n  private HIT_COUNTS_ARRAY_PLACEHOLDER = \"documentdb-formattablehybridsearchquery-hitcountsarray\";\n  private TOTAL_DOCUMENT_COUNT_PLACEHOLDER =\n    \"documentdb-formattablehybridsearchquery-totaldocumentcount\";\n  private RRF_CONSTANT = 60; // Constant for RRF score calculation\n  private logger: AzureLogger = createClientLogger(\"HybridQueryExecutionContext\");\n\n  constructor(\n    private clientContext: ClientContext,\n    private collectionLink: string,\n    private options: FeedOptions,\n    private partitionedQueryExecutionInfo: PartitionedQueryExecutionInfo,\n    private correlatedActivityId: string,\n    private allPartitionsRanges: QueryRange[],\n  ) {\n    this.state = HybridQueryExecutionContextBaseStates.uninitialized;\n    this.pageSize = this.options.maxItemCount;\n    if (this.pageSize === undefined) {\n      this.pageSize = this.DEFAULT_PAGE_SIZE;\n    }\n    if (partitionedQueryExecutionInfo.hybridSearchQueryInfo.requiresGlobalStatistics) {\n      const globalStaticsQueryOptions: FeedOptions = { maxItemCount: this.pageSize };\n      this.globalStatisticsAggregator = new GlobalStatisticsAggregator();\n\n      const globalStatisticsQuery =\n        this.partitionedQueryExecutionInfo.hybridSearchQueryInfo.globalStatisticsQuery;\n      const globalStatisticsQueryExecutionInfo: PartitionedQueryExecutionInfo = {\n        partitionedQueryExecutionInfoVersion: 1,\n        queryInfo: {\n          distinctType: \"None\",\n          hasSelectValue: false,\n          groupByAliasToAggregateType: {},\n          rewrittenQuery: globalStatisticsQuery,\n          hasNonStreamingOrderBy: false,\n        },\n        queryRanges: this.allPartitionsRanges,\n      };\n\n      this.globalStatisticsExecutionContext = new ParallelQueryExecutionContext(\n        this.clientContext,\n        this.collectionLink,\n        globalStatisticsQuery,\n        globalStaticsQueryOptions,\n        globalStatisticsQueryExecutionInfo,\n        this.correlatedActivityId,\n      );\n    } else {\n      this.createComponentExecutionContexts();\n      this.state = HybridQueryExecutionContextBaseStates.initialized;\n    }\n  }\n  public async nextItem(diagnosticNode: DiagnosticNodeInternal): Promise<Response<any>> {\n    const nextItemRespHeaders = getInitialHeader();\n    while (\n      (this.state === HybridQueryExecutionContextBaseStates.uninitialized ||\n        this.state === HybridQueryExecutionContextBaseStates.initialized) &&\n      this.buffer.length === 0\n    ) {\n      await this.fetchMoreInternal(diagnosticNode, nextItemRespHeaders);\n    }\n\n    if (this.state === HybridQueryExecutionContextBaseStates.draining && this.buffer.length > 0) {\n      return this.drainOne(nextItemRespHeaders);\n    } else {\n      return this.done(nextItemRespHeaders);\n    }\n  }\n\n  public hasMoreResults(): boolean {\n    switch (this.state) {\n      case HybridQueryExecutionContextBaseStates.uninitialized:\n        return true;\n      case HybridQueryExecutionContextBaseStates.initialized:\n        return true;\n      case HybridQueryExecutionContextBaseStates.draining:\n        return this.buffer.length > 0;\n      case HybridQueryExecutionContextBaseStates.done:\n        return false;\n      default:\n        return false;\n    }\n  }\n\n  public async fetchMore(diagnosticNode: DiagnosticNodeInternal): Promise<Response<any>> {\n    const fetchMoreRespHeaders = getInitialHeader();\n    return this.fetchMoreInternal(diagnosticNode, fetchMoreRespHeaders);\n  }\n\n  private async fetchMoreInternal(\n    diagnosticNode: DiagnosticNodeInternal,\n    headers: CosmosHeaders,\n  ): Promise<Response<any>> {\n    switch (this.state) {\n      case HybridQueryExecutionContextBaseStates.uninitialized:\n        await this.initialize(diagnosticNode, headers);\n        return {\n          result: [],\n          headers: headers,\n        };\n\n      case HybridQueryExecutionContextBaseStates.initialized:\n        await this.executeComponentQueries(diagnosticNode, headers);\n        return {\n          result: [],\n          headers: headers,\n        };\n      case HybridQueryExecutionContextBaseStates.draining:\n        return this.drain(headers);\n      case HybridQueryExecutionContextBaseStates.done:\n        return this.done(headers);\n      default:\n        throw new Error(`Invalid state: ${this.state}`);\n    }\n  }\n\n  private async initialize(\n    diagnosticNode: DiagnosticNodeInternal,\n    fetchMoreRespHeaders: CosmosHeaders,\n  ): Promise<void> {\n    try {\n      while (this.globalStatisticsExecutionContext.hasMoreResults()) {\n        const result = await this.globalStatisticsExecutionContext.nextItem(diagnosticNode);\n        const globalStatistics: GlobalStatistics = result.result;\n        mergeHeaders(fetchMoreRespHeaders, result.headers);\n        if (globalStatistics) {\n          // iterate over the components update placeholders from globalStatistics\n          this.globalStatisticsAggregator.aggregate(globalStatistics);\n        }\n      }\n    } catch (error) {\n      this.state = HybridQueryExecutionContextBaseStates.done;\n      throw error;\n    }\n\n    // create component execution contexts for each component query\n    this.createComponentExecutionContexts();\n    this.state = HybridQueryExecutionContextBaseStates.initialized;\n  }\n\n  private async executeComponentQueries(\n    diagnosticNode: DiagnosticNodeInternal,\n    fetchMoreRespHeaders: CosmosHeaders,\n  ): Promise<void> {\n    if (this.componentsExecutionContext.length === 1) {\n      await this.drainSingleComponent(diagnosticNode, fetchMoreRespHeaders);\n      return;\n    }\n    try {\n      const hybridSearchResult: HybridSearchQueryResult[] = [];\n      const uniqueItems = new Map<string, HybridSearchQueryResult>();\n\n      for (const componentExecutionContext of this.componentsExecutionContext) {\n        while (componentExecutionContext.hasMoreResults()) {\n          const result = await componentExecutionContext.fetchMore(diagnosticNode);\n          const response = result.result;\n          mergeHeaders(fetchMoreRespHeaders, result.headers);\n          if (response) {\n            response.forEach((item: any) => {\n              const hybridItem = HybridSearchQueryResult.create(item);\n              if (!uniqueItems.has(hybridItem.rid)) {\n                uniqueItems.set(hybridItem.rid, hybridItem);\n              }\n            });\n          }\n        }\n      }\n      uniqueItems.forEach((item) => hybridSearchResult.push(item));\n      if (hybridSearchResult.length === 0 || hybridSearchResult.length === 1) {\n        // return the result as no or one element is present\n        hybridSearchResult.forEach((item) => this.buffer.push(item.data));\n        this.state = HybridQueryExecutionContextBaseStates.draining;\n        return;\n      }\n\n      // Initialize an array to hold ranks for each document\n      const sortedHybridSearchResult = this.sortHybridSearchResultByRRFScore(hybridSearchResult);\n      // store the result to buffer\n      // add only data from the sortedHybridSearchResult in the buffer\n      sortedHybridSearchResult.forEach((item) => this.buffer.push(item.data));\n      this.applySkipAndTakeToBuffer();\n      this.state = HybridQueryExecutionContextBaseStates.draining;\n    } catch (error) {\n      this.state = HybridQueryExecutionContextBaseStates.done;\n      throw error;\n    }\n  }\n\n  private applySkipAndTakeToBuffer(): void {\n    const { skip, take } = this.partitionedQueryExecutionInfo.hybridSearchQueryInfo;\n    if (skip) {\n      this.buffer = skip >= this.buffer.length ? [] : this.buffer.slice(skip);\n    }\n    if (take) {\n      this.buffer = take <= 0 ? [] : this.buffer.slice(0, take);\n    }\n  }\n\n  private async drain(fetchMoreRespHeaders: CosmosHeaders): Promise<Response<any>> {\n    try {\n      if (this.buffer.length === 0) {\n        this.state = HybridQueryExecutionContextBaseStates.done;\n        return this.done(fetchMoreRespHeaders);\n      }\n      const result = this.buffer.slice(0, this.pageSize);\n      this.buffer = this.buffer.slice(this.pageSize);\n      if (this.buffer.length === 0) {\n        this.state = HybridQueryExecutionContextBaseStates.done;\n      }\n      return {\n        result: result,\n        headers: fetchMoreRespHeaders,\n      };\n    } catch (error) {\n      this.state = HybridQueryExecutionContextBaseStates.done;\n      throw error;\n    }\n  }\n\n  private async drainOne(nextItemRespHeaders: CosmosHeaders): Promise<Response<any>> {\n    try {\n      if (this.buffer.length === 0) {\n        this.state = HybridQueryExecutionContextBaseStates.done;\n        return this.done(nextItemRespHeaders);\n      }\n      const result = this.buffer.shift();\n      if (this.buffer.length === 0) {\n        this.state = HybridQueryExecutionContextBaseStates.done;\n      }\n      return {\n        result: result,\n        headers: nextItemRespHeaders,\n      };\n    } catch (error) {\n      this.state = HybridQueryExecutionContextBaseStates.done;\n      throw error;\n    }\n  }\n\n  private done(fetchMoreRespHeaders: CosmosHeaders): Response<any> {\n    return {\n      result: undefined,\n      headers: fetchMoreRespHeaders,\n    };\n  }\n\n  private sortHybridSearchResultByRRFScore(\n    hybridSearchResult: HybridSearchQueryResult[],\n  ): HybridSearchQueryResult[] {\n    const ranksArray: { rid: string; ranks: number[] }[] = hybridSearchResult.map((item) => ({\n      rid: item.rid,\n      ranks: new Array(item.componentScores.length).fill(0),\n    }));\n    // Compute ranks for each component score\n    for (let i = 0; i < hybridSearchResult[0].componentScores.length; i++) {\n      // Sort based on the i-th component score\n      hybridSearchResult.sort((a, b) => b.componentScores[i] - a.componentScores[i]);\n\n      // Assign ranks\n      let rank = 1;\n      for (let j = 0; j < hybridSearchResult.length; j++) {\n        if (\n          j > 0 &&\n          hybridSearchResult[j].componentScores[i] !== hybridSearchResult[j - 1].componentScores[i]\n        ) {\n          rank = j + 1;\n        }\n        const rankIndex = ranksArray.findIndex(\n          (rankItem) => rankItem.rid === hybridSearchResult[j].rid,\n        );\n        ranksArray[rankIndex].ranks[i] = rank; // 1-based rank\n      }\n    }\n\n    // Function to compute RRF score\n    const computeRRFScore = (ranks: number[], k: number): number => {\n      return ranks.reduce((acc, rank) => acc + 1 / (k + rank), 0);\n    };\n\n    // Compute RRF scores and sort based on them\n    const rrfScores = ranksArray.map((item) => ({\n      rid: item.rid,\n      rrfScore: computeRRFScore(item.ranks, this.RRF_CONSTANT),\n    }));\n\n    // Sort based on RRF scores\n    rrfScores.sort((a, b) => b.rrfScore - a.rrfScore);\n\n    // Map sorted RRF scores back to hybridSearchResult\n    const sortedHybridSearchResult = rrfScores.map((scoreItem) =>\n      hybridSearchResult.find((item) => item.rid === scoreItem.rid),\n    );\n    return sortedHybridSearchResult;\n  }\n\n  private async drainSingleComponent(\n    diagNode: DiagnosticNodeInternal,\n    fetchMoreRespHeaders: CosmosHeaders,\n  ): Promise<void> {\n    if (this.componentsExecutionContext && this.componentsExecutionContext.length !== 1) {\n      this.logger.error(\"drainSingleComponent called on multiple components\");\n      return;\n    }\n    try {\n      const componentExecutionContext = this.componentsExecutionContext[0];\n      const hybridSearchResult: HybridSearchQueryResult[] = [];\n      while (componentExecutionContext.hasMoreResults()) {\n        const result = await componentExecutionContext.fetchMore(diagNode);\n        const response = result.result;\n        mergeHeaders(fetchMoreRespHeaders, result.headers);\n        if (response) {\n          response.forEach((item: any) => {\n            hybridSearchResult.push(HybridSearchQueryResult.create(item));\n          });\n        }\n      }\n      hybridSearchResult.forEach((item) => this.buffer.push(item.data));\n      this.applySkipAndTakeToBuffer();\n      this.state = HybridQueryExecutionContextBaseStates.draining;\n    } catch (error) {\n      this.state = HybridQueryExecutionContextBaseStates.done;\n      throw error;\n    }\n  }\n\n  private createComponentExecutionContexts(): void {\n    // rewrite queries based on global statistics\n    let queryInfos: QueryInfo[] =\n      this.partitionedQueryExecutionInfo.hybridSearchQueryInfo.componentQueryInfos;\n    if (this.partitionedQueryExecutionInfo.hybridSearchQueryInfo.requiresGlobalStatistics) {\n      queryInfos = this.processComponentQueries(\n        this.partitionedQueryExecutionInfo.hybridSearchQueryInfo.componentQueryInfos,\n        this.globalStatisticsAggregator.getResult(),\n      );\n    }\n    // create component execution contexts\n    for (const componentQueryInfo of queryInfos) {\n      const componentPartitionExecutionInfo: PartitionedQueryExecutionInfo = {\n        partitionedQueryExecutionInfoVersion: 1,\n        queryInfo: componentQueryInfo,\n        queryRanges: this.partitionedQueryExecutionInfo.queryRanges,\n      };\n      this.componentsExecutionContext.push(\n        new PipelinedQueryExecutionContext(\n          this.clientContext,\n          this.collectionLink,\n          componentQueryInfo.rewrittenQuery,\n          this.options,\n          componentPartitionExecutionInfo,\n          this.correlatedActivityId,\n          this.emitRawOrderByPayload,\n        ),\n      );\n    }\n  }\n  private processComponentQueries(\n    componentQueryInfos: QueryInfo[],\n    globalStats: GlobalStatistics,\n  ): QueryInfo[] {\n    return componentQueryInfos.map((queryInfo) => {\n      if (!queryInfo.hasNonStreamingOrderBy) {\n        throw new Error(\"The component query must have a non-streaming order by clause.\");\n      }\n      return {\n        ...queryInfo,\n        rewrittenQuery: this.replacePlaceholdersWorkaroud(\n          queryInfo.rewrittenQuery,\n          globalStats,\n          componentQueryInfos.length,\n        ),\n        orderByExpressions: queryInfo.orderByExpressions.map((expr) =>\n          this.replacePlaceholdersWorkaroud(expr, globalStats, componentQueryInfos.length),\n        ),\n      };\n    });\n  }\n  // This method is commented currently, but we will switch back to using this\n  // once the gateway has been redeployed with the fix for placeholder indexes\n  // private replacePlaceholders(query: string, globalStats: GlobalStatistics): string {\n  //   // Replace total document count\n  //   query = query.replace(\n  //     new RegExp(`{${this.TOTAL_DOCUMENT_COUNT_PLACEHOLDER}}`, \"g\"),\n  //     globalStats.documentCount.toString(),\n  //   );\n\n  //   // Replace total word counts and hit counts from fullTextStatistics\n  //   globalStats.fullTextStatistics.forEach((stats, index) => {\n  //     // Replace total word counts\n  //     query = query.replace(\n  //       new RegExp(`{${this.TOTAL_WORD_COUNT_PLACEHOLDER}-${index}}`, \"g\"),\n  //       stats.totalWordCount.toString(),\n  //     );\n  //     // Replace hit counts\n  //     query = query.replace(\n  //       new RegExp(`{${this.HIT_COUNTS_ARRAY_PLACEHOLDER}-${index}}`, \"g\"),\n  //       `[${stats.hitCounts.join(\",\")}]`,\n  //     );\n  //   });\n\n  //   return query;\n  // }\n\n  private replacePlaceholdersWorkaroud(\n    query: string,\n    globalStats: GlobalStatistics,\n    componentCount: number,\n  ): string {\n    // Replace total document count\n    query = query.replace(\n      new RegExp(`{${this.TOTAL_DOCUMENT_COUNT_PLACEHOLDER}}`, \"g\"),\n      globalStats.documentCount.toString(),\n    );\n    let statisticsIndex: number = 0;\n    for (let i = 0; i < componentCount; i++) {\n      // Replace total word counts and hit counts from fullTextStatistics\n      const wordCountPlaceholder = `{${this.TOTAL_WORD_COUNT_PLACEHOLDER}-${i}}`;\n      const hitCountPlaceholder = `{${this.HIT_COUNTS_ARRAY_PLACEHOLDER}-${i}}`;\n      if (!query.includes(wordCountPlaceholder)) {\n        continue;\n      }\n      const stats = globalStats.fullTextStatistics[statisticsIndex];\n      // Replace total word counts\n      query = query.replace(new RegExp(wordCountPlaceholder, \"g\"), stats.totalWordCount.toString());\n      // Replace hit counts\n      query = query.replace(new RegExp(hitCountPlaceholder, \"g\"), `[${stats.hitCounts.join(\",\")}]`);\n      statisticsIndex++;\n    }\n    return query;\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}