{"ast":null,"code":"import { StatusCodes } from \"../common/statusCodes\";\nimport { HTTPMethod, isReadRequest } from \"../common\";\nimport { Constants } from \"../common/constants\";\nimport { TimeoutErrorCode } from \"../request/TimeoutError\";\n/**\n * This class TimeoutFailoverRetryPolicy handles retries for read operations\n * (including data plane,metadata, and query plan) in case of request timeouts\n * (TimeoutError) or service unavailability (503 status code) by performing failover\n * and retrying on other regions.\n * @hidden\n */\nexport class TimeoutFailoverRetryPolicy {\n  constructor(globalEndpointManager, headers, methodType, resourceType, operationType, enableEndPointDiscovery) {\n    this.globalEndpointManager = globalEndpointManager;\n    this.headers = headers;\n    this.methodType = methodType;\n    this.resourceType = resourceType;\n    this.operationType = operationType;\n    this.enableEndPointDiscovery = enableEndPointDiscovery;\n    this.maxRetryAttemptCount = 120;\n    this.maxServiceUnavailableRetryCount = 1;\n    this.retryAfterInMs = 0;\n    this.failoverRetryCount = 0;\n  }\n  /**\n   * Checks if a timeout request is valid for the timeout failover retry policy.\n   * A valid request should be a data plane, metadata, or query plan request.\n   * @returns\n   */\n  isValidRequestForTimeoutError() {\n    const isQuery = Constants.HttpHeaders.IsQuery in this.headers;\n    const isQueryPlan = Constants.HttpHeaders.IsQueryPlan in this.headers;\n    if (this.methodType === HTTPMethod.get || isQuery || isQueryPlan) {\n      return true;\n    }\n    return false;\n  }\n  async shouldRetry(err, diagnosticNode, retryContext, locationEndpoint) {\n    if (!err) {\n      return false;\n    }\n    if (!retryContext || !locationEndpoint) {\n      return false;\n    }\n    // Check if the error is a timeout error (TimeoutErrorCode) and if it is not a valid HTTP network timeout request\n    if (err.code === TimeoutErrorCode && !this.isValidRequestForTimeoutError()) {\n      return false;\n    }\n    if (!this.enableEndPointDiscovery) {\n      return false;\n    }\n    if (err.code === StatusCodes.ServiceUnavailable && this.failoverRetryCount >= this.maxServiceUnavailableRetryCount) {\n      return false;\n    }\n    if (this.failoverRetryCount >= this.maxRetryAttemptCount) {\n      return false;\n    }\n    const canUseMultipleWriteLocations = this.globalEndpointManager.canUseMultipleWriteLocations(this.resourceType, this.operationType);\n    const readRequest = isReadRequest(this.operationType);\n    if (!canUseMultipleWriteLocations && !readRequest) {\n      // Write requests on single master cannot be retried, no other regions available\n      return false;\n    }\n    this.failoverRetryCount++;\n    // Setting the retryLocationIndex to the next available location for retry.\n    // The retryLocationIndex is determined based on the failoverRetryCount, starting from zero.\n    retryContext.retryLocationServerIndex = await this.findEndpointIndex(this.failoverRetryCount);\n    diagnosticNode.addData({\n      successfulRetryPolicy: \"timeout-failover\"\n    });\n    return true;\n  }\n  /**\n   * Determines index of endpoint to be used for retry based upon failoverRetryCount and avalable locations\n   * @param failoverRetryCount - count of failovers\n   * @returns\n   */\n  async findEndpointIndex(failoverRetryCount) {\n    // count of preferred locations specified by user\n    const preferredLocationsCount = this.globalEndpointManager.preferredLocationsCount;\n    const readRequest = isReadRequest(this.operationType);\n    let endpointIndex = 0;\n    // If preferredLocationsCount is not zero, it indicates that the user has specified preferred locations.\n    if (preferredLocationsCount !== 0) {\n      // The endpointIndex is set based on the preferred location and the failover retry count.\n      endpointIndex = failoverRetryCount % preferredLocationsCount;\n    } else {\n      // In the absence of preferred locations, the endpoint selection is based on the failover count and the number of available locations.\n      if (readRequest) {\n        const getReadEndpoints = await this.globalEndpointManager.getReadEndpoints();\n        if (getReadEndpoints && getReadEndpoints.length > 0) {\n          endpointIndex = failoverRetryCount % getReadEndpoints.length;\n        }\n      } else {\n        const getWriteEndpoints = await this.globalEndpointManager.getWriteEndpoints();\n        if (getWriteEndpoints && getWriteEndpoints.length > 0) {\n          endpointIndex = failoverRetryCount % getWriteEndpoints.length;\n        }\n      }\n    }\n    return endpointIndex;\n  }\n}","map":{"version":3,"names":["StatusCodes","HTTPMethod","isReadRequest","Constants","TimeoutErrorCode","TimeoutFailoverRetryPolicy","constructor","globalEndpointManager","headers","methodType","resourceType","operationType","enableEndPointDiscovery","maxRetryAttemptCount","maxServiceUnavailableRetryCount","retryAfterInMs","failoverRetryCount","isValidRequestForTimeoutError","isQuery","HttpHeaders","IsQuery","isQueryPlan","IsQueryPlan","get","shouldRetry","err","diagnosticNode","retryContext","locationEndpoint","code","ServiceUnavailable","canUseMultipleWriteLocations","readRequest","retryLocationServerIndex","findEndpointIndex","addData","successfulRetryPolicy","preferredLocationsCount","endpointIndex","getReadEndpoints","length","getWriteEndpoints"],"sources":["/Users/ajitpawar/microsoft/bap/POCs/Scenario_checker_for_maker/mcs-scenario-checker-for-maker/node_modules/@azure/cosmos/src/retry/timeoutFailoverRetryPolicy.ts"],"sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport type { RetryPolicy } from \"./RetryPolicy\";\nimport { StatusCodes } from \"../common/statusCodes\";\nimport type { GlobalEndpointManager } from \"../globalEndpointManager\";\nimport { HTTPMethod, isReadRequest } from \"../common\";\nimport type { OperationType, ResourceType } from \"../common/constants\";\nimport { Constants } from \"../common/constants\";\nimport type { RetryContext } from \"./RetryContext\";\nimport type { CosmosHeaders } from \"../queryExecutionContext/CosmosHeaders\";\nimport { TimeoutErrorCode } from \"../request/TimeoutError\";\nimport type { ErrorResponse } from \"../request\";\nimport type { DiagnosticNodeInternal } from \"../diagnostics/DiagnosticNodeInternal\";\n\n/**\n * This class TimeoutFailoverRetryPolicy handles retries for read operations\n * (including data plane,metadata, and query plan) in case of request timeouts\n * (TimeoutError) or service unavailability (503 status code) by performing failover\n * and retrying on other regions.\n * @hidden\n */\nexport class TimeoutFailoverRetryPolicy implements RetryPolicy {\n  private maxRetryAttemptCount = 120;\n  private maxServiceUnavailableRetryCount = 1;\n  public retryAfterInMs = 0;\n  public failoverRetryCount = 0;\n  public request: any;\n  public locationEndpoint: any;\n\n  constructor(\n    private globalEndpointManager: GlobalEndpointManager,\n    private headers: CosmosHeaders,\n    private methodType: HTTPMethod,\n    private resourceType: ResourceType,\n    private operationType: OperationType,\n    private enableEndPointDiscovery: boolean,\n  ) {}\n\n  /**\n   * Checks if a timeout request is valid for the timeout failover retry policy.\n   * A valid request should be a data plane, metadata, or query plan request.\n   * @returns\n   */\n  private isValidRequestForTimeoutError(): boolean {\n    const isQuery = Constants.HttpHeaders.IsQuery in this.headers;\n    const isQueryPlan = Constants.HttpHeaders.IsQueryPlan in this.headers;\n    if (this.methodType === HTTPMethod.get || isQuery || isQueryPlan) {\n      return true;\n    }\n    return false;\n  }\n\n  public async shouldRetry(\n    err: ErrorResponse,\n    diagnosticNode: DiagnosticNodeInternal,\n    retryContext?: RetryContext,\n    locationEndpoint?: string,\n  ): Promise<boolean> {\n    if (!err) {\n      return false;\n    }\n    if (!retryContext || !locationEndpoint) {\n      return false;\n    }\n    // Check if the error is a timeout error (TimeoutErrorCode) and if it is not a valid HTTP network timeout request\n    if (err.code === TimeoutErrorCode && !this.isValidRequestForTimeoutError()) {\n      return false;\n    }\n    if (!this.enableEndPointDiscovery) {\n      return false;\n    }\n    if (\n      err.code === StatusCodes.ServiceUnavailable &&\n      this.failoverRetryCount >= this.maxServiceUnavailableRetryCount\n    ) {\n      return false;\n    }\n    if (this.failoverRetryCount >= this.maxRetryAttemptCount) {\n      return false;\n    }\n    const canUseMultipleWriteLocations = this.globalEndpointManager.canUseMultipleWriteLocations(\n      this.resourceType,\n      this.operationType,\n    );\n    const readRequest = isReadRequest(this.operationType);\n\n    if (!canUseMultipleWriteLocations && !readRequest) {\n      // Write requests on single master cannot be retried, no other regions available\n      return false;\n    }\n    this.failoverRetryCount++;\n    // Setting the retryLocationIndex to the next available location for retry.\n    // The retryLocationIndex is determined based on the failoverRetryCount, starting from zero.\n    retryContext.retryLocationServerIndex = await this.findEndpointIndex(this.failoverRetryCount);\n    diagnosticNode.addData({ successfulRetryPolicy: \"timeout-failover\" });\n    return true;\n  }\n\n  /**\n   * Determines index of endpoint to be used for retry based upon failoverRetryCount and avalable locations\n   * @param failoverRetryCount - count of failovers\n   * @returns\n   */\n  private async findEndpointIndex(failoverRetryCount: number): Promise<number> {\n    // count of preferred locations specified by user\n    const preferredLocationsCount = this.globalEndpointManager.preferredLocationsCount;\n    const readRequest = isReadRequest(this.operationType);\n    let endpointIndex = 0;\n    // If preferredLocationsCount is not zero, it indicates that the user has specified preferred locations.\n    if (preferredLocationsCount !== 0) {\n      // The endpointIndex is set based on the preferred location and the failover retry count.\n      endpointIndex = failoverRetryCount % preferredLocationsCount;\n    } else {\n      // In the absence of preferred locations, the endpoint selection is based on the failover count and the number of available locations.\n      if (readRequest) {\n        const getReadEndpoints = await this.globalEndpointManager.getReadEndpoints();\n        if (getReadEndpoints && getReadEndpoints.length > 0) {\n          endpointIndex = failoverRetryCount % getReadEndpoints.length;\n        }\n      } else {\n        const getWriteEndpoints = await this.globalEndpointManager.getWriteEndpoints();\n        if (getWriteEndpoints && getWriteEndpoints.length > 0) {\n          endpointIndex = failoverRetryCount % getWriteEndpoints.length;\n        }\n      }\n    }\n    return endpointIndex;\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}